NetHack 4
=========

NetHack 4 is a modernized, network-capable fork of NetHack, with an improved
interface.  It was produced by merging two forks: Alex Smith's AceHack, and
Daniel Thaler's NitroHack.


Back end features:

* NetHack network protocol

  NetHack 4 supports network play without telnet or ssh over its own
  protocol.  The protocol is based on JSON and should make it very easy to
  implement a browser-based NetHack client (TODO!).

* New save game format

  The old format was mostly just a dump of the data structures from memory
  onto disk.

  The new format has 3 sections:

  1. A log of the initial random seed and every game action performed
     afterwards.  This allows a perfect reconstruction of the game.

  2. A binary save after every move (stored as diffs to keep file sizes
     reasonable).  It uses a fixed-width, fixed-endian architecture and
     compiler independent format, but is otherwise a direct descendant of
     the old format.  This also allows a perfect reconstruction of the
     game; and also allows games to be replayed after changes are made
     that would affect sync.  It is stored interleaved with the log.

  3. For speed, a binary save as binary, that enables games to be loaded
     without replaying them from the start.  If something goes wrong with
     loading this section, one of the others can be used instead.

  The log file is written continuously, so the "INSURANCE" option and the
  recover utility are gone - a crashed game can always be restored by
  replaying the log.  After the game ends, the log marked as closed and kept.

* Built in game replay viewing (aka new and improved ttyrec)

  The reason for keeping logs of finished games.  Once there was a way to
  reconstruct the state of the game at any point it would have been silly not
  to use it for game viewing.

  Since the replay mode is based on abstract game state rather than directly
  recorded screen output, it is completely feasible to replay a that was
  played on a unix tty in a windows tile port or vice versa.   A viewer for
  games is built into the new nethack UI.  You can perform commands that don't
  affect the game state (like view inventory) while viewing a game replay.

* New options code

  Options changed ingame are written back to the options file, which you are
  not supposed to edit by hand any more.  The options have moved from
  ~/.nethackrc to ~/.config/NetHack4/NetHack.conf (for game options) and
  ~/.config/NetHack4/curses.conf for the options of the uncursed UI.  Logs of
  active and completed games are also under ~/.config/NetHack4/, along with
  dump files that summarize what happened in a game.

* Birth options

  Want to play without Elbereth? It is now possible to do so without
  recompiling.  ELBERETH, REINCARNATION, SEDUCE and bones files have become a
  new kind of option: birth options, which can only be set before the
  character is created.

* Full separation of user interface code from game code.

  The core game code is now independent of the rest of the game, and in fact
  can be treated as a library.  The game library exposes an API of exactly 23
  functions and is largely OS independent.  The display code is part of the
  OS/platform dependent executable and must provide a list of callbacks
  (windowprocs) to the game.  There is no shared global state between the two.
  This was a prerequisite for the network protocol, which encodes the API
  calls and callbacks almost literally.

  With this change, the days of multiple window port binaries are over.  It
  now makes much more sense to have separate programs, for example
  nitrohack-qt and xnitrohack.
  The NitroHack network server is technically a UI port and uses the same
  mechanisms.

* Rewritten input system

  The game core never, ever requests a key from the UI.  All interactions
  happen on an abstract level: The ui sends commands to the core as a string
  ("wait", "move", etc.), the game my request a direction or a position
  (etc).

  This allows the UI to perform key mapping safely, because it is never
  necessary to guess what context some request for input occurs in.

* All-new uncursed-based text mode UI

  All the old window ports became obsolete due to the extensive API
  changes.   A new UI based on uncursed (a curses-like terminal rendering
  library) has been written.  It is a significant upgrade compared to the
  old tty port in terms of usability and features:

  * unicode display, with customizable display chars
  * configurable keymap, with a configuration dialog
  * full arrow key and function key use
  * multiple visible message lines and automore (if your terminal is high)
  * improved status lines (based on AceHack's status code)
  * permanent inventory display (if your terminal is wide)
  * inventory menu with item actions
  * real line editing

* Layered drawing

  The game core provides a set of display items for each location to the UI,
  rather than a single display char.  For example a monster on an item on a
  trap can be represented logically, and drawn in the UI.

* Mersenne twister random number generator

  An OS independent RNG with known state was required in order to make game
  logs replayable.  The mersenne twister is the best choice.

* Re-runnable game core.

  Several of the main data structures have been made const, all others are
  carefully re-initialized when a game is started or loaded.

  This makes it possible to have a main menu for starting games, viewing the
  top ten or changing options.

  Previously this was not possible, as the altered global state from one
  game would have affected a second, so quitting was the only option.
  NetHack now uses an exception mechanism based on setjmp/longjmp to
  escape from deep callchains when the game ends or panics.

* No more level files and no more lock files.

  All levels are now kept in memory at all times.  This makes a lot of
  locking unnecessary.  It also allows viewing of levels you are not
  currently on.

  The only remaining locking is of active game logs via OS mechanisms which
  are not based on files: fcntl on UNIX and LockFile on Windows.

* Code cleanups

  The number of `#ifdef FOO` has been dramatically reduced.  That makes the
  code much more readable, because the indentation isn't being interrupted
  every couple of lines.  To this end almost all compile options that
  didn't become birth options were enabled unconditionally or removed due
  to being obsolete.  Code for compatibility with very old systems has been
  removed, at least partly because it's very hard to tell if it still
  works.

  All functions have been converted to use standard prototypes rather than
  K&R declarations.  Ugly things like prototype widening and the follow-on
  <FOO>_P #defines went away.  Tools like git diff can now correctly show
  what function a line is in.

  All instances of the keyword "register" have been removed - optimizing
  compilers handle this for us.  Likewise NEARDATA; that only made sense on
  16-bit computers.

* New build systems

  Rather than using the old MakeFiles which required manual configuration,
  NetHack 4 now uses the aimake build system.  (Previously it had support
  for both aimake and CMake, but the CMake build was gettting increasingly
  hard to maintain.)

Game features:

* Autopickup rules

  Real rule sets that control what gets picked up replace the pickup list +
  exceptions system.  Rules can match based on the name, object type and BUC
  status.

  The following rule set picks up all food as well as lizard corpses, but
  no other corpses:

        1. IF name matches "*lizard*" AND type is "food": < GRAB
        2. IF name matches "*corpse*" AND type is "food":   LEAVE >
        3. IF type is "food":                             < GRAB

  Rules are evaluated in order until a matching rule is found. If no rule
  matches, the item is left behind by default.

* Character history tracking

  NetHack 4 will automatically track the following items (with a turn
  timestamp) for use in your ascension posts:

  * new depth reached
  * new experience level reached
  * wishes with the exact wish text
  * killed a unique monster
  * lifesaved
  * crowning
  * artifact gifts
  * basic quest status
  * major oracle consultations
  * performed the invocation
  * gained/lost the amulet of yendor (only shown if the amulet is identified)

  You can view your heroic deeds with #history.

* Dungeon overview + dungeon annotations

  This change was inspired by the "Dungeon Map Overview 3" patch (by Hojita
  Discordia), as found in several variants (in addition to AceHack and
  NitroHack, notably UnNetHack).

  You can now #annotate a level to name/describe it.  #overview / Ctrl+O will
  show a menu of all the levels you remember including your annotations and
  significant features (shops, altars, ...)  You can select a level from the
  overview menu to view your memory of it.

* Dump log

  Inspired by Jukka Lahtinen's dumplog patch.

  When you die, a dump log containing the following information will be
  created:

  * Final (ascii) screenshot
  * Player stats
  * Full inventory, including listings of the contents of containers
  * Player attributes
  * Known spells
  * Skills
  * Conducts
  * Vanquished opponents
  * Final messages
  * dungeon overview
  * heroic deeds

* Sorted loot

  Based on code by Jukka Lahtinen and Patric MÃ¼ller in UnNetHack.

  Item types are sorted based on:

  1. item name
  2. enchantment
  3. BUC
  4. erodeproofing
  5. erosion
  6. greasedness

* Various miscellaneous changes, mostly from AceHack.

* In addition, a large number of vanilla bugs have been fixed (although
  there are an even larger number of vanilla bugs still to fix).

What didn't change:

* The game mechanics, monsters, items etc. are pretty similar to those in
  NetHack 3.4.3; although many of these need changing, we're being very
  cautious about what we change, so as to avoid creating yet another fork
  which increases difficulty in an inconsistent way that imbalances the game.

* There is a lot of code in the core that remains very obscure, because the
  cleanups only improved it superficially.

Build Instructions
==================

UNIX/Linux
----------

You will need to install NetHack 4's dependencies: zlib (which is probably
installed already, but you may need to get its development headers from your
package manager), and (if you want a working server binary) postgresql and
pgcrypto. You also need development headers for those libraries. If you don't
care about the server working, you can do without postgresql; you'll get
compile errors as it tries to compile the server, but the programs that do
install (including the game itself, which can run locally without needing to
connect to a server) will work fine.

Assuming you just want to run NetHack 4 from your home directory, from the top
source directory, run:

    mkdir build
    cd build
    ../aimake -i ~/nethack4 .. # or wherever you want

Currently, system-wide installing (one installation for all users with shared
high scores and bones, how NetHack is traditionally installed) is currently
slightly nontrivial due to problems with permissions, and thus is not
recommended.  If you want to try it, I recommend reading aimake's
documentation:

    aimake --documentation

If you want to run your own server (which is only necessary/useful if you want
people to be able to connect to your NetHack 4 server from other computers,
rather than running locally), you'll also need to set up the postgresql
database:

    su postgres             # or any other way to elevate your permissions
    createuser -DPRS nh4server
    # You'll be prompted for a password at this point.
    createdb -O nh4server nethack4
    echo 'CREATE EXTENSION pgcrypto' | psql -d nethack4
    exit                    # go back to your normal permissions

Next you need to edit the configuration file (a blank configuration file will
have been installed in the appropriate place for you to edit). If you
installed into `~/nethack4`, it should be named
`~/nethack4/config/nethack4.conf`; other forms of install may have other
locations. (You can run nethack4-server with no arguments to discover where
the configuration file should be; if it can't find its configuration file,
it'll complain and tell you where it's looking for it.)

The configuration file looks something like this:

    dbhost=127.0.0.1
    dbport=5432
    dbuser=nh4server
    dbpass=**password**
    dbname=nethack4

Note that the port number has been known to vary based on the way that your
copy of postgresql is packaged; you may want to verify it by looking at
postgresql's configuration, `/etc/postgresql/.../postgresql.conf`. Also be
aware that the configuration file necessarily has to store the password in
plaintext (a hashed password is no good for actually logging into the
database); you may want to change the permissions on the configuration file to
help protect it. (I recommend using a long random password, because it's only
used by computers; there's no need for humans to memorize it.)

Now you can just run the `nethack4-server` binary to start the server; it will
daemonize itself. To test your server setup, you can use the `nethack4`
client; there's a menu option to connect to a server with it.

The easiest way to stop the `nethack4-server` binary is to run
`nethack4-server -k`, which will automatically work out which process is the
server from its pidfile, and tell it to stop.

Windows
-------

You will need to install various prerequisite programs in order to compile
NetHack 4. The build system is written in Perl, and as such, the simplest way
to get a working toolchain is to install Strawberry Perl, available at
http://strawberryperl.com, which comes with a working C toolchain. You will
also need to install Flex and Bison, scanner and parser generators; the
versions at GnuWin32 (http://gnuwin32.sourceforge.net/) work (although they
don't have a very Windows-like idea of directory structure). Strawberry Perl's
and GnuWin32's executables will all need to be on your PATH (search for "PATH"
in Control Panel, on recent versions of Windows).

You will also need to create two more folders, `build` and `install`; I
recommend that both are parallel to the `nethack4` folder that contains the
entire NetHack 4 distribution.

Once you've done this, open a command prompt, change to the build directory,
and type:

    perl ../nethack4/aimake -i ../install --directory-layout=single_directory

aimake should compile and install the entirety of NetHack 4 for you into the
install directory. In order to run it, change directory to the install
directory, and type `nethack4`.

Note that at present, the game is very slow to render on recent versions of
Windows; this is because the Windows console is massively slow. (For a
comparison, you can try running a command that produces a lot of text, such as
`perl ../nethack4/aimake --documentation`, and observing how long it takes to
scroll the screen when you press the spacebar.)
