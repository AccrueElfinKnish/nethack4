/* vim:set cin ft=c sw=4 sts=4 ts=8 et ai cino=Ls\:0t0(0 : -*- mode:c;fill-column:80;tab-width:8;c-basic-offset:4;indent-tabs-mode:nil;c-file-style:"k&r" -*-*/
/* Last modified by Alex Smith, 2013-09-23 */
/* NetHack may be freely redistributed.  See license for details. */

#include <stdlib.h>
#include <stdio.h>
#include "tilesequence.h"

/*
 * ALI
 *
 * Compute the value of ceil(sqrt(c)) using only integer arithmetic.
 *
 * Newton-Raphson gives us the following algorithm for solving sqrt(c):
 *
 *            a[n]^2+c
 * a[n+1]  =  --------
 *             2*a[n]
 *
 * It would be tempting to use a[n+1] = (a[n]^2+c+2*a[n]-1) div 2*a[n]
 * to solve for ceil(sqrt(c)) but this does not converge correctly.
 * Instead we solve floor(sqrt(c)) first and then adjust as necessary.
 *
 * The proposed algorithm to solve floor(sqrt(c)):
 *
 * a[n+1] = a[n]^2+c div 2*a[n]
 *
 * If we define the deviation of approximation n as follows:
 *
 * e[n] = a[n] - sqrt(c)
 *
 * Then it follows that:
 *
 *              e[n]^2
 * e[n+1] = ---------------
 *          2(e[n]+sqrt(c))
 *
 * The sequence will converge to the solution if:
 *
 * | e[n+1] | < | e[n] |
 *
 * which becomes:
 *
 *                      |     e[n]^2      |
 *                      | --------------- | < | e[n] |
 *                      | 2(e[n]+sqrt(c)) |
 *
 * This splits into three cases:
 *
 * If e[n] > 0          * If 0 > e[n] >= -sqrt(c) * If e[n] < -sqrt(c)
 *                      *                         *
 * Converges iff:       * Converges iff:          * Converges iff:
 *                      *             2           *
 *    e[n] > -2*sqrt(c) *    e[n] > - - sqrt(c)   *    e[n] > -2*sqrt(c)
 *                      *             3           *
 *                      *                 sqrt(c) *
 * True for all cases.  * True iff a[n] > ------- * True iff 0 > a[n] > -sqrt(c)
 *                      *                    3    *
 *
 * Case 3 represents failure, but this can be avoided by choosing a positive
 * initial value. In both case 1 and case 2, e[n+1] is positive regardless
 * of the sign of e[n]. It therefore follows that even if an initial value
 * between 0 and sqrt(c)/3 is chosen, we will only diverge for one iteration.
 *
 * Therefore the algorithm will converge correctly as long as we start
 * with a positve inital value (it will converge to the negative root if
 * we start with a negative initial value and fail if we start with zero).
 *
 * We choose an initial value designed to be close to the solution we expect
 * for typical values of c. This also makes it unlikely that we will cause
 * a divergence. If we do, it will only take a few more iterations.
 */

static int
ceil_sqrt(int c)
{
    int a = c / 36, la; /* Approximation and last approximation */

    /* Compute floor(sqrt(c)) */
    do {
        la = a;
        a = (a * a + c) / (2 * a);
    } while (a != la);
    /* Adjust for ceil(sqrt(c)) */
    return a * a == c ? a : a + 1;
}


int
main(int argc, char** argv)
{
    int i;
    FILE *ifp, *ofp;
    char in_line[4096];

    /* We take three arguments: header file template, header file output, map
       file output. */
    if (argc != 4) exit(1);

    /* 
     * create the map file, "tile.map"
     */
    if (!(ofp = fopen(argv[3], "w"))) {
        perror(argv[3]);
        exit(EXIT_FAILURE);
    }
    for (i = 0; i < TILESEQ_COUNT; i++)
        fprintf(ofp, "%s\n", name_from_tileno(i));
    fclose(ofp);

    /* 
     * create the include file, "tile.h"
     */
    if (!(ifp = fopen(argv[1], "r"))) {
        perror(argv[1]);
        exit(EXIT_FAILURE);
    }
    if (!(ofp = fopen(argv[2], "w"))) {
        perror(argv[2]);
        exit(EXIT_FAILURE);
    }
    fprintf(ofp, "/* This file is automatically generated.  Do not edit. */\n");

    fprintf(ofp, "\n#define TOTAL_TILES_USED %d\n", TILESEQ_COUNT);
    i = ceil_sqrt(TILESEQ_COUNT);
    fprintf(ofp, "#define TILES_PER_ROW %d\n", i);
    fprintf(ofp, "#define TILES_PER_COL %d\n\n", (TILESEQ_COUNT + i - 1) / i);

    while (fgets(in_line, sizeof in_line, ifp) != 0)
        (void)fputs(in_line, ofp);

    fprintf(ofp, "\n/*tile.h*/\n");

    fclose(ifp);
    fclose(ofp);

    return EXIT_SUCCESS;
}

