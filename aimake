#!/usr/bin/perl
use utf8;     # this source file is UTF-8
use warnings;
use strict;

# aimake: automated build system for C programs
# Copyright â’¸ 2013 Alex Smith.
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# A copy of version 3 of the GNU General Public License is embedded in
# the documentation later in this file, and can most conveniently be
# viewed via running this file with the --license option.
# Alternatively, it can be viewed in this file's source, or online at
# <http://www.gnu.org/licenses/>.

####### Documentation

=encoding utf8

=head1 NAME

aimake - build and/or install C programs with minimal configuration

=head1 SYNOPSIS

The most common way to build and install a program using aimake is:

B<mkdir> F<build>; B<cd> F<build>; F<../aimake> B<-i> F<installdir>

Commonly used options:

=over 4

=item B<-v>

Produce more verbose output (can be given multiple times).

=item B<-i> F<directory>

Install the program into the specified directory, as well as building it.

=back

For full documentation on F<aimake>, use the B<--documentation> argument.

=head1 DESCRIPTION

B<aimake> is a build system for C programs that attempts to deduce as much as
possible itself, rather than requiring a separate file along the lines of
C<Makefile>, C<config.ac>, or C<CMakeLists.txt>.  In the most common cases, no
configuration file is required at all, although a rudimentary configuration
file can be used to specify more complicated things that cannot be
automatically deduced (such as which files contain the entry points to
libraries, or what commands to use to generate generated source files).

To compile a project with aimake for the first time, create an empty
directory, then call aimake from that directory.  By default, it will compile
the source files in the same directory tree as F<aimake> itself.  You can use
a version of aimake other than the version shipped with the project by running
your version of aimake (from the build directory), and giving the path to the
root of the project's distribution as an argument.  To rebuild the project,
call aimake with no arguments in your build directory.  To install it, call
aimake with the B<-i> switch, and specify where you want to install it (you
can use just B<-i> by itself to install in the same place as last time).

=head1 OPTIONS

=over 4

=item B<-v>, B<--verbose=>I<number>

Set how verbose the build should be.  The default level is 0; higher values
produce more verbose output.  (You can get higher values via specifying a
number, or via specifying the B<-v> option multiple times.)  The messages you
get at each verbosity level are:

=over 4

=item -v-2

No messages at all.  Even important ones.

=item -v-1

Messages about warnings, errors, and failures to compile.  No messages will be
printed if everything works correctly.

=item -v0

Level -1 messages, plus messages about operations that aimake is performing
that actually contribute to compiling the code (e.g. running compilers,
linkers, and so on).  At level 0 and above, aimake also displays the details
of what it is thinking temporarily, using one line that repeatedly changes.

=item -v1

Level 0 messages, plus messages about other operations that aimake performs
(such as determining dependencies).

=item -v2

Level 1 messages, plus a record of all the actual commands that are run.
Additionally, the temporary messages about what aimake is doing are left on
the screen, rather than removed.

=item -v4

Level 2 messages, plus information useful mostly for debugging aimake itself.

=item -v5

Level 4 messages, plus particularly verbose information useful mostly for
debugging aimake itself.

=back

=item B<-i> F<directory>, B<--install=>F<directory>

After building (if necessary), install the project into the given directory.
The directory can be omitted, in which case it will use the same install
directory as last time.

The specific directories to install in are deduced from the directory given.
For instance, if on a UNIX/Linux system you gave F</usr/local> as the
directory to install into, aimake would put the application's read-write data
files under F</var/local>, whereas installing into F</usr> would put them
under F</var/lib>, and installing into F</home/user/package> would put them
inside the install directory.  You can control the details of the install with
the B<--directory-layout> option or "directory_layout" configuration option.

=item B<-W> I<regexp>, B<--show-warnings>=I<regexp>

Instead of compiling, output all error and warning messages that were obtained
during the last compile, for files matching the given regexp.  (Don't include
the // around the regexp.)

This option is currently unimplemented.

=item B<-B> I<regexp>, B<--rebuild=>I<regexp>

Consider all files matching the regexp to have changed, even if they actually
haven't.  (Don't include the // around the regexp.)  This option can be given
multiple times.

This option is currently unimplemented.

=item B<--directory-layout>=I<layout>

Change how the specific install directories are chosen.  The possible values
with the default configuration are:

=over 4

=item fhs

Install into the appropriate system directories that are intended to be
managed by the package manager on a UNIX/Linux system; the install directory
should be F</usr> or F</>.  This is automatically chosen as the layout when
installing into F</usr> or F</>.  This option would mostly be used by package
managers; B<--destdir> would also be used for package managers that operated
using binary packages (as oppose to directly from source).  ("FHS" stands for
"File Hierarchy Standard", the standard that specifies which files should be
placed in which directories on a UNIX or Linux system.)

=item fhs_unmanaged

Install into the appropriate system directories on a UNIX/Linux system,
avoiding directories that are normally maintained by package managers.  This
is automatically chosen as the layout when installing into F</usr/local>, the
only reasonable choice for directory, and so there should rarely be a need to
specify it explicitly.  (Most build systems have F</usr/local> as the default
install directory on UNIX/Linux; however, aimake will not install into system
directories unless the user explicitly requests it to.)

=item fhs_package

Install into system directories specific to the package being installed; every
file will be placed into the install directory (by default,
F</opt/packagename>), into F</etc/opt/packagename>, or into
F</var/opt/packagename>.  This install layout is often used to make it easy to
install and uninstall packages by hand.

=item single_user

Place all the installed files in appropriate subdirectories of the given
directory.  This works on any operating system, and is the default when the
install directory given is unrecognised, or recognised as a user's home or
documents directory.  (Note that this sort of install makes the program
available only to one user, rather than system-wide.)

=item single_directory

Place everything into the same directory, no subdirectories involved (unless
the configuration for the specific project requests that empty subdirectories
are created).  This is also special-cased to cause the program being installed
to look for its data in the current directory, rather than memorizing the path
it was installed to, even if it instructs aimake to tell it the install path.

=back

=item B<--destdir=>F<directory>

When installing, treat the given directory as the root directory, rather than
using the actual root directory.  (For instance, giving B<-i> F</usr>
B<--destdir> F</home/user> would install into F</home/user/usr>, but the
installed program would look for paths as if it had been installed into
F</usr>.)  This is intended for use in packaging programs, and when installing
into a chroot from outside the chroot.  This option may only be given if the
install directory is outside the source directory and outside the build
directory (otherwise, it's not quite clear what it would mean).

=item B<--documentation>

Show the full documentation for aimake.

=item B<--license>

Show the license/copyright information for aimake.

=item B<--no-carriage-return>

Don't use carriage returns to provide progress information.  (This is mostly
only useful if stdout is not a terminal).

=item B<--dump-status>

=item B<--dump-status=subset>

Instead of compiling, dump the internal statefile to stdout in a
human-readable format.  This is mostly only useful for debugging aimake.

It is possible to specify a subset of the statefile to dump as a
comma-separated sequence of keys (e.g. 'xuse_by_object,config_option:libdir').
On large projects, this is considerably faster than dumping the entire
statefile if you are only interested in a small portion of it.

=item B<--ignore-builtin-config>

Ignore all the built-in rules and options, reading configuration only from the
project-specific configuration file.  aimake only has minimal functionality
with no rules (for instance, it will not even check for changes to files in
the source directory), and as such, this is mostly only useful for testing
aimake, or if you want to use aimake's engine for something radically
different from compiling C and have a complex configuration file handy for
that alternative use.  (The built-in directory layouts are not ignored, but
they will not be used for anything if directory_layout is set to something
other than a built-in directory layout.)

=item B<--version>

Show aimake's version number (and a summary of the license).

=item B<--help>

Show a short usage message for aimake (that omits most of the options).

=back

=head1 WHY AIMAKE?

Build systems like B<make> work via an explicitly given directed graph of
dependencies.  The user specifies which files they want to rebuild (although
most Makefiles specify a default, this still needs to be given explicitly),
then B<make> recurses depth-first through the dependencies, rebuilding each
file that is older than any of its dependencies.

There are several problems with this approach.  The main problem is that it
costs a lot of programmer time; whenever any changes are made to the
dependency graph (most commonly due to adding a new source file or new
target), the programmer must alter the Makefile to specify the new
relationships between files.  This problem was enough to motivate the creation
of aimake by itself.  Dependency tracking is something that can be done by a
computer almost as easily (and much more quickly) than a human can, given the
existence of dependency-determining programs such as B<cpp -M> (for C header
files) or B<nm> (for object files and libraries).

There are some other, more minor, problems:

=over 4

=item *

Makefiles cannot handle dependencies on anything other than files (which
means, for instance, that you cannot write a Makefile that recompiles only the
affected files when a Makefile rule is changed, because a Makefile rule is not
a file, and splitting all the rules into separate files would be ridiculous).
Instead of using files as the basic unit of dependencies, aimake uses the more
general concept of an "object", which could be a file, but which could also be
something like a rule or option in a configuration file.  As such, changing
part of your project's configuration will only recompile the parts of your
project that were actually affected by that part of the configuration.

=item *

Makefiles are inherently somewhat platform-specific.  One reason is that
Makefile rules are written as lists of shell commands, and not all shells
behave in the same way.  (For instance, filename formats vary between
operating systems; so does the way filenames containing spaces are escaped.)
aimake works around this via mandating a standard filename format in its
configuration files (that it translates to an appropriate format for the
operating system), and emulating many commands itself (although it necessarily
has to use the C toolchain from the system; an entire C compiler and linker
would be outside the scope of a single Perl script a few hundred kilobytes
long).

=item *

B<make> itself might not always exist, or might use a nonstandard syntax on
some systems, making it hard to write a truly portable Makefile (especially if
you want to do things like out-of-tree build, which is the only sort of build
aimake supports; in-tree builds are hard to debug and hard to clean up, and
also prevent you performing multiple builds from the same source but with
different options).  aimake was intentionally written so that it could be a
single file that could be shipped with a distribution and run on all commonly
used operating systems.  This meant that it had to be written in a scripting
language (otherwise it would need to itself be compiled, thus require a build
system, leading to a chicken-and-egg problem), and ideally one that came
pre-installed on as many systems as possible.  There were only really two
languages that fit these criteria: Perl, and Python.  Perl was chosen mostly
because I was more familiar with it, but it also has the advantage that the
most commonly used Perl distribution on Windows (Strawberry Perl) ships with a
working C toolchain that works with aimake, meaning that only one extra
program needs to be installed to use aimake on Windows.

=item *

B<make> gets very confused when a file's timestamps are changed in a way it
doesn't expect.  (This happens most commonly when the computer doing the build
is a different computer from the computer where the files to build are stored,
and the clocks on the computers are not perfectly in sync.)  Likewise, it
rebuilds a file if any of its dependencies changed modification time, even if
the file itself did not change.  aimake works around these problems via using
the hash of a file in addition to its modification timestamp; if the timestamp
changes at all (forwards or backwards), or in cases where the file might
plausibly have changed multiple times within the resolution of its timestamp,
the file's hash is recomputed to see if its contents also changed.

=item *

Upon recompiling a large project, if there's an error, B<make> has two modes
of operation: stopping after the error (so that only errors from one file are
visible), or continuing anyway (meaning that although all the errors are
visible, all the files have to be recompiled on the next run even if only
errors in one file are fixed and nothing has changed in the others).
B<make>'s behaviour on warnings is even worse: it will display them once, but
on subsequent compiles, the warnings will no longer be visible because the
compiler will not be re-run, and the warnings were not saved anywhere.  aimake
remembers warning and error messages, meaning that warnings will not be lost
upon recompilation, and programs won't run unless their inputs have changed,
even if they errored out or produced no output.

=item *

Many programs need to be able to inspect information given to the build system
(for instance, to learn which directory their data files will eventually be
installed in, so that they can locate them at runtime).  This is quite
difficult to set up in many build systems (and B<make> has no native concept
of an install path, meaning that some external tool is needed to set a prefix
or the like).  In aimake, doing this (for C, at least) is as simple as writing
strings like "AIMAKE_OPTION_datadir" in the source files you're compiling; if
any of those strings are detected, it'll #define it to the appropriate value
for you.  Similar mechanisms exist to detect the platform you're running on.

=item *

Errors in writing a Makefile can be hard to debug or even notice; a missing
dependency, for instance, may only cause a build failure under very specific
conditions.  Although aimake cannot entirely eliminate human error, it can
detect some common mistakes (e.g. it will complain if a command has an output
that's on the filesystem but outside the build directory), and the greatly
reduced amount of configuration also means that there's less of an opportunity
to make mistakes.  I initially wrote the first version of aimake because cmake
was unexpectedly rebuilding the entire project I was working on from scratch
every time I made even a small change; it eventually turned out that I'd
accidentally introduced a dependency loop in the project, with a program that
generated files being built from the files it generated.  aimake can warn
about this sort of problem if it's introduced into a project later than the
initial build.  (It's impossible in general to warn about it on the first
build because none of the files that depend on each other can be generated in
the first place, making it impossible to determine what files they'd
generate.)

=back

Many other build tools are available that try to fix one or more of these
problems, but as far as I know, aimake is the only program which tries to fix
them all at once.

=head1 ADAPTING A SOURCE TREE FOR USE WITH AIMAKE

aimake is designed to be as easy as possible to use with new projects, and as
such it often works with unmodified source and no project-specific
configuration file.  However, there are some steps you can take to get the
best possible result.

First, make sure that the directory layout of your source tree reflects the
dependencies between files; this is to help it resolve ambiguities.  It mostly
doesn't matter if all your symbols have different name, but if you declare the
same function or variable in multiple files, aimake will need to know which to
link against.  It will favour linking against files that it has to link to
anyway, but when all else fails, it will fall back to linking to files in the
same directory (and with as many matching characters as possible at the start
of the filename, as a second tiebreak).  Also make sure that files have
appropriate extensions (F<.c> for C files, F<.cxx> for C++ files, F<.h> for
headers, etc.).

Next, you can use some aimake-specific macros in your C and C++ source and
header files.  One reason to do this would be if you have code specific to one
operating system; you can use C<AIMAKE_BUILDOS_> macros to conditionalize your
code to one operating system, for instance C<AIMAKE_BUILDOS_linux>,
C<AIMAKE_BUILDOS_MSWin32>, or C<AIMAKE_BUILDOS_darwin> (typically indicating
Mac OS X).  (The possibilities for the build OS are taken from Perl's C<$^O>
operating system identification variable.)  Another is to make your code
depend on aimake configuration options; you can write
C<AIMAKE_OPTION_packagename> to discover the package name, for instance.  (You
can use any configuration option or install directory this way; aimake will
recompile the file in question whenever the the relevant option or directory
is changed.)  Note that the option value will be used as-is; if you want it as
a C string, stringify it as follows:

    #define STRINGIFY_EXPAND(x) STRINGIFY(x)
    #define STRINGIFY(x) #x
    #define PACKAGENAME_AS_STRING STRINGIFY_EXPAND(AIMAKE_OPTION_packagename)

Although aimake will identify which executables it should produce as output
(via looking for functions called C<main>), it will not produce shared
libraries without an indication of which symbols form the API of the shared
library.  In order to create shared libraries correctly on all operating
systems, aimake will need to know which symbols are imported from shared
libraries (that you create; the system header files will contain this
information for system libraries), and which symbols are exported from shared
libraries, via wrapping their names in macros, e.g.:

    int AIMAKE_EXPORT(library_function)(void); /* exported function */
    int AIMAKE_IMPORT(library_function)(void); /* imported function */

The names only need to be wrapped this way in the declaration, not the
definition (which can be left unchanged). C<AIMAKE_IMPORT> and
C<AIMAKE_EXPORT> only work correctly when the type of a variable, or return
type of a function, is a single identifier (not some complex chain of arrays
and pointers, etc.), so for complicated return types you will need to use a
typedef:

    char *function_returning_a_string(void) /* not imported or exported */

    typedef char *char_p;
    char_p AIMAKE_EXPORT(function_returning_a_string)(void) /* exported */

In addition to C<AIMAKE_IMPORT> and C<AIMAKE_EXPORT>, there are also
C<AIMAKE_REVERSE_IMPORT> and C<AIMAKE_REVERSE_EXPORT>, which mark symbols that
exist in the file using the library, and are used by the library (rather than
the other way round, a much more common scenario).

If aimake sees any symbols tagged as C<AIMAKE_EXPORT>, it will place them in a
shared library (and, if appropriate, link executables it creates against that
shared library).  The name of the library will be based on the common prefix
of the object files that are used to build the library (so, e.g., if they have
wildly varying filenames but are all in the same directory, it will be named
after the directory).  As an exception, directories called F<src> are ignored
for naming purposes, because that name is very commonly used to hold source
files.

Finally, you can request that a file not be compiled in certain configurations
via making it conditionally error out:

    #ifdef AIMAKE_BUILDOS_MSWin32
    # error !AIMAKE_FAIL_SILENTLY! This file should not be built on Windows.
    #endif

The C<#error !AIMAKE_FAIL_SILENTLY!> will cause the compilation to error out
silently, without the user being informed of an error in the file.  (Note that
this can happen while aimake is locating header files necessary to be able to
use the file; as such, you should ensure that the error happens based only on
the individual file being compiled, and does not depend on anything that might
be included from a header file.)

In addition to changing the source and headers that make up your project, it
is also possible to add a project-specific configuration file, that contains
configuration options or rules overrides.  This should be a file named
F<aimake.rules> in the source directory.  Here's a sample configuration:

    {
        options => {
            packagename => 'example',
        },
        rules => {
            _libraries => {
                output => ['searchlib:some_unusual_library'],
            },
            _cflags => {
                object => 'optionset:CFLAGS',
                depends => ['optstring:-Wall', 'optstring:-Wextra'],
            },
        },
    }

The format of the configuration file is explained in much more detail later in
this document, but this example should serve as an overview of some of the
most common tasks: setting an option (in this case, C<packagename>, which is
probably the most important option to set); telling aimake to search for a
particular library so that it can be linked into the project; and changing the
flags that will be passed to the C compiler.  (All the libraries used by a
project can be listed as C<searchlib:> objects in a rule output, even if some
are only used in some configurations or on some operating systems; aimake will
not complain if it fails to find a library, or if it finds it but does not
find a reason to use it.)  There are some libraries searched for by default
(rule C<default_libraries> in the default configuration; additionally, any
libraries used by default on the build system (such as F<libc.so> on Linux)
will be automatically incuded.

=head1 INTERNALS

=head2 THEORY

aimake operates almost entirely using a set of rules (which are described in
its configuration file; a default configuration file exists at the end of the
F<aimake> script, and can be augmented for a specific project via a file
F<aimake.rules>, if that project needs to do something unusual like generating
some of its source files).  Almost the entire build process is written in
terms of rules; for instance, there is a rule to determine which files need
compiling.  (The main activity that occurs without being driven by rules is to
change the "hash" of C<sys:always_rebuild>, to parse the configuration file
into a set of objects, and to verify that the build directory has not been
tampered with (or recover if it has); that's about it.)

There are four main sorts of rules from the point of view of the configuration
file (they are conflated internally in order to simplify the code):

=over 4

=item Production rules

A production rule makes aimake aware of files on the filesystem (and usually
creates them first); there are some other "file-like" objects like
configuration options that would be appropriate targets for production rules,
but those are handled via special cases internally in order to avoid an
infinite regress during startup.  Pretty much all the rules in standard build
systems are of this form, so it should be quite familiar.  Production rules
almost invariably run a command in order to produce the output files; and
frequently (although not always) apply to a specific input file.  Examples of
built-in production rules are C<compile_c> that produces object files from C
files, and C<generate_search_test_file> which generates a specific file,
C<bpath:aimake/aimake_1.c> (and does not have a specific input object).

=item Provision rules

A provision rule tells aimake that a specific object (often a file) can
I<provide> a specific other object, which is usually an abstract concept such
as "functions named C<yyinput>" or "files with basename F<project.h>".  These
are typically used to set include directories or libraries.  A provision rule
might or might not need to run a command (such as B<nm>) to determine what is
being provided, and its output is a non-file-like object and a set of
dependencies for it.  (For instance, an object file C<path:hello.o> that
contained a function C<say_hello> might provide C<symbol:say_hello>, with
C<optpath::path:hello.o> and C<path:hello.o> as dependencies; then something
with a dependency on C<symbol:say_hello> would be able to satisfy that
dependency via depending on F<hello.o> and adding C<hello.o> as a command line
option.)  The hash of a non-file-like object is the hash of the dependencies
that were found for it, just like the hash of a file-like object is the hash
of its contents.

The set of dependencies of a non-file-like object is treated by aimake the
same way it would treat the content of a file-like object, which reduces the
internal complexity somewhat.  In fact, production rules and provision rules
are treated almost identically internally, and are collectively known as
I<provicion> rules (with I<provice> as a verb, meaning "produce or provide".)

=item Dependency rules

A dependency rule is used to tell aimake how to determine the dependencies of
an object; this allows file-like objects to have dependencies (or
non-file-like objects to have additional dependencies that were not set when
they were created).  An object cannot be used unless all its dependencies are
up to date; and any C<optstring:> or C<optpath:> dependencies of an object
will be given to any command using it as command-line options (which is the
usual method in aimake of passing arbitrarily many command-line options to a
program, rather than a fixed number).  These dependencies are known as I<use
dependencies> because they do not need to be up-to-date to build the object,
but do need to be up-to-date to use it.  (An object's I<build dependencies>
are the objects that were used to build it, which are the (recursively
expanded) use dependencies of the object or objects it was built from.)

Internally, dependency rules are desugared into provision rules, that provide
a C<dependencies:> object (with a tweak to prevent a chicken-and-egg problem:
the object's dependencies do not need to be in place already before its
dependencies are determined), and the C<dependencies:> object is implicitly
added to the dependencies of every rule that depends on the object.

=item Install rules

Installing has a special interface (for instance, it may need to be run as
root, and goes to a user-specified path rather than just being placed in an
appropriate place in the build directory).  Install rules also have a special
interface in the configuration file.  They're desugared into a production rule
that just copies the file, with some minor special cases (to do with
permissions, and to be willing to create files outside the build directory
without complaining, and to do all installing at the end of the run, even
after rules depending on C<sys:rebuild_late>).

=back

The internals of aimake actually mostly operate on "pairs", rather than rules;
a pair is a rule, plus one specific set of inputs to it.  (So C<compile_c> is
a built-in rule; C<compile_c path:hello.c> is a pair, that refers to the
operation of running a compiler on F<hello.c>, to create a file such as
F<hello.o> or F<hello.obj> depending on platform.)

At the start of the build, aimake "changes" C<sys:always_rebuild>, and parses
the configuration file into C<config_option:> and C<config_rule:> objects.
(The rules are in the configuration file, so it needs to be parsed
separately.)  It statically considers all C<optstring:>, C<optpath:>,
C<intcmd:> and C<cmd:> objects to exist (as well as most C<sys:> objects).
Other objects are I<not> statically considered to exist; in particular,
C<path:> and C<spath:> objects need to be located via rule (there are built-in
rules for this), or aimake will consider them nonexistent despite actually
existing on the filesystem.  This means that aimake will notice changes,
additions, and deletions of files in the source tree (the files are "produced"
via the built-in rule C<find_source_files>; although this is run every time
you run aimake, this does not cause the entire project to be rebuilt because
most of the files will likely retain the same modification time or hash as
last time).

From then on, everything is done by rules.  Each pair is either I<changed>,
meaning that running it might potentially do something, or I<unchanged>,
meaning that nothing relevant has changed since last time it ran; initially,
all rules are unchanged, but many will be marked as changed at the start of
the run due to the "change" to C<sys:always_rebuild>.  (There's actually one
more state internally, for optimization purposes: I<blocked> pairs are changed
pairs that are missing one or more direct dependencies.  While a pair is
blocked, aimake doesn't bother calculating its indirect dependencies, like it
would with a non-blocked changed pair.)  Each object (including nonexistent
objects!) is either I<sure>, meaning that aimake knows the object does not
need to be rebuilt (either because it knows it's correct on disk / in memory,
or because it knows it doesn't exist), or I<unsure>, meaning that aimake does
not know whether the object needs rebuilding.  Here's what the main loop looks
like:

=over 4

=item *

Whenever an object's contents (i.e. hash or modification time) changes, then
all pairs with a dependency on that object become changed.  (Exception: if the
pair also has a dependency on a nonexistent, sure object, I<and> either has
never been run, or produced no output last time it ran; in this case, there
cannot be any reason to run it again until that nonexistent object starts
existing.  This optimization leads to the pair remaining unchanged if its full
use dependencies are known, or becoming blocked if the nonexistent object is a
direct dependency and thus there was no need to calculate the full use
dependencies.)

=item *

Whenever a pair becomes changed, all objects that it proviced last time it ran
become unsure.  (We can't know whether it will provice them the same way
again, or a different way, or even end up not provicing them at all after
running.)

=item *

For efficiency, a cache is maintained of each pair's full use dependencies
(i.e. all the use dependencies specified in the object being operated on, the
rule's command, any use dependencies of those, and so on).  (aimake version 2
was very slow; the lack of this cache was one of the reasons, although its
algorithm was inefficient in general and not amenable to one being added.)
Whenever a provided object is changed, any pair that has a use dependency on
that object has its cache recalculated.

=item *

If a pair is changed, and has no unsure objects in its full use dependencies,
their build dependencies, I<their> build dependencies, and so on, then the
pair can be run.  (As an exception, if an object in the pair's use
dependencies isn't unsure but also doesn't exist, then the pair "runs" but
produces no output, and any output it previously had is deleted.  This is what
allows aimake to recover from a source file being deleted, for instance;
previous versions had trouble with this case.  There's another minor exception
to do with C<searchfile:> objects, in case a generated source file wants to
search for the same header file that the source of the generator wanted to
search for; the situation is obviously benign, as it'll find it in the same
place, but would potentially cause a dependency loop without special
casing.  The same special case applies to C<searchlib:> and C<symbolset:>
objects; C<searchlib:> objects for the same reason, C<symbolset:> objects
because their dependencies are encoded in their name.)  When the pair is run,
it becomes unchanged, and the hashes of anything it previously output, and
anything it now outputs, are updated.  Such objects also become sure (with a
slight exception in the dubious case where the same object is output by
multiple pairs).  An object no longer being produced by a pair counts as a
hash change (the hash of a nonexistent object is treated as different from the
hash of an object that exists).

Any warnings produced running the pair are recorded with the pair.  If the
pair produced an I<error>, then any objects it previously produced are marked
as unsure (and cannot be marked as sure again until the rule runs
successfully), holding them and all their descendants in limbo until the error
is fixed.  (If they are deleted from the filesystem in the process, which is
quite likely, their hash will also change.)  This means that if fixing the
error causes the objects to be recreated with the same hash, there will not be
a need to recreate their descendants in the future, avoiding the need for a
long recompile in the case of a widely depended-on file (like a generator for
a generated header file that is included almost everywhere) having an error.

=back

There's one other source of errors: dependency problems.  aimake's core
doesn't notice a problem if something can't be built due to a missing
dependency (it simply assumes it built correctly with no output), but the user
probably considers this situation a bug.  As such, an internal list is kept of
pairs that aren't producing any output; and that list is scanned for pairs
that didn't produce output due to missing expanded use dependencies that
weren't in the command, to let the user know what went wrong.

=head2 AIMAKE OBJECTS

aimake tracks a lot more types of objects than just files:

=over 4

=item C<path:>

One of the files in the source directory.  (aimake is designed for out-of-tree
builds, although it can build into a subdirectory of the source directory; it
simply treats any subdirectory that contains an aimake state file as not
existing.)  aimake scans these for changes.  This is a relative, not absolute,
path (so that it continues to work correctly if the source directory is
renamed), in aimake relative path format (that is, directories are separated
with slashes, and colons, slashes and backslashes in path components are
escaped with backslashes; note that aimake relative path format cannot
represent an absolute path, which saves having to worry about how the
filesystem is rooted).  Because they represent specific files, C<path:>
objects are produced, not provided.

=item C<bpath:>

One of the files in the build directory: things like object files.  Like with
C<path:>, this is a relative path in aimake relative path format.  C<bpath:>
objects are produced, not provided.

=item C<spath:>

One of the files that exists as part of the system's toolchain: compilers,
system libraries, system headers, and the like.  This is always an absolute
path, and is in aimake's absolute path format (which works like its relative
path format, except that it has an extra component at the start, which
represents the filesystem root to use in a system-dependent manner; this might
be the null string on systems whose filesystem only has one root).

C<spath:> objects can only be created via things external to aimake (such as
the system's package manager), but they can be produced via a no-op command,
to tell aimake to consider them to be relevant; they are considered
nonexistent until that happens.

=item C<searchpath:>

A set of directories that is looked in for include files, libraries, or the
like.  This looks something like C<searchpath:systeminclude>, and the actual
paths to search are stored as dependencies (the same way as an C<optionset:>
works).  Search paths are typically used to produce objects on the search
path.

=item C<searchfile:>

A filename that is being searched for (most likely, because there's an unmet
dependency on some unknown file with that name).  This looks something like
C<searchfile:stdio.h>.  Note that all objects providing a C<searchfile:> must
provide the same list of dependencies for it (the built-in rules create
searchfiles with the empty set of dependencies); aimake assumes requests to
search for files with a particular name to be interchangeable.

=item C<searchlib:>

A library that is being searched for (not including naming conventions of the
platform, e.g. 'libfoo.a' on Linux would become 'searchlib:foo'). aimake
assumes that these are interchangeable the same way C<searchfile:>s are.

=item C<extend:>

A filename that's produced from another filename.  This is formed out of an
extension and a file-like object, and is just an alias for something in the
C<bpath:>, not an object in its own right.  For instance,
C<extend:.s:path:src/foo.c> might be an alias for C<bpath:src/foo.s>.  (This
is mostly used to tell compilers and similar tools where to place their
output.)   As a special case, an extension of ".." causes the filename to be
deleted too, producing the directory of the object:
C<extend:..:path:src/foo.c> is C<path:src>.  This construction might produce
an C<spath:>, C<path:> or C<bpath:>.

=item C<file:>

A reference to a file with a particular name.  This is used to represent
dependencies produced via code like C<#include "foo.h">.  It is possible for
multiple rules to provide the same C<file:> object.  (The difference between
C<file:> and C<searchfile:> is that if an unknown file is included, that'll
I<produce> a C<searchfile:> object to let aimake know to search for it, and
I<depend on> a C<file:> object to let aimake know to use it once it's found.

=item C<symbol:>

A reference to a symbol (as would be used by a linker); this is used the same
way as C<file:>, but for linking rather than compiling.

=item C<shared_symbol:>

A symbol that is exported by the file that provides it, and is intended to be
compiled as part of the API of a library.  aimake's standard rules will
attempt to create a C<symbolset:> containing each shared_symbol that is
defined.

A C<shared_symbol:> is subject to the same special rules that a C<symbolset:>
is: if two or more pairs generate the same C<shared_symbol:> object, they must
give it the same dependencies.

=item C<symbol_in_object:>

A reference to a symbol produced by a specific object.  This is used
internally to determine which C files contain a C<main> function.

=item C<symbolset:>

A set of symbols and the object files that define them, ready to be made into
a library.  Symbol sets have two names: an internal name, and a filename,
looking like C<symbolset:d41d8cd98f00b204e9800998ecf8427e:bpath:libfoo.so>.
When aimake creates a symbol set, the internal name is a hash of the symbols
and object files that make up the symbol set, and the filename is based on the
common prefix of the object files (not counting header files).  Symbol sets
are provided objects; they don't represent a file on disk (thus, the filename
is a I<suggested> filename that will most likely be used to represent the
resulting library).  If a C<symbolset:> object is used in an C<optpath:> or
C<extend:> object, it will be treated as if it were just its filename portion;
this does not happen for other uses of C<symbolset:> objects.

Because the internal name of a symbolset encodes its dependencies, these are
subject to the same special cases that C<searchfile:> objects are; if two or
more pairs generate the same C<searchfile:> object, they must give it the same
dependencies.

=item C<config_option:>

An option in the config file.  This is mostly used in dependencies, to specify
things like "this object file needs to be rebuilt if the CFLAGS change" (a
build dependency), or "this source file has the install path substituted into
it at compile time" (a use dependency).  The object is named using the option
name after C<config_option:>, e.g.  C<config_option:CFLAGS>.  These
dependencies are added automatically when options are substituted into
commands.

=item C<config_rule:>

A rule in the config file.  Every rule includes itself as a use dependency.
That way, if the config file is changed, files are recompiled accordingly.
Each rule has its own name for this purpose.

=item C<sys:>

Things like dummy targets, file-like objects that aren't files, and so on.
The following C<sys:> objects exist:

=over 4

=item C<sys:always_rebuild>

An object that conceptually changes with each run of aimake.  This should only
be used for, e.g., "last build" reports in the About box of a program.
(B<aimake> also uses it internally to determine when to scan for new files in
the source tree, a task that should always be performed.)

=item C<sys:rebuild_late>

An object that conceptually depends on everything that doesn't depend on it.
This is typically used for wildcard-style build rules where you want to depend
on everything that obeys a particular pattern.  This is implemented via
marking it as unsure until no further compilation is possible, then marking it
as sure and continuing the compile.  If you also need the rule to re-run every
time (which is likely when doing wildcard-style dependencies), also add a
dependency on C<sys:always_rebuild>.

=item C<sys:installing>

An object that conceptually depends on everything that doesn't depend on it,
including C<sys:rebuild_late>.  This is used to ensure that installing is
performed last of all, and is implicitly added as a dependency of install
rules.  (It is probably a bad idea to add it manually.)

=item C<sys:clean>

An object that is always sure and never exists.  Any rule that depends on
C<sys:clean> can run "successfully", causing it to delete all its outputs.
It's rare to use C<sys:clean> in a configuration rule manually; rather, aimake
will add it to dependency lists automatically when it's required to clean up
after a rule is changed, or after a command starts producing a different set
of outputs, and thus although it has defined semantics, it's likely best to
treat it as internal use only.

=item C<sys:touch_only>

An object that conceptually represents a file that is deleted immediately
after being installed.  It can be installed in a directory to force the
directory to be created at install time.

=item C<sys:create_subdir>

An object that conceptually represents a subdirectory.  It can be installed in
a directory, with a specific name, to force a subdirectory with that name to
be created at install time (if it doesn't already exist).

=item C<sys:empty_file>

An object that conceptually represents a zero-length file.  Its only use is to
be installed, creating or truncating an install target.  (This could
theoretically be implemented in terms of C<intcmd:writefile>, but that would
be rather unintuitive and hard to read.)

=item C<sys:ensure_exists>

An object that conceptually represents the file that already exists at an
install target.  When installed, it will ensure that the install target exists
(by creating it as a zero-length file if necessary), but will not overwrite an
existing file at that location.

=back

=item C<cmd:>

Represents a command shipped with the system, like C<gcc>.  This is only
meaningful in the part of a configuration file that specifies what command to
run to accomplish something.  (C<bpath:>, C<tool:> and C<intcmd:> objects can
also be used in the same context.)  This is just a filename, no directories
are involved.

=item C<tool:>

A type of command shipped with the system, such as C<tool:c_compiler>.  These
are provided by C<cmd:> objects, and are typically listed in use dependencies
of files that need compilation.

=item C<intcmd:>

Represents a command that's emulated by aimake.  This gives system-independent
behaviour for some commonly used commands:

=over 4

=item C<intcmd:nop>

An internal command that does nothing and produces no output.  Typically used
to provide files that already exist.

=item C<intcmd:cat>

An internal command that just outputs the file given as its argument. (The
file will be assumed to be encoded in UTF-8, regardless of the encoding of
the operating system.)

=item C<intcmd:echo>

An internal command that outputs its arguments, separated by spaces.  Any
paths in the arguments will be output in aimake format.

=item C<intcmd:writefile>

An internal command that takes a filename (as an C<optpath:> and a set of
contents for that file (as any number of C<optstring:>s.)  Any underscores in
the contents will be replaced with spaces, and any spaces with newlines, and
then the resulting string will be written to that file (which should be in the
C<bpath:>); underscores and backslashes can be escaped with backslashes.  This
is used to generate things like input files for compiler tests.

=item C<intcmd:symlink>

An internal command that causes its second argument to become an alias for its
first argument.  This will be done via a symbolic link if possible, but on
some platforms it may need to copy the file; thus, there is no guarantee that
the two arguments will have the same meaning forever.  This will overwrite its
second argument if necessary.  (On POSIXy systems, this is similar to B<ln
-sf>, except that it handles relative paths more intuitively.)

=item C<intcmd:assert_equal>

An internal command that compares two arguments (optstrings or optpaths).  It
succeeds if they are equal, and fails otherwise, producing no output.  The
intended use of this command is in combination with fail_silently, to create
rules that work only in certain circumstances (e.g. on specific OSes).

=item C<intcmd:testcase>

An internal command used for testing aimake.  It prints its arguments to the
user and records them as warnings, and errors out if the first argument
contains "failed" anywhere.  There shouldn't be much of a need to use this in
anything other than a testsuite for aimake itself.

=item C<intcmd:testruncount>

An internal command used for testing aimake.  It writes the number of times
aimake has been run with the current F<aimake.objects> file to a file given as
an C<optpath:>.  (The main use of this in testing is to observe whether a rule
is run or not.)  This command is unlikely to be useful except in testing
aimake.

=item C<intcmd:optionvalues>

An internal command that takes config options as its arguments
(e.g. C<optpath::config_option:packagename>), and outputs their values in
"name=value" form.  Any values that are aimake objects that represent files
will be converted to pathnames as the operating system understands them.

=item C<intcmd:filetest>

An internal command that takes an C<optstring:> and an C<optpath:>, and either
succeeds or errors out depending on information about the filename referred to
by the C<optpath:>.  The C<optstring:> can be:

=over 4

=item C<-e>

The filename exists and refers to something (which might be a file, directory,
special file, symlink, etc.; aimake won't check what sort of entity the
filename refers to).

=item C<-f>

The filename refers to an ordinary file.

=item C<-d>

The filename refers to a directory.

=item C<-l>

The filename refers to a symbolic link.

=item C<-x>

The filename refers to an executable.  (Depending on the operating system,
this might check whether the filename has permissions that allow the current
user to execute it, or it might check the filename for extensions like
C<.exe>.)

=item C<-z>

The filename refers to an empty file.

=item C<-s>

The filename refers to a nonempty file.

=item C<-T>

The filename refers to a text file.  (This cannot be checked 100% reliably.)

=item C<-B>

The filename refers to a binary file.  (This cannot be checked 100% reliably,
either.)

=back

=item C<intcmd:listtree>

An internal command that takes any number of directory names as its arguments,
and returns a list of all the files (but not directories) recursively inside
those directories, one per line.  (As such, it's similar to the POSIXy
B<find>.)  Any symbolic links found are returned, but not dereferenced or
followed.  Unlike calling commands external to aimake (whose output is
typically split on newlines before being fed to the regular expression
specified in the config file), an internal mechanism is used to remember where
the boundaries of each filename are, so this will work correctly even if, for
some reason, your filenames contain newlines, NULs, or other such bizarre
characters.

If given an optstring as well as an optpath, the optstring specifies the
maximum nesting depth to go down the tree; 0 will just list the directory
itself, 1 will also list its subdirectories, and so on.

If given an optpath that's a C<searchfile:> rather than a directory, the
output will be limited to files with that filename.

=item C<intcmd:xuse_statistics>

An internal command that outputs some information about the rule that caused
it to run (specifically, the expanded set of use dependencies of the rule's
commands, i.e. the build dependencies of its output).  Any number of
C<optstring:> arguments can be given; if any are given, then objects are only
considered for calculating the C<hash> if they have at least one of the given
C<optstring:>s as a suffix.  The output is a number of lines in key=value
form, and may be expanded with extra information in future. At present, the
currently output keys are:

=over 4

=item hash

The MD5 hash (in hexadecimal) of the string constructed by sorting then
concatenating the names of all the C<path:> and C<bpath:> objects (that have
appropriate suffixes) in the expanded use dependencies, separated by colons.
The main purpose of this is to be able to easily compare sets of dependencies.

=item stem

The longest common prefix of the C<namehint:>s in the expanded use
dependencies of the rule; any final slash will be removed, and the resulting
object name will be on the C<bpath:>.  The intended purpose of this is to find
a sensible filename and location for objects that would not otherwise have an
obvious filename.

=item dependency

A use dependency of the rule's commands, including non-file-like objects,
objects on the C<spath:>, or objects that do not match the suffixes given.

=back

=back

=item C<optstring:>

An C<optstring:> object represents an option that needs to be provided to a
command.  So for instance, the F<ar> command often used to make libraries
might have C<optstring:cr> as a use dependency.  C<optstring:> objects are the
first thing to appear on a command line when a command is executed, and
normally start with an appropriate option character for the system (typically
slash on systems that don't use slashes as path separators, and hyphens
otherwise).  These are specified as use dependencies, but become build
dependencies unchanged.

C<optstring:> objects are split on spaces, because typically the only use for
spaces inside an option is to specify a filename which contains embedded
spaces, and that would be done via C<optpath:>.  Each space-separated
component becomes a separate command-line argument.

An C<optstring:> that has a leading space is moved to the end of the command
line, but otherwise works like the C<optstring:> without the space.  This is
mostly used for libraries, e.g. C<optstring: -lm>.

=item C<optpath:>

A combination of an C<optstring:> and a file-like object.  The format is,
e.g., C<optpath:-o:bpath:file.h> if they should be combined into one
command-line option, and C<optpath:-o :bpath:file.h> (that's a space and a
colon) if they should be left as two consecutive command-line options.

=item C<optionset:>

A set of options commonly used together, such as the C<CFLAGS> commonly used
by B<make> programs (which would be C<optionset:CFLAGS>).

=item C<namehint:>

A clue as to what would make a sensible name for an object.  Objects that
particularly strongly hint at a name depend on their own names; e.g. a file
C<bpath:main_c.o> that contained the main routines for a file might well
depend on C<namehint::bpath:main_c.o>.  C<namehint:> objects always exist
(thus depending on them doesn't cause problems, unless someone adds
dependencies to them using dependency rules; don't do that), and are added by
the default configuration according to some heuristics.  Therefore, you should
never need to deal with them yourself.

=item C<dependencies:>

The set of dependencies generated by a particular dependency rule,
e.g. C<dependencies:ch_file_dependencies:path:header.h> would represent the
dependencies of C<header.h> that were found via the rule
C<ch_file_dependencies>.  Dependency objects generated by dependency rules are
automatically added as dependencies of the objects they are dependencies for.
These can be generated manually too, but do not have special handling in that
case; you might want to do this if, for instance, you only want the object to
respect certain set of dependencies for the purpose of specific other rules.

=back

=head1 CONFIGURATION

aimake is designed not to need configuration on simple projects, but
sufficiently complex projects may need some configuration to explain things to
aimake that it couldn't possibly guess (such as how to generate files that are
used as part of the build process).

Much of the workings of aimake are driven by a configuration file that's
embedded into the B<aimake> script itself, in order that only a single file
need be shipped.  Any part of this script can be overriden by a configuration
file C<aimake.rules> in the root of the package source directory, via
specifying an option or a rule with the same name.

The format of the configuration file itself is Perl object notation; this
allows for comments, dictionaries, lists, numbers, strings, and regular
expressions:

    # this is a comment, from the # to the end of line
    4                       # a number
    'abcde'                 # a literal string
    "x\n\t$var"             # a string containing escapes, variables
    qr/foo.*bar/i           # a regular expression (qr//; the i is a modifier)
    [1, 2, 3, 4,]           # a list, trailing comma optional
    {foo => 1, bar => 2,}   # a dictionary, trailing comma optional

The configuration file allows defining one or more variables (either to
abbreviate what would otherwise be repeated code, or to avoid "magic numbers"
in tthe code).  There are also some predefined variables, which hold
platform-specific extensions: $exeext (executables), $objext (object files),
$libext (static libraries), $dllext (dynamic libraries).  (In order to catch
mistakes due to omitting $exeext, it will never be set to the null string, but
rather to an arbitrary string on platforms that do not normally use a special
extension for executables.  This extension will be removed when installing the
executable.)  These are followed by a single dictionary with two keys,
C<options> and C<rules>.  Here's a simple example C<aimake.rules>:

    $version = "1.2.3";        # variable definition

    {
        options => {
            packagename => 'configexample',  # override an option
        },
        rules => {
            install_executable => undef,     # undefine a rule
            _generate_usage => {             # define a new rule
                command => ['extend:$exeext:bpath:gendocs', 'optstring:-u'],
                output => 'bpath:doc/usage',
            },
        },
    }

The options dictionary is very simple: keys of the dictionary are options, and
the corresponding values their values.  The following options are recognised
(unrecognised options are also legal, but will be ignored except for
C<config_option:> dependencies, which e.g. are used to define the
C<AIMAKE_OPTION_> macros):

=over 4

=item packagename

A directory name that will be used to name any directories that are specific
to the package when installing.

=item ignore_directories

A regex of directory names to never consider part of the source tree.  (By
default, this is a list of directories used to hold data by a range of version
control systems.)

=item ignore_directories_with_files

A list of filenames that cause directories containing them to never be
considered part of the source tree.  (By default, this is a list of files
generated to hold internal state by autoconf, CMake, and aimake, which
indicate that the directory is being used as a build directory.)

=back

The rules dictionary is more complex.  It consists of a number of rules; the
keys are the rule names, and the values the rules themselves.  aimake's
predefined rules will all start with a lowercase letter.  In order to avoid
clashes with them when defining your own rules, start the names of your own
rules with an underscore.

There are two sorts of rules, from the point of view of an install: rules
which specify dependencies of objects or install them, and rules which provice
objects.  Rules that produce an object have a C<command> and C<output>, and
perhaps also a C<object> if they need to apply to multiple files or the like,
a C<verb> and/or an C<outputarg>, and may specify C<information_only> and/or
C<propagate_usedeps>.  Rules that provide an object work like production
rules, but also need an C<outdepends>.  Rules that specify dependencies have
an C<object> and a C<depends> (or an C<install_dir> if they are actually
install rules), and perhaps also a C<command> if commands need to be run to
determine the dependencies, and/or a C<dependsarg>.  Either can have a
C<inner>, C<linesep>, C<lineskip>, C<linemax>, C<unescape>, C<avoid_rules>,
C<filter>, C<filter_absolute>, C<filter_text_files>,
C<filter_nonexistent_files>, C<output_as_searchfile>, C<filter_spath>,
C<require_match> and/or C<low_message_priority>, and can specify
C<force_locale>, C<fail_silently>, C<also_match_stderr>, and/or
C<ignore_warnings> if they have a C<command>.

A rule itself is a dictionary with a number of keys:

=over 4

=item command

A list of objects, or a single object which will be interpreted as a 1-element
list.  The list will be recursively extended with use dependencies of the
objects listed (and also the C<object>, if it exists, and if this is a
provicion rule).  Once this has been done, all executable-like and option-like
objects will be used to form a command (either an internal command or one that
exists on the system, depending on which executable-like objects are
involved), and executed.  (Alternatively, you get an error if you try to use
multiple different executables, or provide none; C<bpath:> objects are only
treated as executable-like if there are no other executable-like objects
provided.)  The list of objects is also considered a list of dependencies, to
know when to rebuild.

If the command produces output on stdout, it is discarded unless one of the
other options (most commonly C<output>) is a regexp.  If it produces output on
stderr, the user will be informed of it (and there will be an indication of
warnings in the progress report), but the output will otherwise be ignored.
If the command returns a failure status or crashes with a signal, it will be
reported as an error unless the C<fail_silently> key is set; when failing
silently, it will be considered to produce an empty C<output> or C<depends>
(depending on the type of rule), whereas when an error is reported, it will
leave all its descendants in limbo until the error is resolved.

For dependency rules, rather than provicion rules, a C<command> can be given
if a command needs to be used to determine the dependencies.  It can be
omitted if it would just be C<intcmd:nop>.  (It can also be omitted in
provicion rules if no command need be run for the rule; this happens in
provision rules quite a bit, and could also happen in rules that "generate"
C<spath:> objects.)

A null string in the C<command> of a dependency rule refers to the C<object>
(which must be given).  This is, however, pointless, because the C<object> is
automatically included in the list if it exists for provicion rules, and would
lead to an infinite regress if included for dependency rules (because it would
specify calculating the command based on the dependencies of the object we're
trying to calculate dependencies for).  Likewise, if just the "outside" part
of an object (e.g. C<optpath::>) is given, the C<object> is used to fill in
the "inside" (and this can be meaningful in any sort of rule).  Note that just
because the C<object> is automatically included in the dependency lists, this
doesn't necessarily mean it will be mentioned on the command line; use
C<optpath::> for that.  (The command line arguments to the executable being
run are produced entirely out of C<optstring:> and C<optpath:> objects; no
other objects have an influence on it, unless you consider the name of the
executable itself to be part of the command line.)

=item output

Just like the C<command>, a list of objects or a single object.  You can use a
regular expression instead of an object name; that will cause the output of
the command to be parsed for lines matching the regular expression, and the
first parenthesized group matched by the regular expression will be treated as
a filename (for non-internal commands and internal commands that operate on
text, such as C<intcmd:cat>), or an object name (for internal commands that
operate on objects, such as C<intcmd:listtree>).  (It's OK for the regular
expression to match multiple times on the same line, which will produce
multiple output objects.)  The output will be interpreted assuming that it is
encoded in the current locale for your platform (because this is the encoding
most likely to be output by programs), if it comes from an external program.
The list of output objects is considered to be the objects that the rule is
responsible for providing or producing, and (mostly for the purpose of
catching errors in the configuration files; aimake itself could handle this
case just fine) if they are files, they must exist after the rule is executed.
(It's OK if they existed beforehand; in fact, there are standard rules that
"generate" C<spath:> objects, with the purpose of the rule being to inform
aimake of the object's existence, and get it to monitor for changes in it,
rather than to create it.)  If an object is listed as providing or producing
itself, that will be silently ignored (because it's meaningless, and the
config file is easier to write without having to handle that case).  Null
strings, as usual, refer to the C<object>, including nested inside other
objects (if there's no C<inner>).

=item outdepends

Provision rules don't generate files on disk; they just say "objects X can be
used to provide object Y".  In this case, object Y is the C<output>;
C<outdepends> specifies what objects X, the use dependencies of object Y, are.
This is in exactly the same format as the C<output>, including the
substitution of the C<object> where required.  C<outdepends> is omitted for
production rules, and for dependency rules.

=item information_only

Normally, outputting something in the C<path:> or C<spath:> is a mistake.  If
you do it intentionally (e.g. to make aimake aware of files in the C<spath:>),
set C<information_only> so that aimake will know that you're merely talking
about the files, not changing them, and so not error out.

=item propagate_usedeps

Sometimes, a provision rule will not need the normal use dependencies of an
object to be in place.  (For instance, when looking at a file to see which
symbols it provides, you don't need access to the symbols that that file
uses.)  Setting propagate_usedeps to 1 will cause the object itself to become
a use dependency of the objects it produces/provides, but not require those
dependencies to be satisfied to run the rule.  (This is always the case for
dependency rules, so there's no point in specifying it.)  The first of these
effects is equivalent to adding C<''> to the C<outdepends>, but the second
effect cannot be achieved otherwise (which is why C<propagate_usedeps>
exists).

You can set propagate_usedeps to 2 to get the second effect on its own,
causing the objects provided by the C<object> to completely ignore the
C<object>'s use dependencies.  This is mostly useful in the case of
"providing" C<searchfile:> objects that will subsequently be used to help
locate the C<object>'s dependencies, which would cause a dependency loop
otherwise.

=item object

The object to specify dependencies of, in the case of a dependency rule.  This
must be a single object.  In the case of a provicion rule, the only purpose of
the C<object> is to determine what null strings mean in the C<command>,
C<output>, and C<outdepends>.

The object itself is also implicitly treated as a dependency of the rule, as
if it were specified in the C<command>, except that in the case of dependency
rules (or provicion rules with C<propagate_usedeps> set) this dependency only
goes one level; the object's use dependencies will not also be considered as
part of the command, like is usual for dependency rules.  This avoids the
obvious infinite regress that would otherwise occur with dependency rules; an
object's dependencies may well depend on its contents, but normally, you can't
depend on an object without also depending on all its use dependencies.

Instead of using an object name directly, you can use a regular expression;
this will cause the rule to be able to run once for each object that matches
(although it will only match one object at a time), in order to allow you to
write rules that, say, use a custom compiler you built to compile a custom
filetype (it'd be invoked on each file individually).

Some types of object are disallowed in the C<object> (basically either because
infinitely many of that object exist, or because the object is entirely
virtual, or because aimake doesn't track how many of those objects exist):
C<sys:>, C<cmd:>, C<intcmd:>, C<optstring:>, C<optpath:>.

=item depends

The objects that that object depends on.  These are "use dependencies";
anything that requires C<object> in its command must also require C<object>'s
C<depends>.  This works exactly like C<output>.  C<output> versus C<depends>
is what distinguishes a rule as a provicion rule versus a dependency rule.
(C<command> should be set if regular expressions are being used for, say,
C<depends>; otherwise, the only reason to set it would be if you also set
C<fail_silently> and the command's exit code was used to determine whether the
dependency was needed or not, or if you want to make an assertion about the
object at the same time as producing dependencies for it using the command's
exit code.)

=item install_dir

An install rule is like a dependency rule, but it specifies an install
directory rather than a list of dependencies and thus specifies C<install_dir>
rather than C<depends>.  If the C<-i> switch is used, the C<object> will be
installed into that directory.

The available install directories are as follows:

=over 4

=item bindir

A directory used for installing executables runnable by the user.  This will
typically be somewhere that's on the $PATH by default.

=item libdir

A directory used for installing libraries that are used by tools provided with
the system, such as C compilers.  This should be used for
architecture-dependent files.

=item specificlibdir

A directory used for installing libraries that are only used by the program
being installed.  Like libdir, this should be used for architecture-dependent
files.

=item includedir

A directory used for installing include files that are used by tools provided
with the system (e.g. C header files).  This should be used for
architecture-independent files.

=item specificincdir

A directory used for installing architecture-independent include files that are
specific to the program being installed (although they will still be visible
to system tools if an appropriate path is given).

=item configdir

A directory used for system-wide configuration files (that apply to all users
on a multi-user system); these may be intended to be edited by the user, but
should not be edited by the program itself.  These should be text files.

=item datadir

A directory used for general architecture-independent read-only data files
used by the program.

=item mandir

A directory used for documentation in UNIX manual format.

=item infodir

A directory used for documentation in GNU Info format.

=item statedir

A directory used for general architecture-independent data files that are both
read and written by the program (and that are shared between all users).

=item rootbindir

Like C<bindir>, but for executables designed to be run with elevated
permissions.  (This doesn't actually do anything to elevate the permissions,
nor to prevent users without elevated permissions running the executables;
however, on many systems, users who don't have elevated permissions will be
prevented from running the program by accident, even though they can still do
so intentionally.)

=item gamesbindir

Like C<bindir>, but for executables which are games.  (Some sites may have
policy that handles game executables specially.)

=item gamesdatadir

Like C<datadir>, but for read-only data files for games.

=item gamesstatedir

Like C<statedir>, but for read-write shared data files for games (such as high
score tables).

=item logdir

A directory used for log files that are written by the program.

=item lockdir

A directory used for files, shared between all users, that are transient in
nature.  (The directory is likely, but not guaranteed, to be one where files
are deleted on reboot.)  It is probably a bad idea to install anything into
this directory, but aimake tracks it so that compiled programs can refer to
it.

=item specificlockdir

A directory used for files, shared between all users, that are transient in
nature, that is not used by any other package (and thus, can be given files
with arbitrary filenames without worrying about name clashes).  The directory
may be deleted on reboot, and as such, may have to be re-created each time it
is used.

=back

=item install_name

The basename to install a file under, if it isn't the same as the basename of
the C<object>. This can include forward slashes to install into a subdirectory
(regardless of what the path separator happens to be on the system in
question).

=item inner

There are a few compound objects like C<searchpath:> and C<optpath:>.  To
output such objects, C<output> or C<depends> can be set to just the "outside"
part of the object (e.g. C<searchpath:library:> or C<optpath:-o :>), and
C<inner> is used to specify the "inside" part of the object.  It can be a
regular expression, with the same meaning as making C<output> or C<depends> a
regular expression.  The default value of C<inner> is C<object>.

=item outputarg

Nested objects have the form C<objtype:outputarg:inner>.  If C<output> is just
a C<objtype:outputarg:>, the C<inner> is used to fill in the rest of the
object name.  If output is just a C<objtype:>, however, the C<outputarg> is
used to fill in the rest of the name; this works for both nested and
non-nested objects.  (It's possible to have both an C<outputarg> and an
C<inner> in the case of a nested object.)  C<outputarg> should be omitted if
not needed, and should be specified if needed.  Just as with C<inner>, it can
be a regular expression (and typically is only useful if it's a regular
expression); unlike with C<output> and C<inner>, it's interpreted as a plain
old string, not as a filename or object name.  (Only one of C<output>,
C<inner>, and C<outputarg>, and C<outdepends> should be a regular expression.)

=item dependsarg

Works exactly like C<outputarg>, except for C<depends> not C<output>.

=item in_subdir

By default, aimake uses absolute paths for command line arguments.  Sometimes,
a program will only function correctly with relative paths.  In such a case,
set C<in_subdir> to specify the current directory for running the command;
C<optpath:>s that refer to files within that subdirectory will be formatted as
relative paths.  C<in_subdir> can also be set to C<bpath:> in order to give
shorter command lines when running commands, in cases where there's no
particular need to give absolute paths (the default is absolute paths, because
they're less prone to being misinterpreted).

=item require_match

Consider the command to have errored out if any regexes in the rule fail to
match any lines of output.  (This helps detect typos in regexes in the case
where you know they should match at least once.)  This option overrides
C<fail_silently> in the situation where both are given (otherwise, the
combination of C<require_match> and C<fail_silently> would be completely
pointless.)

=item low_message_priority

Causes aimake not to print messages about this rule being run unless the
verbosity level is increased to at least 1.  (This is used for production
rules that make aimake aware of objects on the C<spath:>, mostly.)  There is
no point in specifying this for dependency rules, because those messages
require a verbosity level of 1 or more to be printed anyway.

=item avoid_rules

Can be set to a regular expression that matches the names of rules.  Provided
objects created by rules whose names match the regular expression will not be
considered to satisfy dependencies of this rule.  (You would use this, for
instance, to avoid an infinite regress when creating a dynamic library; you
would want the symbols to come from object files, not from the dynamic library
that the rule itself had created.)

=item filter

When C<output>, C<outdepends>, C<outputarg>, C<dependsarg>, C<depends>, or
C<inner> is a regular expression, C<filter> can also be a regular expression,
which tells aimake to disregard lines that don't match the C<filter> before
trying to match the other regular expression.  Otherwise, it is ignored.

=item linesep

Changes what is considered to be a line separator in the output.  You might,
for instance, want to split the output on spaces if trying to parse a Makefile
rule.  The default is a newline.  This can be a regular expression.

If C<linesep> is combined with C<unescape>, then escaped literal newlines will
be deleted (as usual with C<unescape>, escaped C<linesep>s will be considered
to be a literal C<linesep>, unless C<linesep> is a newline itself),
non-escaped literal newlines will be considered to be newline characters that
don't break a line, and non-escaped C<linesep>s will be considered a
transition from one line to the next.  (This makes it possible for every
codepoint to be used in the output from a program; as such, C<aimake> will
track the line separators internally.)

=item lineskip

After applying the C<filter> and C<linesep>, specifies the first line of
output that will be read, by specifying how many of the lines to skip at the
start.  The default is 0.

=item linemax

After applying the C<filter>, C<linesep> and C<lineskip>, specifies the
maximum number of lines of output that will be read.  If not provided (the
default), all the lines will be read.

=item unescape

Causes aimake to unescape the output from a program.  By default, no
unescaping is done.  At present, the only recognised values for C<unescape>
are:

=over 4

=item C<'backslash'>

Backslash-newline is deleted; backslash followed by any letter in C<abfnrt>
will be replaced by a corresponding control character according to the rules
of C; and backslash followed by any other character will be replaced by that
character.  (No vertical tabs, sorry.  They're not portable between character
sets.  At present, we don't implement decimal/hexadecimal/octal escapes,
either.)

=item C<'backslash_whitespace'>

Backslash-newline is deleted; backslash followed by other whitespace, or
another backslash, deletes the backslash but leaves the whitespace or second
backslash; and backslash followed by any other character preserves both the
backslash and the character.  (This is the encoding gcc uses for makefile
fragments.)

=back

=item also_match_stderr

Causes the command's output to be considered to include standard error as well
as standard output.  (That is, messages on stderr will not be considered to be
warnings, but rather will be matched by any regular expressions used.)

=item fail_silently

If something goes wrong trying to run the C<command>, the entire rule will be
ignored for those inputs.  Normally, the user will also be informed of this.
Setting C<fail_silently> to 1 causes no messages to be printed upon failure;
this is typically used in situations where the easiest way to find out if a
command is applicable to a situation or not is to attempt to run it.  The
rule's output will nonetheless not be used; instead, the C<output> or
C<depends> will be considered to be the empty set.  Setting C<fail_silently>
to 2 causes failures to be treated as successes (e.g. if you're running a
command you suspect will fail to glean information from what it outputs before
it errors out.)  It should be set to 1, 2 or omitted.

With a provicion rule, C<fail_silently> at 1 only affects messages, because an
empty C<output> has the same affect as the rule failing. However, with a
dependency rule, C<fail_silently> at 1 changes the course of the build; if a
dependency rule errors out, it prevents any building from the C<object>
(because building is not safe if the dependencies are unknown), but if it
fails silently, it permits building from the C<object> without specifying any
dependencies. This means that C<fail_silently> plus a hardcoded dependency
list can be used to add dependencies conditionally.

You can alternatively cause fail_silently to be conditionally set to 1 for a
single execution of a rule via arranging for the string
C<!AIMAKE_FAIL_SILENTLY!> to be produced on the command's stderr in the
situations where you want a silent failure.  The intended purpose of this is
to make it easy to specify that files are completely ignored under certain
conditions, like this example C code:

    #ifndef AIMAKE_BUILDOS_MSWin32
    # error !AIMAKE_FAIL_SILENTLY! This file only works on Windows systems.
    #endif

=item ignore_warnings

This is similar to C<fail_silently>, but for successes; if the command
succeeds, the user will not be informed of any warnings produced running it.
It should be set to 1 or omitted.

=item filter_absolute

Causes any objects other than C<file:> objects (i.e. any objecs that
correspond to an absolute path) that would be generated via a regular
expression match to be ignored if set to 1 (this is most common/useful in
dependency rules).  It should be set to 1 or omitted.

=item output_as_searchfile

Causes any C<file:> objects that would be output to be output as
C<searchfile:> objects instead.

=item filter_spath

Causes any C<spath:> objects that would be generated via a regular expression
match to be ignored if set to 1 (this is most common/useful in dependency
rules).  It should be set to 1 or omitted.

=item filter_nonexistent_files

If set to 1, causes any objects that would be generated via a regular
expression match to be ignored if they don't appear to be the filename of an
existing file (that's either a regular file or a symbolic link).  It should be
set to 1 or omitted, and is mostly useful for avoiding false positives when
parsing output that mixes filenames with other information.

=item filter_text_files

If set to 1, causes any objects that would be generated via a regular
expression match to be ignored if they appear to be text files, rather than
binary files (the main purpose of this is for filtering out linker scripts,
which cannot be distinguished from libraries via filename alone).  It should
be set to 1 or omitted.

=item force_locale

Forces the LC_ALL environment variable to have a particular value when running
the C<command:>.  This is used when parsing the output of a command, in order
to force the command to output the messages in a particular language
(typically the locale would be set to "C", which is supported by every program
and causes it to output in its default language, typically English); this
saves needing to write a regular expression to match messages in all languages
that the program is translate into.

=item verb

C<verb> affects the message given (e.g. "Built file.o") when the rule succeeds
(and has no effect except on messages).  The default is "built" for a
provicion rule, and "found" for a dependency rule.

=back

You can provide a list of dictionaries rather than a single dictionary as the
definition of a rule.  This allows for alternative versions of rules to work
using different compilers, or the like.  aimake will pick the first rule on
the list which doesn't contain a nonexistent object in its C<command>, nor its
C<outdepends>.  This can only be used for rules with no C<object>, for
efficiency reasons (it's mostly intended for rules that provide C<tool:>
objects).

=for comment
Apparently, there's no POD version available, so we use this plaintext
version instead.  (I can't reformat it due to the no-derivs metalicense.)

=head1 COPYRIGHT

Copyright (C) 2013 Alex Smith.

This program is free software: you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation, either version 3 of the License, or (at your option) any later
version.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
details.

Note that the author of this program does not believe that programs compiled
using aimake are a derivative work of aimake (in the same way that, for
instance, programs compiled using autoconf are not a derivative work of
autoconf).  As such, the license of aimake does not restrict what licenses and
distribution terms you use for programs that you compile with aimake.

                     GNU GENERAL PUBLIC LICENSE
                        Version 3, 29 June 2007

  Copyright (C) 2007 Free Software Foundation, Inc. <http://fsf.org/>
  Everyone is permitted to copy and distribute verbatim copies
  of this license document, but changing it is not allowed.

                             Preamble

   The GNU General Public License is a free, copyleft license for
 software and other kinds of works.

   The licenses for most software and other practical works are designed
 to take away your freedom to share and change the works.  By contrast,
 the GNU General Public License is intended to guarantee your freedom to
 share and change all versions of a program--to make sure it remains free
 software for all its users.  We, the Free Software Foundation, use the
 GNU General Public License for most of our software; it applies also to
 any other work released this way by its authors.  You can apply it to
 your programs, too.

   When we speak of free software, we are referring to freedom, not
 price.  Our General Public Licenses are designed to make sure that you
 have the freedom to distribute copies of free software (and charge for
 them if you wish), that you receive source code or can get it if you
 want it, that you can change the software or use pieces of it in new
 free programs, and that you know you can do these things.

   To protect your rights, we need to prevent others from denying you
 these rights or asking you to surrender the rights.  Therefore, you have
 certain responsibilities if you distribute copies of the software, or if
 you modify it: responsibilities to respect the freedom of others.

   For example, if you distribute copies of such a program, whether
 gratis or for a fee, you must pass on to the recipients the same
 freedoms that you received.  You must make sure that they, too, receive
 or can get the source code.  And you must show them these terms so they
 know their rights.

   Developers that use the GNU GPL protect your rights with two steps:
 (1) assert copyright on the software, and (2) offer you this License
 giving you legal permission to copy, distribute and/or modify it.

   For the developers' and authors' protection, the GPL clearly explains
 that there is no warranty for this free software.  For both users' and
 authors' sake, the GPL requires that modified versions be marked as
 changed, so that their problems will not be attributed erroneously to
 authors of previous versions.

   Some devices are designed to deny users access to install or run
 modified versions of the software inside them, although the manufacturer
 can do so.  This is fundamentally incompatible with the aim of
 protecting users' freedom to change the software.  The systematic
 pattern of such abuse occurs in the area of products for individuals to
 use, which is precisely where it is most unacceptable.  Therefore, we
 have designed this version of the GPL to prohibit the practice for those
 products.  If such problems arise substantially in other domains, we
 stand ready to extend this provision to those domains in future versions
 of the GPL, as needed to protect the freedom of users.

   Finally, every program is threatened constantly by software patents.
 States should not allow patents to restrict development and use of
 software on general-purpose computers, but in those that do, we wish to
 avoid the special danger that patents applied to a free program could
 make it effectively proprietary.  To prevent this, the GPL assures that
 patents cannot be used to render the program non-free.

   The precise terms and conditions for copying, distribution and
 modification follow.

                        TERMS AND CONDITIONS

   0. Definitions.

   "This License" refers to version 3 of the GNU General Public License.

   "Copyright" also means copyright-like laws that apply to other kinds of
 works, such as semiconductor masks.

   "The Program" refers to any copyrightable work licensed under this
 License.  Each licensee is addressed as "you".  "Licensees" and
 "recipients" may be individuals or organizations.

   To "modify" a work means to copy from or adapt all or part of the work
 in a fashion requiring copyright permission, other than the making of an
 exact copy.  The resulting work is called a "modified version" of the
 earlier work or a work "based on" the earlier work.

   A "covered work" means either the unmodified Program or a work based
 on the Program.

   To "propagate" a work means to do anything with it that, without
 permission, would make you directly or secondarily liable for
 infringement under applicable copyright law, except executing it on a
 computer or modifying a private copy.  Propagation includes copying,
 distribution (with or without modification), making available to the
 public, and in some countries other activities as well.

   To "convey" a work means any kind of propagation that enables other
 parties to make or receive copies.  Mere interaction with a user through
 a computer network, with no transfer of a copy, is not conveying.

   An interactive user interface displays "Appropriate Legal Notices"
 to the extent that it includes a convenient and prominently visible
 feature that (1) displays an appropriate copyright notice, and (2)
 tells the user that there is no warranty for the work (except to the
 extent that warranties are provided), that licensees may convey the
 work under this License, and how to view a copy of this License.  If
 the interface presents a list of user commands or options, such as a
 menu, a prominent item in the list meets this criterion.

   1. Source Code.

   The "source code" for a work means the preferred form of the work
 for making modifications to it.  "Object code" means any non-source
 form of a work.

   A "Standard Interface" means an interface that either is an official
 standard defined by a recognized standards body, or, in the case of
 interfaces specified for a particular programming language, one that
 is widely used among developers working in that language.

   The "System Libraries" of an executable work include anything, other
 than the work as a whole, that (a) is included in the normal form of
 packaging a Major Component, but which is not part of that Major
 Component, and (b) serves only to enable use of the work with that
 Major Component, or to implement a Standard Interface for which an
 implementation is available to the public in source code form.  A
 "Major Component", in this context, means a major essential component
 (kernel, window system, and so on) of the specific operating system
 (if any) on which the executable work runs, or a compiler used to
 produce the work, or an object code interpreter used to run it.

   The "Corresponding Source" for a work in object code form means all
 the source code needed to generate, install, and (for an executable
 work) run the object code and to modify the work, including scripts to
 control those activities.  However, it does not include the work's
 System Libraries, or general-purpose tools or generally available free
 programs which are used unmodified in performing those activities but
 which are not part of the work.  For example, Corresponding Source
 includes interface definition files associated with source files for
 the work, and the source code for shared libraries and dynamically
 linked subprograms that the work is specifically designed to require,
 such as by intimate data communication or control flow between those
 subprograms and other parts of the work.

   The Corresponding Source need not include anything that users
 can regenerate automatically from other parts of the Corresponding
 Source.

   The Corresponding Source for a work in source code form is that
 same work.

   2. Basic Permissions.

   All rights granted under this License are granted for the term of
 copyright on the Program, and are irrevocable provided the stated
 conditions are met.  This License explicitly affirms your unlimited
 permission to run the unmodified Program.  The output from running a
 covered work is covered by this License only if the output, given its
 content, constitutes a covered work.  This License acknowledges your
 rights of fair use or other equivalent, as provided by copyright law.

   You may make, run and propagate covered works that you do not
 convey, without conditions so long as your license otherwise remains
 in force.  You may convey covered works to others for the sole purpose
 of having them make modifications exclusively for you, or provide you
 with facilities for running those works, provided that you comply with
 the terms of this License in conveying all material for which you do
 not control copyright.  Those thus making or running the covered works
 for you must do so exclusively on your behalf, under your direction
 and control, on terms that prohibit them from making any copies of
 your copyrighted material outside their relationship with you.

   Conveying under any other circumstances is permitted solely under
 the conditions stated below.  Sublicensing is not allowed; section 10
 makes it unnecessary.

   3. Protecting Users' Legal Rights From Anti-Circumvention Law.

   No covered work shall be deemed part of an effective technological
 measure under any applicable law fulfilling obligations under article
 11 of the WIPO copyright treaty adopted on 20 December 1996, or
 similar laws prohibiting or restricting circumvention of such
 measures.

   When you convey a covered work, you waive any legal power to forbid
 circumvention of technological measures to the extent such circumvention
 is effected by exercising rights under this License with respect to
 the covered work, and you disclaim any intention to limit operation or
 modification of the work as a means of enforcing, against the work's
 users, your or third parties' legal rights to forbid circumvention of
 technological measures.

   4. Conveying Verbatim Copies.

   You may convey verbatim copies of the Program's source code as you
 receive it, in any medium, provided that you conspicuously and
 appropriately publish on each copy an appropriate copyright notice;
 keep intact all notices stating that this License and any
 non-permissive terms added in accord with section 7 apply to the code;
 keep intact all notices of the absence of any warranty; and give all
 recipients a copy of this License along with the Program.

   You may charge any price or no price for each copy that you convey,
 and you may offer support or warranty protection for a fee.

   5. Conveying Modified Source Versions.

   You may convey a work based on the Program, or the modifications to
 produce it from the Program, in the form of source code under the
 terms of section 4, provided that you also meet all of these conditions:

     a) The work must carry prominent notices stating that you modified
     it, and giving a relevant date.

     b) The work must carry prominent notices stating that it is
     released under this License and any conditions added under section
     7.  This requirement modifies the requirement in section 4 to
     "keep intact all notices".

     c) You must license the entire work, as a whole, under this
     License to anyone who comes into possession of a copy.  This
     License will therefore apply, along with any applicable section 7
     additional terms, to the whole of the work, and all its parts,
     regardless of how they are packaged.  This License gives no
     permission to license the work in any other way, but it does not
     invalidate such permission if you have separately received it.

     d) If the work has interactive user interfaces, each must display
     Appropriate Legal Notices; however, if the Program has interactive
     interfaces that do not display Appropriate Legal Notices, your
     work need not make them do so.

   A compilation of a covered work with other separate and independent
 works, which are not by their nature extensions of the covered work,
 and which are not combined with it such as to form a larger program,
 in or on a volume of a storage or distribution medium, is called an
 "aggregate" if the compilation and its resulting copyright are not
 used to limit the access or legal rights of the compilation's users
 beyond what the individual works permit.  Inclusion of a covered work
 in an aggregate does not cause this License to apply to the other
 parts of the aggregate.

   6. Conveying Non-Source Forms.

   You may convey a covered work in object code form under the terms
 of sections 4 and 5, provided that you also convey the
 machine-readable Corresponding Source under the terms of this License,
 in one of these ways:

     a) Convey the object code in, or embodied in, a physical product
     (including a physical distribution medium), accompanied by the
     Corresponding Source fixed on a durable physical medium
     customarily used for software interchange.

     b) Convey the object code in, or embodied in, a physical product
     (including a physical distribution medium), accompanied by a
     written offer, valid for at least three years and valid for as
     long as you offer spare parts or customer support for that product
     model, to give anyone who possesses the object code either (1) a
     copy of the Corresponding Source for all the software in the
     product that is covered by this License, on a durable physical
     medium customarily used for software interchange, for a price no
     more than your reasonable cost of physically performing this
     conveying of source, or (2) access to copy the
     Corresponding Source from a network server at no charge.

     c) Convey individual copies of the object code with a copy of the
     written offer to provide the Corresponding Source.  This
     alternative is allowed only occasionally and noncommercially, and
     only if you received the object code with such an offer, in accord
     with subsection 6b.

     d) Convey the object code by offering access from a designated
     place (gratis or for a charge), and offer equivalent access to the
     Corresponding Source in the same way through the same place at no
     further charge.  You need not require recipients to copy the
     Corresponding Source along with the object code.  If the place to
     copy the object code is a network server, the Corresponding Source
     may be on a different server (operated by you or a third party)
     that supports equivalent copying facilities, provided you maintain
     clear directions next to the object code saying where to find the
     Corresponding Source.  Regardless of what server hosts the
     Corresponding Source, you remain obligated to ensure that it is
     available for as long as needed to satisfy these requirements.

     e) Convey the object code using peer-to-peer transmission, provided
     you inform other peers where the object code and Corresponding
     Source of the work are being offered to the general public at no
     charge under subsection 6d.

   A separable portion of the object code, whose source code is excluded
 from the Corresponding Source as a System Library, need not be
 included in conveying the object code work.

   A "User Product" is either (1) a "consumer product", which means any
 tangible personal property which is normally used for personal, family,
 or household purposes, or (2) anything designed or sold for incorporation
 into a dwelling.  In determining whether a product is a consumer product,
 doubtful cases shall be resolved in favor of coverage.  For a particular
 product received by a particular user, "normally used" refers to a
 typical or common use of that class of product, regardless of the status
 of the particular user or of the way in which the particular user
 actually uses, or expects or is expected to use, the product.  A product
 is a consumer product regardless of whether the product has substantial
 commercial, industrial or non-consumer uses, unless such uses represent
 the only significant mode of use of the product.

   "Installation Information" for a User Product means any methods,
 procedures, authorization keys, or other information required to install
 and execute modified versions of a covered work in that User Product from
 a modified version of its Corresponding Source.  The information must
 suffice to ensure that the continued functioning of the modified object
 code is in no case prevented or interfered with solely because
 modification has been made.

   If you convey an object code work under this section in, or with, or
 specifically for use in, a User Product, and the conveying occurs as
 part of a transaction in which the right of possession and use of the
 User Product is transferred to the recipient in perpetuity or for a
 fixed term (regardless of how the transaction is characterized), the
 Corresponding Source conveyed under this section must be accompanied
 by the Installation Information.  But this requirement does not apply
 if neither you nor any third party retains the ability to install
 modified object code on the User Product (for example, the work has
 been installed in ROM).

   The requirement to provide Installation Information does not include a
 requirement to continue to provide support service, warranty, or updates
 for a work that has been modified or installed by the recipient, or for
 the User Product in which it has been modified or installed.  Access to a
 network may be denied when the modification itself materially and
 adversely affects the operation of the network or violates the rules and
 protocols for communication across the network.

   Corresponding Source conveyed, and Installation Information provided,
 in accord with this section must be in a format that is publicly
 documented (and with an implementation available to the public in
 source code form), and must require no special password or key for
 unpacking, reading or copying.

   7. Additional Terms.

   "Additional permissions" are terms that supplement the terms of this
 License by making exceptions from one or more of its conditions.
 Additional permissions that are applicable to the entire Program shall
 be treated as though they were included in this License, to the extent
 that they are valid under applicable law.  If additional permissions
 apply only to part of the Program, that part may be used separately
 under those permissions, but the entire Program remains governed by
 this License without regard to the additional permissions.

   When you convey a copy of a covered work, you may at your option
 remove any additional permissions from that copy, or from any part of
 it.  (Additional permissions may be written to require their own
 removal in certain cases when you modify the work.)  You may place
 additional permissions on material, added by you to a covered work,
 for which you have or can give appropriate copyright permission.

   Notwithstanding any other provision of this License, for material you
 add to a covered work, you may (if authorized by the copyright holders of
 that material) supplement the terms of this License with terms:

     a) Disclaiming warranty or limiting liability differently from the
     terms of sections 15 and 16 of this License; or

     b) Requiring preservation of specified reasonable legal notices or
     author attributions in that material or in the Appropriate Legal
     Notices displayed by works containing it; or

     c) Prohibiting misrepresentation of the origin of that material, or
     requiring that modified versions of such material be marked in
     reasonable ways as different from the original version; or

     d) Limiting the use for publicity purposes of names of licensors or
     authors of the material; or

     e) Declining to grant rights under trademark law for use of some
     trade names, trademarks, or service marks; or

     f) Requiring indemnification of licensors and authors of that
     material by anyone who conveys the material (or modified versions of
     it) with contractual assumptions of liability to the recipient, for
     any liability that these contractual assumptions directly impose on
     those licensors and authors.

   All other non-permissive additional terms are considered "further
 restrictions" within the meaning of section 10.  If the Program as you
 received it, or any part of it, contains a notice stating that it is
 governed by this License along with a term that is a further
 restriction, you may remove that term.  If a license document contains
 a further restriction but permits relicensing or conveying under this
 License, you may add to a covered work material governed by the terms
 of that license document, provided that the further restriction does
 not survive such relicensing or conveying.

   If you add terms to a covered work in accord with this section, you
 must place, in the relevant source files, a statement of the
 additional terms that apply to those files, or a notice indicating
 where to find the applicable terms.

   Additional terms, permissive or non-permissive, may be stated in the
 form of a separately written license, or stated as exceptions;
 the above requirements apply either way.

   8. Termination.

   You may not propagate or modify a covered work except as expressly
 provided under this License.  Any attempt otherwise to propagate or
 modify it is void, and will automatically terminate your rights under
 this License (including any patent licenses granted under the third
 paragraph of section 11).

   However, if you cease all violation of this License, then your
 license from a particular copyright holder is reinstated (a)
 provisionally, unless and until the copyright holder explicitly and
 finally terminates your license, and (b) permanently, if the copyright
 holder fails to notify you of the violation by some reasonable means
 prior to 60 days after the cessation.

   Moreover, your license from a particular copyright holder is
 reinstated permanently if the copyright holder notifies you of the
 violation by some reasonable means, this is the first time you have
 received notice of violation of this License (for any work) from that
 copyright holder, and you cure the violation prior to 30 days after
 your receipt of the notice.

   Termination of your rights under this section does not terminate the
 licenses of parties who have received copies or rights from you under
 this License.  If your rights have been terminated and not permanently
 reinstated, you do not qualify to receive new licenses for the same
 material under section 10.

   9. Acceptance Not Required for Having Copies.

   You are not required to accept this License in order to receive or
 run a copy of the Program.  Ancillary propagation of a covered work
 occurring solely as a consequence of using peer-to-peer transmission
 to receive a copy likewise does not require acceptance.  However,
 nothing other than this License grants you permission to propagate or
 modify any covered work.  These actions infringe copyright if you do
 not accept this License.  Therefore, by modifying or propagating a
 covered work, you indicate your acceptance of this License to do so.

   10. Automatic Licensing of Downstream Recipients.

   Each time you convey a covered work, the recipient automatically
 receives a license from the original licensors, to run, modify and
 propagate that work, subject to this License.  You are not responsible
 for enforcing compliance by third parties with this License.

   An "entity transaction" is a transaction transferring control of an
 organization, or substantially all assets of one, or subdividing an
 organization, or merging organizations.  If propagation of a covered
 work results from an entity transaction, each party to that
 transaction who receives a copy of the work also receives whatever
 licenses to the work the party's predecessor in interest had or could
 give under the previous paragraph, plus a right to possession of the
 Corresponding Source of the work from the predecessor in interest, if
 the predecessor has it or can get it with reasonable efforts.

   You may not impose any further restrictions on the exercise of the
 rights granted or affirmed under this License.  For example, you may
 not impose a license fee, royalty, or other charge for exercise of
 rights granted under this License, and you may not initiate litigation
 (including a cross-claim or counterclaim in a lawsuit) alleging that
 any patent claim is infringed by making, using, selling, offering for
 sale, or importing the Program or any portion of it.

   11. Patents.

   A "contributor" is a copyright holder who authorizes use under this
 License of the Program or a work on which the Program is based.  The
 work thus licensed is called the contributor's "contributor version".

   A contributor's "essential patent claims" are all patent claims
 owned or controlled by the contributor, whether already acquired or
 hereafter acquired, that would be infringed by some manner, permitted
 by this License, of making, using, or selling its contributor version,
 but do not include claims that would be infringed only as a
 consequence of further modification of the contributor version.  For
 purposes of this definition, "control" includes the right to grant
 patent sublicenses in a manner consistent with the requirements of
 this License.

   Each contributor grants you a non-exclusive, worldwide, royalty-free
 patent license under the contributor's essential patent claims, to
 make, use, sell, offer for sale, import and otherwise run, modify and
 propagate the contents of its contributor version.

   In the following three paragraphs, a "patent license" is any express
 agreement or commitment, however denominated, not to enforce a patent
 (such as an express permission to practice a patent or covenant not to
 sue for patent infringement).  To "grant" such a patent license to a
 party means to make such an agreement or commitment not to enforce a
 patent against the party.

   If you convey a covered work, knowingly relying on a patent license,
 and the Corresponding Source of the work is not available for anyone
 to copy, free of charge and under the terms of this License, through a
 publicly available network server or other readily accessible means,
 then you must either (1) cause the Corresponding Source to be so
 available, or (2) arrange to deprive yourself of the benefit of the
 patent license for this particular work, or (3) arrange, in a manner
 consistent with the requirements of this License, to extend the patent
 license to downstream recipients.  "Knowingly relying" means you have
 actual knowledge that, but for the patent license, your conveying the
 covered work in a country, or your recipient's use of the covered work
 in a country, would infringe one or more identifiable patents in that
 country that you have reason to believe are valid.

   If, pursuant to or in connection with a single transaction or
 arrangement, you convey, or propagate by procuring conveyance of, a
 covered work, and grant a patent license to some of the parties
 receiving the covered work authorizing them to use, propagate, modify
 or convey a specific copy of the covered work, then the patent license
 you grant is automatically extended to all recipients of the covered
 work and works based on it.

   A patent license is "discriminatory" if it does not include within
 the scope of its coverage, prohibits the exercise of, or is
 conditioned on the non-exercise of one or more of the rights that are
 specifically granted under this License.  You may not convey a covered
 work if you are a party to an arrangement with a third party that is
 in the business of distributing software, under which you make payment
 to the third party based on the extent of your activity of conveying
 the work, and under which the third party grants, to any of the
 parties who would receive the covered work from you, a discriminatory
 patent license (a) in connection with copies of the covered work
 conveyed by you (or copies made from those copies), or (b) primarily
 for and in connection with specific products or compilations that
 contain the covered work, unless you entered into that arrangement,
 or that patent license was granted, prior to 28 March 2007.

   Nothing in this License shall be construed as excluding or limiting
 any implied license or other defenses to infringement that may
 otherwise be available to you under applicable patent law.

   12. No Surrender of Others' Freedom.

   If conditions are imposed on you (whether by court order, agreement or
 otherwise) that contradict the conditions of this License, they do not
 excuse you from the conditions of this License.  If you cannot convey a
 covered work so as to satisfy simultaneously your obligations under this
 License and any other pertinent obligations, then as a consequence you may
 not convey it at all.  For example, if you agree to terms that obligate you
 to collect a royalty for further conveying from those to whom you convey
 the Program, the only way you could satisfy both those terms and this
 License would be to refrain entirely from conveying the Program.

   13. Use with the GNU Affero General Public License.

   Notwithstanding any other provision of this License, you have
 permission to link or combine any covered work with a work licensed
 under version 3 of the GNU Affero General Public License into a single
 combined work, and to convey the resulting work.  The terms of this
 License will continue to apply to the part which is the covered work,
 but the special requirements of the GNU Affero General Public License,
 section 13, concerning interaction through a network will apply to the
 combination as such.

   14. Revised Versions of this License.

   The Free Software Foundation may publish revised and/or new versions of
 the GNU General Public License from time to time.  Such new versions will
 be similar in spirit to the present version, but may differ in detail to
 address new problems or concerns.

   Each version is given a distinguishing version number.  If the
 Program specifies that a certain numbered version of the GNU General
 Public License "or any later version" applies to it, you have the
 option of following the terms and conditions either of that numbered
 version or of any later version published by the Free Software
 Foundation.  If the Program does not specify a version number of the
 GNU General Public License, you may choose any version ever published
 by the Free Software Foundation.

   If the Program specifies that a proxy can decide which future
 versions of the GNU General Public License can be used, that proxy's
 public statement of acceptance of a version permanently authorizes you
 to choose that version for the Program.

   Later license versions may give you additional or different
 permissions.  However, no additional obligations are imposed on any
 author or copyright holder as a result of your choosing to follow a
 later version.

   15. Disclaimer of Warranty.

   THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
 APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
 HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
 OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
 THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
 IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
 ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

   16. Limitation of Liability.

   IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
 WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
 THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
 GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
 USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
 DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
 PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
 EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
 SUCH DAMAGES.

   17. Interpretation of Sections 15 and 16.

   If the disclaimer of warranty and limitation of liability provided
 above cannot be given local legal effect according to their terms,
 reviewing courts shall apply local law that most closely approximates
 an absolute waiver of all civil liability in connection with the
 Program, unless a warranty or assumption of liability accompanies a
 copy of the Program in return for a fee.

                      END OF TERMS AND CONDITIONS

             How to Apply These Terms to Your New Programs

   If you develop a new program, and you want it to be of the greatest
 possible use to the public, the best way to achieve this is to make it
 free software which everyone can redistribute and change under these terms.

   To do so, attach the following notices to the program.  It is safest
 to attach them to the start of each source file to most effectively
 state the exclusion of warranty; and each file should have at least
 the "copyright" line and a pointer to where the full notice is found.

     <one line to give the program's name and a brief idea of what it does.>
     Copyright (C) <year>  <name of author>

     This program is free software: you can redistribute it and/or modify
     it under the terms of the GNU General Public License as published by
     the Free Software Foundation, either version 3 of the License, or
     (at your option) any later version.

     This program is distributed in the hope that it will be useful,
     but WITHOUT ANY WARRANTY; without even the implied warranty of
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     GNU General Public License for more details.

     You should have received a copy of the GNU General Public License
     along with this program.  If not, see <http://www.gnu.org/licenses/>.

 Also add information on how to contact you by electronic and paper mail.

   If the program does terminal interaction, make it output a short
 notice like this when it starts in an interactive mode:

     <program>  Copyright (C) <year>  <name of author>
     This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
     This is free software, and you are welcome to redistribute it
     under certain conditions; type `show c' for details.

 The hypothetical commands `show w' and `show c' should show the appropriate
 parts of the General Public License.  Of course, your program's commands
 might be different; for a GUI interface, you would use an "about box".

   You should also get your employer (if you work as a programmer) or school,
 if any, to sign a "copyright disclaimer" for the program, if necessary.
 For more information on this, and how to apply and follow the GNU GPL, see
 <http://www.gnu.org/licenses/>.

   The GNU General Public License does not permit incorporating your program
 into proprietary programs.  If your program is a subroutine library, you
 may consider it more useful to permit linking proprietary applications with
 the library.  If this is what you want to do, use the GNU Lesser General
 Public License instead of this License.  But first, please read
 <http://www.gnu.org/philosophy/why-not-lgpl.html>.

=cut

####### Imports
#
# We want everything required for aimake to run to be contained in this single
# file, apart from the Perl distribution itself (which is obviously required
# to be able to run it). As such, only modules that ship with Perl are legal
# here. Additionally, in order to keep as much portability as possible, we aim
# for compatibility with old Perl versions. The oldest supported version is
# 5.8, a mostly arbitrarily choice based on anecdotal data (it's the oldest
# version I've seen anyone been unable to upgrade from for years). There's a
# list of which modules shipped with which versions in Module::CoreList.
# (Additionally, avoid modules that were removed or deprecated in later
# versions.)
use 5.008;

use Getopt::Std qw/getopts/;
use File::Path qw/make_path/;
use File::Spec ();
use File::Temp qw/tempfile/;
use File::Find qw/finddepth/;
use Cwd qw/cwd realpath/;
use Fcntl qw/:DEFAULT :flock :seek/;
use FindBin qw'$RealBin';
use ExtUtils::MakeMaker;
use Memoize;
use Carp;
use Config;
use Getopt::Long;
use Pod::Usage qw/pod2usage/;
use POSIX qw/sigprocmask SIG_SETMASK/;
use PerlIO;
use PerlIO::encoding;
use Encode qw/encode :fallbacks/;
use Data::Dumper;
use Digest::MD5 qw/md5_hex/;
use Safe;
use Storable qw/store_fd fd_retrieve dclone/; # why the naming inconsistency?

####### Global variables and constants

use constant configfilename => 'path:aimake.rules';
use constant statefilename => 'bpath:aimake.objects';

select STDERR;
$| = 1;
select STDOUT;

my ($opt_verbose, $opt_install, $opt_prefix, $opt_dump, @opt_warnings,
    $opt_ignore_builtin_config, $opt_version, $opt_dlayout,
    $opt_nocr, @opt_rebuild, $opt_documentation, $opt_license);  # options
my ($codeset, $text_layers, $binary_layers,
    $utf8_layers, $ascii_layers); # encodings
my ($path, $bpath, $ipath, $singledir, $cwd); # important paths
my $installing;                   # mode of operation
my %config_hashes = ();           # configuration
my ($state, $state_fh, $config);  # state and configuration handling

####### Subroutines

##### Portability

### Backwards compatibility for old perl versions
#
# The // operator was introduced in Perl 5.10, so here's a function that
# does the same thing.
sub defined_or { defined $_[0] and return $_[0]; return $_[1]; }

##### Progress reporting
sub run_command;
{
    my $colwidth = undef;
    my $last_report_msg = '';
    # There's no portable way to determine the screen width, but
    # we can do it via tput if tput exists. Otherwise, 80 is a
    # reasonable guess.
    sub screenwidth {
        my $failreason;
        $colwidth and return $colwidth;
        ($failreason, $colwidth) =
            run_command "cmd:tput", "optstring:cols", \ "nostderr"
            and !$failreason and return $colwidth;
        $colwidth = 80; return $colwidth;
    }
    sub print_stderr_tl {
        # Calling binmode on stderr makes all redirects on it slower, for the
        # rest of the program, leading to quadratic performance. So we do
        # things the old-fashioned way instead.
        my $msg = shift;
        $msg = encode($codeset, $msg);
        print STDERR $msg;
    }
    sub progress_report {
        my $level = shift;
        my $str = shift;
        if ($level <= $opt_verbose && !$opt_nocr) {
            # We may have to clear the line the old-fashioned way.
            print_stderr_tl (' ' x (length defined_or($last_report_msg,"")) .
                             "\r");
            $last_report_msg = '';
        }
        my $ldiff = (length $str) - length defined_or($last_report_msg,"");
        $ldiff < 0 and $str .= ' ' x -$ldiff;
        if ($level <= $opt_verbose + 0.5 && $level > $opt_verbose
            && $level < 3 && !$opt_nocr) {
            $str = substr $str, 0, screenwidth - 1;
            print_stderr_tl "$str\r";
            $str =~ s/ +$//;
            $last_report_msg = $str;
        } elsif ($level <= $opt_verbose) {
            print_stderr_tl "$str\n";
            $last_report_msg = '';
        }
        return 1;
    }
}

##### Generic utilities

### Scalar manipulation

# Deep compare on two scalars (a bit like a deep copy); returns true if they
# are copies of each other (deep, shallow, or in between)
sub deepequals {
    my $x1 = shift;
    my $x2 = shift;
    !defined $x1 and return !defined $x2;
    !defined $x2 and return;
    !ref $x1 && !ref $x2 and return $x1 eq $x2; # neither is a reference
    !ref $x1 || !ref $x2 and return; # one is a reference, the other isn't
    ref $x1 ne ref $x2 and return; # they're different types of reference
    ref $x1 eq 'SCALAR' and return deepequals($$x1, $$x2);
    if (ref $x1 eq 'ARRAY') {
        return unless $#$x1 == $#$x2;
        deepequals($x1->[$_], $x2->[$_]) or return for 0..$#$x1;
        return 1;
    }
    if (ref $x1 eq 'HASH') {
        my @keys1 = sort keys %$x1;
        my @keys2 = sort keys %$x2;
        return unless deepequals(\@keys1, \@keys2);
        deepequals($x1->{$_}, $x2->{$_}) or return for @keys1;
        return 1;
    }
    die "Cannot compare references of type '" . ref $x1 . "'";
}

# Hashing arbitrary scalars.
sub serialize_sv {
    my $sv = shift;
    defined $sv or return 'u';
    # Make sure we're always using the string version of $sv.
    ref $sv or return "s" . (length "$sv") . " $sv";
    (ref $sv) =~ /\bRegexp$/ and return "r" . (length "$sv") . " $sv";
    if (ref $sv eq 'ARRAY') {
        my $x = "a" . scalar @$sv . " ";
        $x .= serialize_sv($_) for @$sv;
        return $x;
    }
    if (ref $sv eq 'HASH') {
        my @keys = sort keys %$sv;
        my $x = "h" . scalar @keys. " ";
        $x .= serialize_sv($_). serialize_sv($sv->{$_}) for @keys;
        return $x;
    }
    die "serialize_sv called on unsupported reference type " . ref $sv;
}
sub sv_hash {
    return md5_hex(serialize_sv(shift));
}

##### Object name handling
#
# All objects have an object type, and a value. Depending on the object type,
# they might also have an inner (nested) object. Some objects are produced,
# and some are provided (and some are just virtual).
my %objtype_nested = (
    path => 0, bpath => 0, spath => 0, extend => 1, file => 0, symbol => 0,
    shared_symbol => 0, symbolset => 1, symbol_in_object => 1, namehint => 1,
    config_option => 0, config_rule => 0, cmd => 0, tool => 0, intcmd => 0,
    optstring => 0, optpath => 1, optionset => 0, sys => 0, searchpath => 0,
    searchfile => 0, searchlib => 0, dependencies => 1);
my %objtype_provided = (
    path => 0, bpath => 0, spath => 0, extend => 0, file => 1, symbol => 1,
    shared_symbol => 1, symbolset => 1, symbol_in_object => 1, namehint => 0,
    config_option => 0, config_rule => 0, cmd => 0, tool => 1, intcmd => 0,
    optstring => 0, optpath => 0, optionset => 1, sys => 0, searchpath => 1,
    searchfile => 1, searchlib => 1, dependencies => 1);
my %objtype_is_special = ( # TODO: existence check for (int)?cmd:?
    path => 0, bpath => 0, spath => 0, extend => 1, file => 0, symbol => 0,
    shared_symbol => 0, symbolset => 0, symbol_in_object => 0, namehint => 1,
    config_option => 0, config_rule => 0, cmd => 1, tool => 0, intcmd => 1,
    optstring => 1, optpath => 1, optionset => 0, sys => 1, searchpath => 0,
    searchfile => 0, searchlib => 0, dependencies => 0);

# Some object types allow multiple interchangeable providers, requiring the
# same outdepends from each provider. This is done via a regex, rather than
# via parsing + a hash, because it's part of the inner loop.
use constant multiple_providers_ok_regex =>
    qr/^(?>s(?:earch(?:file|lib)|ymbolset|hared_symbol|path)|path):/;

# Splits an object name into its components. If the second argument is true,
# don't worry about missing components.
sub parse_objname {
    my $objname = shift;
    my $relaxed = shift;
    $objname =~ /^([^:]+):(.*)$/s or
        croak "Invalid object name $objname";
    my $objtype = $1;
    my $objvalue = $2;
    if ($objtype_nested{$objtype}) {
        unless ($objvalue =~ /^([^:]*):(.*)$/s) {
            $relaxed or croak "Invalid object content $objvalue";
            return ($objtype, $objvalue);
        }
        return ($objtype, $1, $2);
    }
    return ($objtype, $objvalue);
}
# don't memoize; it's very slightly slower (40 microseconds, not 32)

# Splits a pair name into components. A pair name is "$rule $object".
sub parse_pairname {
    my $pairname = shift;
    $pairname =~ /^([^ ]+) (.*)$/s or
        croak "Invalid pair name '$pairname'";
    return ($1, $2);
}

# Resolve an extend: object. Other objects are returned unchanged.
# extend: objects are either used to find parent directories (value = ..), or
# used to construct filenames in the build directory (other values).
sub aipath_parent;
sub parse_aipath;
sub deparse_aipath;
sub resolve_extend {
    my $objname = shift;
    my ($objtype, $objvalue, $objinner) = parse_objname $objname;

    $objtype eq 'extend' or return $objname;

    $objvalue eq '..' and return aipath_parent $objinner;

    (undef, undef, $objinner) = parse_objname $objinner
        while $objinner =~ /^symbolset:/;

    my @aipath = parse_aipath $objinner;
    # Remove any existing extension. It's OK if this doesn't match.
    $aipath[-1] =~ s/\.[^.]+//s;
    $aipath[-1] .= $objvalue;

    $aipath[0] = 'bpath';

    return deparse_aipath @aipath;
}

# Given a potentially incomplete reference to an object name, complete it if
# it actually is incomplete. Incomplete object names could be of any of the
# following formats:
# [the null string]
# type:
# type:value                [for nested types]
# type:value:
# type:value:incomplete_inner
# Complete object names could be either of these:
# type:value                [for non-nested types]
# type:value:complete_inner
sub complete_objname;
sub complete_objname {
    my $objnameref = shift;
    my $inner = shift;
    if ($$objnameref eq '') { $$objnameref = $inner; return; }
    my ($objtype, $objvalue, $objinner) = parse_objname $$objnameref, 1;
    $objtype_nested{$objtype} or return;
    if (defined $objinner && $objinner ne '') {
        complete_objname \$objinner, $inner;
        $$objnameref = "$objtype:$objvalue:$objinner";
    } else {
        $$objnameref = "$objtype:$objvalue:$inner";
    }
}

# Constructs an object name in a form that's nice for users to read, even if
# it loses a bit of information. This means using their own native path format
# when possible (with relative paths to save space, and conflating the path
# and the bpath because it usually doesn't matter), removing extraneous
# metadata, etc.
sub aipath2ospath;
sub friendly_objname;
sub friendly_objname {
    return shift if $opt_verbose >= 4;

    my ($objtype, $objvalue, $objinner) =
        parse_objname (resolve_extend shift);

    # The bpath in the first case is correct; we conflate the path and bpath
    $objtype eq  'path' and return aipath2ospath "bpath:$objvalue", 'bpath:';
    $objtype eq 'bpath' and return aipath2ospath "bpath:$objvalue", 'bpath:';
    $objtype eq 'spath' and return aipath2ospath "spath:$objvalue";

    $objtype eq 'symbol'           and return $objvalue;
    $objtype eq 'symbol_in_object' and return $objvalue;

    $objtype eq 'dependencies'     and return friendly_objname $objinner;

    defined $objinner and return "$objtype:$objvalue:$objinner";
    return "$objtype:$objvalue";
}

##### Path handling
#
# All internal calculations are done using aimake path format.
#
# Relative paths are specified as a slash-separated list of directory names,
# perhaps ending in a filename. Arbitrary characters are allowed inside
# directory and file names, but any slashes, backslashes, or colons are
# protected via preceding them with a backslash. The path format itself does
# not distinguish between files and directories, and contains no equivalent to
# . or .. (and as such cannot reach out above the directory the path is
# relative to). Likewise, aimake paths are case-sensitive regardless of the
# underlying filesystem; if running on a case-insensitive filesystem, they're
# forced to consistent case (foldcase if there's enough Unicode support
# available to do that, otherwise lowercase).
#
# Absolute paths are similar, but have one extra component at the start,
# specifying which root on the filesystem to use. This component is present no
# matter what the OS, but on OSes like UNIX that have a single root on their
# filesystem, it's the null string.
#
# aimake paths are only ever used as components of object names; as such,
# they're always preceded by an object type. Here are the object types that
# can be passed to these functions:
#
# bpath:[relative path]    A path relative to the build directory ($bpath)
# path:[relative path]     A path relative to the source directory ($path)
# spath:[absolute path]    An absolute path
#
# When outputting an aimake object name, the same object types are used (and
# also, in special cases, file:).
#
# There are other object types that conceptually represent files, like
# extend:, but those are too high-level to be passed to these low-level
# routines, and must be converted to [bs]?path:s first.

### Logical path manipulation

# The most important directories. Note that $bpath and $path are stored as
# spaths, contrary to normal practice; this is to avoid a circular definition.
# $path is set when parsing options.
sub ospath2aipath;
$bpath = ospath2aipath cwd, undef, 1;
$cwd = 'bpath:';

# Given an aimake path, splits it into components, unescaping them.
# The first component will be path/bpath/spath.
my $aipath_element = qr//s;
sub parse_aipath;
sub parse_aipath {
    my $aipath = shift;
    my ($objtype, $objvalue, $objinner) = parse_objname $aipath;
    $objtype =~ /^[bs]?path$/ or croak "Invalid path type $objtype";
    my @aipath = ();
    push @aipath, $1 while $objvalue =~ m=((?:[^\\\/:]|\\.)*)( / | $ )=gsx;
    pop @aipath; # remove a null string at the end
    s/\\(.)/$1/gs for @aipath;
    return ($objtype, @aipath);
}

# Given the components of an aimake path, creates the path, via escaping them
# and adding appropriate separators. This is the inverse of parse_aipath.
sub deparse_aipath {
    my $objtype = shift;
    my @aipath = (@_);
    s/([\\\/:])/\\$1/gs for @aipath;
    return $objtype . ":" . join '/', @aipath;
}

# Given a native OS path, returns the matching aimake path, as an object name.
#
# The OS path should typically be an absolute path. If no second argument is
# given, relative paths are taken to be relative to the current directory
# (typically $bpath). If some second argument is given, then relative paths
# are interpreted as files in some unknown location, and returned as file:
# objects; the second argument is just interpreted as a boolean. The third
# argument forces the resulting path to be an spath, which is only used before
# $bpath is set (in order to be able to set $bpath).
sub ospath2aipath {
    my $ospath = shift;
    my $required_by = shift;
    my $force_spath = shift;

    # If we're trying to convert a nonexistent path, we won't be able to
    # realpath it successfully. So we need an eval to trap errors.
    eval {
        !defined $required_by || File::Spec->file_name_is_absolute($ospath)
            and $ospath = realpath($ospath);
    };

    if (File::Spec->case_tolerant) {
        $ospath = defined_or(
            eval 'use feature ":5.16"; fc $ospath',
            lc $ospath);
    }

    if (File::Spec->file_name_is_absolute($ospath)) {
        my ($vol, $dirs, $file) = File::Spec->splitpath($ospath);
        my @dirs = File::Spec->splitdir($dirs);
        $dirs[0] eq File::Spec->rootdir and shift @dirs;
        my @aipath = ('spath', $vol, (grep {$_ ne ''} @dirs, $file));
        my $aipath = deparse_aipath @aipath;
        if (!$force_spath) {
            # A nice property of aimake spaths: if spath X contains spath Y,
            # then X is textually a prefix of Y. The bpath might be inside
            # the path, but not vice versa, so we check the bpath first.
            $aipath eq $bpath and $aipath = 'bpath:';
            $aipath =~ /^\Q$bpath\E\/(.*)$/ and $aipath = "bpath:$1";
            $path and $aipath eq $path and $aipath = 'path:';
            $path and $aipath =~ /^\Q$path\E\/(.*)$/  and $aipath = "path:$1";
        }
        return $aipath;
    } else {
        # Ignore the root: we can't make anything sensible of D:.. anyway
        my (undef, $dirs, $file) = File::Spec->splitpath($ospath);
        my @dirs = File::Spec->splitdir($dirs);
        my @aipath = (grep {$_ ne ''} 'file', @dirs, $file);
        return deparse_aipath @aipath;
    }
}

# Given an aimake path (as an object name), returns an equivalent filename (or
# directory name) that can be interpreted by the native operating system.
#
# This will typically be an absolute path regardless of the location of the
# aimake path. The second argument can be set to a directory (an aimake path)
# to instead attempt to produce a short path, by using a relative path to that
# path if possible (for simpler visual inspection, or because the filename is
# being recorded in an archive, or perhaps because the filename is going to be
# passed to a program that's expecting a specific name). Sensible values for
# $shorten are pretty much limited to undef, $bpath, and $cwd.
sub aipath2ospath {
    my $aipath = shift;
    my $shorten = shift;
    $shorten and $aipath eq $shorten and return File::Spec->curdir();
    $shorten and $shorten ne 'bpath:' and $shorten ne 'path:' and
        $shorten .= '/';
    if ($shorten && $aipath =~ /^\Q$shorten\E(.*)$/s) {
        # A relative path is requested and possible.
        my @aipath = parse_aipath "path:$1";
        shift @aipath; # remove the dummy "path:"
        # A bare filename/dirname with no path?
        scalar @aipath == 1 and return $aipath[0];
        # Otherwise, concatenate the path together. (File::Spec->catfile
        # requires at least two components to work correctly. Even then, it
        # assumes it's producing a file rather than a directory, but we don't
        # have enough information to tell otherwise.)
        return File::Spec->catfile(@aipath);
    } else {
        # An absolute path is requested, or necessary.
        # (Note that path: might not be set yet during system initialization,
        # due to the chicken-and-egg problem of the path depending on the
        # statefile and the statefile being in the bpath.)
        $aipath eq 'path:' and $aipath = $path;
        $aipath eq 'bpath:' and $aipath = $bpath;
        $path and $aipath =~ s=^path:=$path/=;
        $aipath =~ s=^bpath:=$bpath/=;
        my (undef, $vol, @dirs) = parse_aipath $aipath; # ignore the spath:
        my $file = pop @dirs;
        unshift @dirs, File::Spec->rootdir;
        return File::Spec->catpath($vol, File::Spec->catdir(@dirs), $file);
    }
}

# Given an aimake path, returns the containing directory.
# This cannot meaningfully be done for "path:" (the source directory),
# "bpath:" (the build directory), or any spath: object without slashes
# (a root of the OS filesystem).
sub aipath_parent {
    my $aipath = shift;
    my @aipath = (parse_aipath $aipath);
    pop @aipath;
    scalar @aipath < 1 || $aipath[0] eq 'spath' && scalar @aipath < 2
        and croak "Tried to take the parent of root '" .
        friendly_objname($aipath) . "'";
    return deparse_aipath @aipath;
}

# Given an aimake path (as an object name), returns it as an aimake path
# (again, as an object name). The result might not match the original if, say,
# it's actually inside the bpath but specified as an spath, or contains
# similar issues.
sub cleanup_aipath {
    return ospath2aipath(aipath2ospath($_[0]));
}


### I/O

# Complains (and halts the program) if the argument is not writable.
#
# We consider the bpath: to be freely writable, the path: to be untouchable,
# and the spath: to be usually untouchable except during install operations.
# This is a check to avoid accidentally overwriting files that we shouldn't
# change (most likely due to a misconfiguration), and is separate from any
# read-only status that might exist in the filesystem.
sub verify_writable {
    my $aipath = shift;
    my $installing = shift;
    my $aipath_c = cleanup_aipath $aipath;
    my $fon = friendly_objname $aipath_c;
    $aipath_c =~ /^path:/ and croak "Attempt to overwrite source file '$fon'";
    $aipath_c =~ /^spath:/ and !$installing and croak
        "Attempt to overwrite system file '$fon'";
}

# Creates a directory, if it doesn't already exist.
#
# The directory's parents will also be created if necessary. If the second
# argument is false, the first argument is the directory to create. If the
# second argument is true, the first argument is a file inside the directory
# to create (and as such, the containing directories will be created, but not
# the file itself).
#
# This will do nothing, rather than error out, if given an object that isn't
# an aimake path.
sub ensure_directory {
    my $aipath = shift;
    my $containing_only = shift;
    my $installing = shift;

    my ($objtype, undef) = parse_objname $aipath;
    $objtype =~ /^[bs]?path$/ or return;

    $containing_only and $aipath = aipath_parent $aipath;
    verify_writable $aipath, $installing;
    my $fon = friendly_objname $aipath;
    my $ospath = aipath2ospath $aipath;

    return if -d $ospath; # avoid a useless message
    die "Found a non-directory at '$fon'" if -e $ospath;
    progress_report 1, "Creating directory '$fon'...";
    make_path $ospath or die "Could not create directory '$fon': $!";
}

# Takes the hash of a file on disk. This modifies state, so should be
# protected via atomically{}.
#
# This uses the modification time to check to see if a file has been changed;
# however, we have to be careful. If the file was changed very recently, it's
# possible it'll be changed again in the same second, meaning we wouldn't
# notice the change. The obvious thing to do would be to compare the
# modification time to the current time, but that's unsafe due to clock skew;
# there's no guarantee that the filesystem is using anything approximating the
# same times as the system clock (and because the files may be on separate
# filesystems, also no guarantee that files use the same times as each other,
# meaning we can't just measure the clock skew and use the measured value).
#
# Instead, we use four fields:
#
# _mtime: the modification time of the file the last time we checked it;
#
# _ltime: the time on the system clock the last time _mtime or _mhash changed;
#
# _mhash: the hash of the file the last time we checked it;
#
# _hashok: true if the file was checked twice, 3 or more seconds apart, had
# the same mtime and mhash on both occasions, and _mtime and _mhash are still
# the same as they were then.
#
# If _hashok is set and _mtime equals the file's modification time, then the
# file must still have the same hash (barring manual timestamp adjustment);
# the hash was correct as of the second check, and any change to the file
# after the second check would have changed its modification time (because its
# modification time had the same value as the first check, and the filesystem
# clock must have changed since then).
sub file_hash {
    my $aipath = shift;
    my ($objtype, undef) = parse_objname $aipath;
    my $ospath = aipath2ospath $aipath;
    -e $ospath or return;
    my $mtime = (stat(_))[9];
    my $ltime = time;
    my $oldmtime = defined_or($state->{_mtime}->{$aipath}, -1);
    my $oldltime = defined_or($state->{_ltime}->{$aipath}, -1);
    my $oldmhash = defined_or($state->{_mhash}->{$aipath}, 'x');
    my $hashok = $state->{_hashok}->{$aipath};

    return $oldmhash if $mtime == $oldmtime && $hashok;

    $state->{_mtime}->{$aipath} = $mtime;
    my $digestor = Digest::MD5->new;
    open my $fh, "<$binary_layers", $ospath
        or croak "'$ospath' exists but is not readable";
    $digestor->addfile($fh);
    close $fh;
    my $mhash = $digestor->hexdigest;

    $state->{_mhash}->{$aipath} = $mhash;
    $state->{_ltime}->{$aipath} = $ltime
        if $oldmtime != $mtime || $oldmhash ne $mhash;
    $state->{_hashok}->{$aipath} =
        ($ltime > $oldltime + 3 &&
         $mtime == $oldmtime && $mhash eq $oldmhash);

    return $mhash;
}

##### Interfacing with OS facilities

# Finds the executable for a command, or undef if the command doesn't exist on
# the system. MakeMaker's used to search for the command because it
# understands the differences between operating systems with respect to
# executable naming, and it's one of the modules we have access to in 5.8;
# IPC::Cmd would be reasonable in a more modern Perl (and just goes indirectly
# via MakeMaker anyway).
sub locate_command {
    my $cmd = shift;
    for my $dir (File::Spec->path) {
        my $fnos = File::Spec->rel2abs($cmd, $dir);
        my $cmdos = MM->maybe_command($fnos);
        return ospath2aipath $cmdos if $cmdos;
    }
    return;
}
memoize('locate_command');

# Returns the name of a signal, given its number.
{
    my %signal_map = ();
    my $signal_map_initialized = 0;
    sub signal_name {
        my $signum = shift;
        $Config{sig_name} && $Config{sig_num}
            or return "SIG_$signum";
        unless ($signal_map_initialized) {
            @signal_map{split ' ', $Config{sig_num}} =
                (split ' ', $Config{sig_name});
            $signal_map_initialized = 1;
        }
        return "SIG" . defined_or($signal_map{$signum}, "_$signum");
    }
}

# Given a command, and an argument list, runs the command.
#
# The command and arguments are all objects; one bpath/cmd/intcmd, and a list
# of optstrings and optpaths. A few options are also accepted, given as scalar
# references:
# \ "nostderr"      Don't try to capture stderr, leaving it unredirected.
# \ "cwd:$aipath"   Use $aipath as the current working directory.
# \ "locale:$l"     Use $l as the locale for running the command.
# \ "relpaths"      Use relative paths. (By default, absolute paths are used.)
# \ "cmdline"       Return the command line, and take no other action.
#
# Irrelevant objects can be given, and will simply be ignored. intcmd and cmd
# objects take precedence when determining which is a command; otherwise, we
# use an executable on the bpath. If there's more than one equally good option
# for the command, or no options, we throw an exception. The options will be
# passed to the command in the standard order (early optstrings, optpaths with
# a value, plain optpaths, late optstrings), maintaining order as a tiebreak.
#
# The return value is ($failreason, $stdout, $stderr). $failreason will be
# undef if everything worked fine, or otherwise a textual description of what
# went wrong. $stdout and $stderr are captures of the command's stdout and
# stderr (its stdin will remain unredirected), interpreted in text mode (so
# you'll get CRLF translation on Windows).
#
# With \ "cmdline" set, the return value is a single scalar, representing a
# human-readable command line. (It may be slightly ambiguous, such as via
# failing to escape filenames; this is intentional in order to produce the
# most readable path possible, but should not be run as a result.)
my %listtree_cache = ();
sub run_command {
    # Find options and executables.
    my @xuse = grep !ref $_, @_;
    my @execs = grep /^(?:cmd|intcmd):/, @xuse;
    my @opts = grep /^opt(?:string|path):/, @xuse;
    my %intopts = map {$$_ =~ /^(cwd|locale):(.*)$/s ? ($1 => $2) : ($$_ => 1)}
        grep ref $_, @_;
    if (scalar @execs == 0) {
        @execs = grep /^bpath:/, @xuse;
        @execs = grep {-x aipath2ospath($_)} @execs;
    }
    scalar @execs == 0 and die "Cannot find command in {" .
        (join ', ', map +(friendly_objname $_), @xuse) . "}";
    scalar @execs > 1 and die "Found too many commands: {" .
        (join ', ', map +(friendly_objname $_), @execs) . "}";

    # Move options into order.
    @opts = ((grep /^optstring:[^ ]/, @opts),
             (grep !/^optstring:./s && !/^optpath::/, @opts),
             (grep /^optpath::/, @opts),
             (grep /^optstring: /, @opts));

    my $cmd = $execs[0];
    if ($cmd =~ /^intcmd:/ && !$intopts{'cmdline'}) {
        if ($cmd eq 'intcmd:nop') {
            return (undef, '', '');
        } elsif ($cmd eq 'intcmd:cat') {
            scalar @opts == 1 and $opts[0] =~ /^optpath::(.*)$/s
                or return ("Invalid arguments", '', '');
            my $fn = aipath2ospath($1);
            # TODO: User-customizable encoding?
            open my $fh, "<$utf8_layers", $fn or
                return ("Could not open 'fn' for reading: $!", '', '');
            local $/ = undef;
            my $stdout = <$fh>;
            close $fh;
            return (undef, $stdout, '');
        } elsif ($cmd eq 'intcmd:filetest') {
            @opts = sort @opts;
            scalar @opts == 2 and $opts[1] =~ /^optstring:-[fdlxzsTB]/
                and $opts[0] =~ /^optpath::(.*)$/s
                or return ("Invalid arguments", '', '');
            my $fn = aipath2ospath($1);
            my ($ts, $expl);
            $opts[1] =~ s/^optstring:-//;
            $opts[1] eq 'f' and ($ts, $expl) = (-f $fn, 'present');
            $opts[1] eq 'd' and ($ts, $expl) = (-d $fn, 'a directory');
            $opts[1] eq 'l' and ($ts, $expl) = (-l $fn, 'a symlink');
            $opts[1] eq 'x' and ($ts, $expl) = (-x $fn, 'executable');
            $opts[1] eq 'z' and ($ts, $expl) = (-z $fn, 'empty');
            $opts[1] eq 's' and ($ts, $expl) = (-s $fn, 'nonempty');
            $opts[1] eq 'T' and ($ts, $expl) = (-T $fn, 'a text file');
            $opts[1] eq 'B' and ($ts, $expl) = (-B $fn, 'a binary file');
            !$ts and return ("$fn is not $expl", '', '');
            return (undef, '', '');
        } elsif ($cmd eq 'intcmd:echo') {
            map +(s/^optstring: ?// || s/^optpath:([^:]*):/$1/), @opts;
            return (undef, (join ' ', @opts), '');
        } elsif ($cmd eq 'intcmd:writefile' ||
                 $cmd eq 'intcmd:testruncount') {
            my @paths = grep /^optpath::/s, @opts;
            my @strings = grep /^optstring:/s, @opts;
            scalar @paths + scalar @strings == scalar @opts
                or return ("Invalid arguments (bad optpath)", '', '');
            scalar @paths == 1
                or return ("Invalid arguments (wrong number of filenames)",
                           '', '');
            $paths[0] =~ /^optpath::(.*)$/s;
            my $fn = aipath2ospath($1);
            open my $fh, ">$text_layers", $fn or
                return ("Could not open 'fn' for writing: $!", '', '');
            s/^optstring:// for @strings;
            s{(\\.|_| )}{$1 eq '_' ? ' ' :
                         $1 eq ' ' ? "\n" :
                         substr $1, 1, 1}ge for @strings;
            if ($cmd eq 'intcmd:testruncount') {
                @strings = ($config_hashes{'sys:always_rebuild'});
            }
            print $fh "$_\n" or do {
                close $fh; return ("Could not write '$fn': $!", '', '');
            } for @strings;
            close $fh or return ("Could not flush '$fn': $!", '', '');
            return (undef, '', '');
        } elsif ($cmd eq 'intcmd:testcase') {
            progress_report 0, "intcmd:testcase argument: $_" for @opts;
            $opts[0] and $opts[0] =~ /failed/ and
                return ('Testcase failure', '', (join ' ', @opts));
            return (undef, '', (join ' ', @opts));
        } elsif ($cmd eq 'intcmd:assert_equal') {
            # If we have two identical arguments, they collapse to one
            # argument.
            scalar @opts == 1 and return(undef, '', '');
            scalar @opts == 2 or return ("Wrong number of arguments", '', '');
            return ("'opts[0]' does not equal '$opts[1]'", '', '');
        } elsif ($cmd eq 'intcmd:optionvalues') {
            my $stderr = '';
            my @stdout = ();
            my $failreason = undef;
            for my $o (@opts) {
                if ($o !~ /^optstring:(.*)$/s &&
                    $o !~ /^optpath::config_option:(.*)$/) {
                    $failreason = "Invalid arguments";
                    $stderr .= "'$o' is the wrong sort of object";
                } elsif (defined $config->{options}->{$1}) {
                    my $k = $1;
                    my $o = $config->{options}->{$k};
                    $o =~ /^[bs]?path:/ and $o =
                        ($singledir ? File::Spec->curdir : aipath2ospath($o));
                    push @stdout, "$k=$o";
                } else {
                    $failreason = "Missing config options";
                    $stderr .= "'$1' is not a config option";
                }
            }
            # TODO: Because we're outputting OS paths, we need to use in-band
            # newlines to signal that fact. Of course, this fails for dirnames
            # with newlines in.
            return ($failreason, (join "\n", @stdout), $stderr);
        } elsif ($cmd eq 'intcmd:xuse_statistics') {
            my @stdout = [];
            my @flxuse = grep /^b?path:/, @xuse;
            if (scalar @opts) {
                my %filtered_flxuse = ();
                for my $filter (@opts) {
                    if ($filter =~ /^optstring:(.*)$/) {
                        my $match = $1;
                        /\Q$match\E$/ and $filtered_flxuse{$_} = 1
                            for @flxuse;
                    }
                }
                @flxuse = sort keys %filtered_flxuse;
            } else {
                @flxuse = sort @flxuse;
            }
            push @stdout, 'hash=' . md5_hex(join ':'. @flxuse);
            my @namehints = grep /^namehint:/, @xuse;
            @namehints and @flxuse = sort @namehints;
            my $stem = 'anonymous';
            if (@flxuse) {
                $stem = $flxuse[0];
                $stem =~ s/^[^:]+://;
                for my $flxuse (@flxuse) {
                    "${stem}::$flxuse" =~ /^(.*).*?::[^:]+:\1/;
                    $stem = $1;
                }
            }
            $stem =~ s/\/$//;
            # It's common to use "src" as an intermediate folder name, but we
            # don't want to go around creating libraries src.so.
            $stem =~ s/\/src$//;
            push @stdout, "stem=bpath:$stem";
            push @stdout, "dependency=$_" for @xuse;
            return (undef, \@stdout, '');
        } elsif ($cmd eq 'intcmd:listtree') {
            my %results = ();
            my $starttime = time;
            my $lastdir = '';
            my $depth = undef;
            my %dirs = ();
            my $fnfilter = undef;
            /^optpath::([bs]?path:.*)$/s and $dirs{$1} = 1 for @opts;
            /^optpath::searchfile:(.*)$/s and $fnfilter = $1 for @opts;
            /^optstring:(\d+)/s and $depth = $1 for @opts;
            keys %dirs or return ("No directory specified", '', '');
            for my $dir (keys %dirs) {
                my $osdir = aipath2ospath($dir);
                my $aidir = cleanup_aipath($dir);
                -d $osdir or return ("'$osdir' is not a directory", '', '');
                my $in_spath = $aidir =~ /^spath:/;
                !$listtree_cache{$dir} and finddepth({
                    no_chdir => 1,
                    wanted => sub {
                        my $aifile = ospath2aipath($File::Find::name);
                        !-d $File::Find::name and
                            $listtree_cache{$dir}{$aifile} = 1;
                        # This can be a quick operation. It can also be very
                        # slow. If it's taken more than between 1 and 2
                        # seconds, start showing a progress bar.
                        if (time > $starttime + 1 && $lastdir
                            ne $File::Find::dir) {
                            $lastdir = $File::Find::dir;
                            progress_report($opt_verbose + 0.5,
                                            "Looking in $lastdir");
                        }
                    },
                    # We need to skip things like VCS directories. We don't
                    # bother checking for them in the spath in order to speed
                    # things up, because they're unlikely to be there.
                    preprocess => sub {
                        ospath2aipath($File::Find::dir) =~ /^bpath:/ and
                            $aidir !~ /^bpath:/ and return;
                        ospath2aipath($File::Find::dir) =~ /^\Q$aidir\E(.*)$/s
                            or die "'$File::Find::dir' escaped from '$osdir' ('"
                            . ospath2aipath($File::Find::dir) . "', '$aidir')";
                        # y=/=/= counts slashes, but only on a read-write
                        # scalar.
                        my $diff = $1;
                        return if defined $depth && $diff =~ y=/=/= > $depth;
                        return @_ if $in_spath;
                        return grep {
                            $_ !~ $config->{options}->{ignore_directories}
                                and do {
                                    my $ok = 1;
                                    -e File::Spec->catfile($File::Find::dir, $_)
                                        and $ok = 0
                                        for @{$config->{options}->
                                              {ignore_directories_with_files}};
                                    $ok;
                                }
                        } @_;
                    }
                }, $osdir);
                for my $aifile (keys %{$listtree_cache{$dir}}) {
                    !defined $fnfilter ||
                        $aifile =~ m{^[bs]?path:(?:[^\\]|\\.)+/
                            \Q$fnfilter\E$}xs
                            and $results{$aifile} = 1;
                }
            }
            return (undef, [sort keys %results], '');
        } elsif ($cmd eq 'intcmd:symlink') {
            return ('TODO: intcmd:symlink unimplemented', '', '');
        }
        return ("No such internal command $cmd", '', '');
    } elsif ($cmd =~ /^bpath:/) {
        # When actually running the command, always use an absolute path.
        # When telling the user what we did, a relative path would be OK, but
        # we avoid that anyway (basically because of confusion over the value
        # of cwd, and partly because it wouldn't help for, say, /usr/bin/gcc,
        # which is not inside the cwd).
        $cmd = aipath2ospath($cmd);
    } elsif ($cmd =~ /^cmd:(.*)$/s) {
        my $cmd_name = $1;
        $cmd = locate_command($1);
        defined $cmd or return ("No such command '$cmd_name'", '', '');
        $cmd = aipath2ospath($cmd);
    }

    # Convert options into a string representation.
    my $oldcwd_aipath = $cwd;
    $intopts{'cwd'} and $cwd = $intopts{'cwd'};
    my $rel = $intopts{'relpaths'} ? $cwd : undef;
    @opts = map {
        /^optstring: ?(.*)$/s ? split / /, $1 :
        do {
            my (undef, $objvalue, $objinner) = parse_objname $_;
            $objinner = resolve_extend $objinner;
            my $ospath = $objinner =~ /^searchlib:(.*)$/s ? $1 :
                $objinner =~ /^config_option:/ ? $objinner :
                $objinner =~ /^symbolset:[^:]+:(.*)$/s ?
                aipath2ospath($1, $rel) : aipath2ospath($objinner, $rel);
            $objvalue =~ /^(.*) $/s ? ($1, $ospath) : "$objvalue$ospath";
        }
    } @opts;

    # If we're asked for the command line, just return it now. This doesn't
    # actually follow any quoting rules in existence, but it's pretty close to
    # what Windows uses and will be familiar on Unix too. (Less ambiguous
    # escaping would be less readable, especially because, say, Windows uses
    # backslash as a path separator.)
    my $cmdline = "$cmd " . join ' ', map {/ / ? "\"$_\"" : $_} @opts;
    $intopts{'cmdline'} and do {$cwd = $oldcwd_aipath; return $cmdline;};

    # Change directory if necessary.
    my $oldcwd_ospath = cwd;
    unless (chdir aipath2ospath($cwd)) {
        $cwd = $oldcwd_aipath;
        return ("Could not change directory to '" .
                aipath2ospath($intopts{cwd}, 'bpath:') .
                "': $!", undef, undef);
    }
    progress_report 2, "Running $cmdline (wd: '" .
        aipath2ospath($cwd, 'bpath:') . "')";

    # If we get information in the wrong encoding, treat that like a compile
    # error.
    local $PerlIO::encoding::fallback = FB_CROAK; # report errors with die()

    local $ENV{LC_ALL} = defined_or($intopts{locale},
        defined_or($ENV{LC_ALL}, defined_or($ENV{LANG}, 'C')));
    my $layers = $text_layers;
    $ENV{LC_ALL} eq 'C' and
        $layers = $ascii_layers; # locale 'C' probably implies ASCII

    # We capture stdout and stderr via redirecting files, which is the most
    # portable possible method.
    open my $save_stdout, ">&", \*STDOUT or die "Could not save stdout: $!";
    my $tmp_stdout = tempfile() or die "Could not create temp file: $!";
    binmode $tmp_stdout, $layers;
    open STDOUT, ">&", $tmp_stdout or die "Could not capture stdout: $!";
    my ($save_stderr, $tmp_stderr);
    unless ($intopts{nostderr}) {
        open $save_stderr, ">&", \*STDERR or die "Could not save stderr: $!";
        $tmp_stderr = tempfile() or die "Could not create temp file: $!";
        binmode $tmp_stderr, $layers;
        open STDERR, ">&", $tmp_stderr or die "Could not capture stderr: $!";
    }
    # Repeating $cmd like this forces shells to never be involved. This works
    # better than trying to allow for the escaping rules of every shell in
    # existence.
    my $sysreturn = system { $cmd } $cmd, @opts;
    my $err = $!;
    open STDOUT, ">&", $save_stdout or die "Could not restore stdout: $!";
    close $save_stdout;
    seek $tmp_stdout, 0, 0;
    unless ($intopts{nostderr}) {
        open STDERR, ">&", $save_stderr or die "Could not restore stderr: $!";
        close $save_stderr;
        seek $tmp_stderr, 0, 0;
    }

    # Slurp up the stdout/stderr from the temp files.
    my $failreason = undef;
    my ($stdout, $stderr);
    eval {
        $! = 0;
        {
            local $/;
            $stdout = <$tmp_stdout>;
            $stderr = <$tmp_stderr> unless $intopts{nostderr};
        }
        close $tmp_stdout;
        close $tmp_stderr unless $intopts{nostderr};
        1;
    } or do {
        $@ =~ /^(.*) does not map to Unicode/s;
        $failreason = "Invalid character found in command output: $1";
        close $tmp_stdout;
        close $tmp_stderr;
    };

    # Restore the changed directory.
    $cwd = $oldcwd_aipath;
    chdir $oldcwd_ospath or die
        "Could not change back to the correct directory: $!";

    # Report the results.
    if ($sysreturn == -1) {$failreason = "Could not execute command: $err";}
    elsif ($sysreturn >> 8 != 0) {
        $failreason = "Command reported failure status " .
            ($sysreturn >> 8);
    } elsif ($sysreturn != 0) {
        signal_name($sysreturn & 127) eq 'SIGINT' and
            die "Interrupted."; # make control-C work as expected
        $failreason = "Command crashed with signal " .
            signal_name($sysreturn & 127);
    }
    progress_report 2, (defined_or($failreason, "Command succeeded").".");
    return ($failreason, $stdout, $stderr);
}

##### Statefile handling
#
# We have a statefile on disk (bpath:aimake.objects), and a mirror of it in
# memory ($state). The statefile itself is protected via critical sections;
# all writing of the state file goes via atomically{}. This both leaves us in
# a sane state upon crash or signal, and makes it easier to implement parallel
# building in the future.
{
    my $state_backup = {};
    my $write_on_crash = undef;
    my $last_clone_time = 0;
    sub atomically (&) {
        # The basic algorithm on a single-process system is to back up the
        # state in $state_backup, record the backup as the currently correct
        # version of the state, run the code block given, then record the
        # state as being currently correct. We only record one snapshot
        # (even to memory) every 10 seconds, in order to save on time spent
        # in dclone() (which otherwise accounts for 1/3 of all time spent
        # in the program; this means that only 10 seconds of progress will
        # be lost in a crash.
        if (time > $last_clone_time + 10) {
            $state_backup = dclone $state;
            $last_clone_time = time;
        }
        $write_on_crash = \$state_backup;
        $_[0]->();
        $write_on_crash = \$state;
    }

    # Writes out the last consistent statefile (on error or exit).
    sub write_statefile {
        # We want to avoid dying to a signal while the statefile is being
        # written, so turn off signals temporarily. The FD is already held
        # open, so we write to the file, truncate it, and rewind it. On some
        # OSes, we can't turn off signals, so that's guarded via an eval.
        #
        # The truncate isn't completely critical; Storable will happily stop
        # reading early. So on systems without a working truncate, we don't
        # die, we just end up with a file that can't shrink. The rewind is
        # only important if the program doesn't immediately exit, so it's
        # outside the signals-disabled section.
        defined $write_on_crash or return;

        my ($allsigs, $oldsigs);

        eval {
            $allsigs = POSIX::SigSet->new;
            $allsigs->fillset;
            $oldsigs = POSIX::SigSet->new;
            sigprocmask(SIG_SETMASK, $allsigs, $oldsigs);
        };
        store_fd($$write_on_crash, $state_fh);
        eval { truncate $state_fh, tell $state_fh; };
        defined $oldsigs and eval {
            sigprocmask(SIG_SETMASK, $oldsigs);
        };
        seek $state_fh, 0, SEEK_SET;
    }
}

# Like atomically, but for reads.
sub atomic_read(&) {
    $_[0]->();
}

# Set up our crash handlers.
# A crash handler.
$SIG{__DIE__} = sub {
    die @_ if $^S;
    write_statefile;
    confess @_;
};
use sigtrap qw/die normal-signals/; # convert SIGINT etc. into die()

# Initializes the statefile at the start of the program.
# It doesn't make sense to atomically{} here, because the statefile doesn't
# exist in memory before the call its used.
#
# This also locks the statefile, to prevent two copies of aimake running
# simultaneously on the same build directory (which wouldn't work and which
# would likely be a mistake anyway).
sub read_statefile {
    $state = {};
    my $statefn = aipath2ospath(statefilename);

    # We want to open an already-existing file, or not clobber an already
    # existing file; this way, if two new builds are started simultaneously in
    # the same directory, we don't get one clobbering the other's state
    # (because one of the processes will fail the lock before it tries to do
    # any reading or writing).
    sysopen $state_fh, $statefn, O_RDWR | O_CREAT;
    binmode $state_fh, $binary_layers;
    flock $state_fh, (LOCK_EX | LOCK_NB)
        or die "Cannot lock statefile '$statefn': is aimake already running?";

    # This could theoretically go wrong if someone renames the state file
    # beneath us, but at that point, we can't really expect sane behaviour
    # anyway :)
    if (-z $statefn) {
        $state = {};
        store_fd($state, $state_fh) or die "Error writing statefile: $!";
    } else {
        $! = 0;
        # retrieve_fd can die; it can also merely set $! and return undef
        $state = fd_retrieve($state_fh);
        defined $state or die "Error reading statefile: $!";
    }

    seek $state_fh, 0, SEEK_SET; # rewind the file
}
END {
    defined $state_fh and flock $state_fh, LOCK_UN;
    defined $state_fh and close $state_fh;
}

##### Rule logic

sub rule_applies_to_object {
    my $rulename = shift;
    my $objname = shift;
    my $objpattern = $config->{rules}->{$rulename}->{object};
    defined $objpattern or return $objname eq 'sys:no_object';
    (ref $objpattern) =~ /\bRegexp$/ and return $objname =~ $objpattern;
    return $objname eq $objpattern;
}

sub rules_that_apply_to {
    my $objname = shift;
    my @rv = ();
    for my $rulename (keys %{$config->{rules}}) {
        rule_applies_to_object $rulename, $objname or next;
        push @rv, $rulename;
    }
    return @rv;
}
memoize('rules_that_apply_to');

sub objects_for_rule {
    my $rulename = shift;
    my @rv = ();
    my $objpattern = $config->{rules}->{$rulename}->{object};
    my $objvalue = 'sys:no_object';
    defined $objpattern and (ref $objpattern) !~ /\bRegexp$/
        and $objvalue = $objpattern;
    for my $object (keys %{$state->{hash_by_object}}, $objvalue) {
        rule_applies_to_object $rulename, $object or next;
        push @rv, $object;
    }
    return @rv;
}

##### Object logic
#
# This does most of the actual work of aimake.
#
# We use the following state to store information about rules, pairs, and
# objects:
#
# Each pair knows which objects are unsure via it; each object knows how many
# pairs have it as unsure (->{unsure_by_pair}, ->{unsure_count_by_object})
#
# Each pair knows which objects it proviced last time it ran (and with which
# hashes); each object knows which pairs proviced it (->{hash_by_pair}, etc.)
#
# Each pair knows what errors or warnings it output last time it ran; that's
# in ->{errwarn_by_pair}. Warnings have 'W:' at the start; errors have 'E:'.
#
# Each pair knows the objects in its expanded use dependencies, and vice versa
# (->{xuse_by_pair} (an array, not a hash), ->{xuse_by_object}). If the pair
# is changed or blocked, then xuse_by_pair can be undef; in such a case,
# xuse_by_object doesn't contain that pair. The innermost keys of
# xuse_by_object list the objects originally responsible for including that
# xuse; this gives better error messages. There is also a hash
# ->{xuse_prevpair} that, for each pair and each object in its expanded use
# dependencies, specifies the object that created that object (if any); this
# is only meaningful when xuse_by_pair is not undef, and is used by unsureness
# checks to determine whether an unsure object would have an effect on a pair
# or not.
#
# There is a list of changed pairs, ->{changed_pairs}. The values of that hash
# list the reason the pair has not been marked as unchanged yet.
#
# A pair can be blocked, meaning that it has a nonexistent object in its
# command (that isn't its object): this gives (->{blocked_by_object},
# ->{blocked_by_pair}). If a rule would be marked as changed, it can be marked
# as blocked instead, and becomes marked as changed only when the object
# blocking it comes into existence. ->{blocked_by_pair}->{$pair} is a scalar.
#
# Out of these various interesting statefile elements, some are read-only
# (i.e. you can change the value, but not change /within/ the value), and
# others cannot be shared. The read-only elements are hashes (i.e. $state
# ->{hash_by_$x}->{$y}->{$z}, and xuse_by_pair lists; everything else cannot
# share.

### Mutators
# In order to prevent things getting out of sync, we use mutators for all
# this. The mutators have to be contained in an appropriate atomically{}
# themselves; we don't add one because the atomicity often needs to expand
# to more than a single access.
#
# The mutators also call each other when necessary; e.g. marking a pair as
# changed will mark all objects it proviced on its last run as unsure.

my %sure_pair_cache;
my %unsure_pair_cache;

sub mark_object_unsure {
    my $pair = shift;
    my $obj = shift;
    progress_report 4, "Want to mark $obj as unsure via $pair...";
    $state->{unsure_by_pair}->{$pair}->{$obj} and return;
    progress_report 4, "Marking $obj as unsure via $pair.";
    $state->{unsure_by_pair}->{$pair}->{$obj} = 1;
    $state->{unsure_count_by_object}->{$obj} ||= 0;
    $state->{unsure_count_by_object}->{$obj}++;
    %sure_pair_cache = ();
}
sub object_exists;
sub parse_objname;
sub mark_object_sure {
    my $pair = shift;
    my $obj = shift;
    my ($objtype, undef) = parse_objname $obj;
    progress_report 4, "Want to mark $obj as sure via $pair...";
    unless ($state->{unsure_by_pair}->{$pair}->{$obj}) {
        delete $state->{unsure_by_pair}->{$pair} # undo autovivification
            unless keys %{$state->{unsure_by_pair}->{$pair}};
        return;
    }
    progress_report 4, "Marking $obj as sure via $pair.";
    delete $state->{unsure_by_pair}->{$pair}->{$obj};
    delete $state->{unsure_by_pair}->{$pair}
        unless keys %{$state->{unsure_by_pair}->{$pair}};
    $state->{unsure_count_by_object}->{$obj}--;
    delete $state->{unsure_count_by_object}->{$obj}
        unless $state->{unsure_count_by_object}->{$obj};

    # If the object is one we maintain on the filesystem, and it's marked as
    # sure and nonexistent (e.g. if it was previously output, but the pair
    # that previously output it stopped generating it), delete it. (Nothing
    # would go wrong with the object sitting around on the filesystem, but
    # it's a bit crufty to leave old object files around like that.)
    #
    # This also makes it possible to implement a "clean" mode via adding a
    # nonexistent object (like sys:clean) as a dependency of every pair.
    if ($objtype eq 'bpath' && !object_exists($obj)) {
        my $fn = aipath2ospath($obj);
        if (-e $fn && -f _) {
            progress_report 1, "Deleting no longer generated file '$fn'";
            unlink $fn or
                progress_report -1, "Could not delete old file '$fn': $!";
        }
    }

    %unsure_pair_cache = ();
}
sub mark_pair_xuse_unknown;
sub mark_pair_changed {
    my $pair = shift;
    my ($rulename, $objname) = parse_pairname $pair;
    progress_report 4, "Want to mark $pair as changed...";
    return if $state->{changed_pairs}->{$pair};
    return if $state->{blocked_by_pair}->{$pair};
    progress_report 4, "Marking $pair as changed.";

    # Special case: If a pair currently has no outputs and at least one
    # nonexistent, sure xuse, there's no need to mark it as changed now
    # because it'll be marked as changed when that xuse starts existing. This
    # optimization is only safe when we actually know the xuse; otherwise, we
    # can end up with a pair with unknown xuse but not marked as changed,
    # which violates our invariants. This optimization is also unsafe if the
    # pair has a rule that doesn't apply to the object, or if the object does
    # not exist.
    if (!$state->{hash_by_pair}->{$pair} && object_exists($objname) &&
        defined $state->{xuse_by_pair}->{$pair} &&
        rule_applies_to_object $rulename, $objname) {
        $state->{unsure_count_by_object}->{$_} or object_exists($_)
            or return for @{$state->{xuse_by_pair}->{$pair}};
    }

    # Another special case: if the pair currently has no outputs and a missing
    # object in its command, we can mark it as blocked rather than changed
    # (which is a lot more efficient, because the main loop doesn't need to
    # calculate its xuse in order to know whether to run it or not. If we
    # already know the xuse, this is pointless, as we'll already have left
    # if it matters. Again, we require the object itself to exist and the rule
    # to match the object.
    elsif (!$state->{hash_by_pair}->{$pair} && object_exists($objname) &&
           rule_applies_to_object $rulename, $objname) {
        my $cmd = $config->{rules}->{$rulename}->{command};
        if ($cmd) {
            my @cmd = ($cmd);
            ref $cmd eq 'ARRAY' and @cmd = @$cmd;
            complete_objname \$_, $objname for @cmd;
            $_ = resolve_extend $_ for @cmd;
            for my $blocker (@cmd) {
                if (!$state->{unsure_count_by_object}->{$blocker} &&
                    !object_exists($blocker)) {
                    $state->{blocked_by_object}->{$blocker}->{$pair} = 1;
                    $state->{blocked_by_pair}->{$pair} = $blocker;
                    return;
                }
            }
        }
    }

    $state->{changed_pairs}->{$pair} = 'has not been checked yet';
    for my $obj (keys %{$state->{hash_by_pair}->{$pair}}) {
        mark_object_unsure $pair, $obj;
    }
    delete $state->{hash_by_pair}->{$pair}
        unless keys %{$state->{hash_by_pair}->{$pair}};
}
sub mark_pair_unchanged {
    my $pair = shift;
    progress_report 4, "Marking $pair as unchanged.";
    delete $state->{changed_pairs}->{$pair};
    if (exists $state->{blocked_by_pair}->{$pair}) {
        my $blocker = $state->{blocked_by_pair}->{$pair};
        delete $state->{blocked_by_object}->{$blocker}->{$pair};
        delete $state->{blocked_by_object}->{$blocker}
            unless keys %{$state->{blocked_by_object}->{$blocker}};
        delete $state->{blocked_by_pair}->{$pair};
    }
}
sub inappropriate_prevpair;
sub set_proviced_hash {
    my $pair = shift;
    my $obj = shift;
    my $hash = shift; # can be undef if the rule no longer provices the object
    my ($objtype, $objvalue) = parse_objname $obj;

    progress_report 4, "Want to set hash of $obj via $pair...";

    # We're now sure of what happens when the rule is run. However, we can't
    # call mark_object_sure until the hash is correct; mark_object_sure will
    # attempt to delete a bpath object that nothing claims to generate, and
    # that would happen for a new object because we haven't set its hash yet.

    # There's no need to change anything but the sureness flag if the hash
    # didn't change.
    my $oldhash = $state->{hash_by_pair}->{$pair}->{$obj};
    delete $state->{hash_by_pair}->{$pair}
        unless keys %{$state->{hash_by_pair}->{$pair}};
    if (!defined $hash && !defined $oldhash) {
        mark_object_sure $pair, $obj;
        return;
    }
    progress_report 4, "oldhash $oldhash hash $hash"
        unless ref $oldhash || ref $hash ||
        !defined $oldhash || !defined $hash;
    if (deepequals($hash, $oldhash)) {
        mark_object_sure $pair, $obj;
        return;
    }

    progress_report 4, "Setting hash of $obj via $pair.";

    # Set hash_by_pair, hash_by_object.
    if (defined $hash) {
        $state->{hash_by_pair}->{$pair}->{$obj} = $hash;
        $state->{hash_by_object}->{$obj}->{$pair} = $hash;
    } else {
        delete $state->{hash_by_pair}->{$pair}->{$obj};
        delete $state->{hash_by_pair}->{$pair}
            unless keys %{$state->{hash_by_pair}->{$pair}};
        delete $state->{hash_by_object}->{$obj}->{$pair};
        delete $state->{hash_by_object}->{$obj}
            unless keys %{$state->{hash_by_object}->{$obj}};
    }

    mark_object_sure $pair, $obj;

    # If the object blocks any pairs, unblock them and mark them as changed
    # again.
    for my $cpair (keys %{$state->{blocked_by_object}->{$obj}}) {
        mark_pair_unchanged $cpair; # remove the blocker
        mark_pair_xuse_unknown $cpair if $objtype_provided{$objtype};
        mark_pair_changed $cpair;
    }

    # Changing the object changes pairs that depend on it. If it's a provided
    # object, it can also change the expanded use dependencies of pairs that
    # depend on it (although not with respect to that object, only with
    # respect to other objects). This must be done after hash_by_object is
    # set, so that mark_pair_changed won't defer the changed setting until
    # this object comes into existence (falsely believing it not to exist).
    # However, we can (and should, for efficiency reasons) skip any pairs that
    # cannot possibly look at the object via $pair.
    #
    # Iterating over xuse-by_object may miss out some pairs, but only changed
    # pairs with unknown xuses (on which operating would be pointless anyway).
    for my $cpair (keys %{$state->{xuse_by_object}->{$obj}}) {
        next if inappropriate_prevpair $cpair, $pair;

        # We need to mark the xuse unknown before marking the pair as changed,
        # in case the old xuse had a dependency on a nonexistent object (which
        # could cause mark_pair_changed to be a no-op) but the new xuse only
        # contains existing objects. (If the pair is not already changed, then
        # mark_pair_changed will recalculate the xuse and mark the xuse as
        # known again.)
        mark_pair_xuse_unknown $cpair if $objtype_provided{$objtype};
        mark_pair_changed $cpair;
    }

    # If an object comes into existence, we need to add pairs and recalculate
    # those.
    if (!defined $oldhash) {
        my @rules = rules_that_apply_to $obj;
        for my $rule (@rules) {
            my $cpair = "$rule $obj";
            mark_pair_xuse_unknown $cpair;
            mark_pair_changed $cpair;
        }
    }

    # If a rule changes, we need to add pairs for objects it now applies to
    # (and used not to), and recalculate all pairs containing it (the command
    # may have changed, meaning that the xuses are different). Marking the
    # rules as changed will be a no-op in most cases, but it will matter if
    # the pair is brand new.
    #
    # Additionally, if a dependency rule changes, we need to recalculate
    # xuses of anything that depended on its object.
    if ($objtype eq 'config_rule') {
        progress_report 4, "Adding pairs from rule $objvalue";
        my @objects = objects_for_rule $objvalue;
        my $r = $config->{rules}->{$objvalue};
        for my $o (@objects) {
            my $cpair = "$objvalue $o";
            mark_pair_xuse_unknown $cpair;
            mark_pair_unchanged $cpair; # unblock it
            mark_pair_changed $cpair;
            if (defined $r && exists $r->{depends}) {
                for my $dpair (keys %{$state->{xuse_by_object}->{$o}}) {
                    mark_pair_xuse_unknown $dpair;
                    mark_pair_changed $dpair; # needed to allow an undef xuse
                }
            }
        }
    }

    # Remove any autovivified xuses, if the object isn't used at all.
    delete $state->{xuse_by_object}->{$obj}
        unless keys %{$state->{xuse_by_object}->{$obj}};
    delete $state->{blocked_by_object}->{$obj}
        unless keys %{$state->{blocked_by_object}->{$obj}};
}
# Marks a pair as sure, and sets all its outputs. Called after a pair is run
# successfully. Also set the pair's warning messages (if any).
sub record_pair_outputs {
    my $pair = shift;
    my %obj_to_hash = %{+shift};
    my $warnings = shift;

    progress_report 4, "Setting hashes for successful run of $pair.";

    for my $oldobj (keys %{$state->{hash_by_pair}->{$pair}}) {
        # Force the keys to exist for any object that was there before.
        $obj_to_hash{$oldobj} = defined_or($obj_to_hash{$oldobj}, undef);
    }
    if (defined $state->{unsure_by_pair}->{$pair}) {
        for my $oldobj (keys %{$state->{unsure_by_pair}->{$pair}}) {
            # Force the keys to exist for any object's unsure via the pair, even
            # if it isn't being output (this can happen when there was previously
            # a dependency loop).
            $obj_to_hash{$oldobj} = defined_or($obj_to_hash{$oldobj}, undef);
        }
    }
    set_proviced_hash $pair, $_, $obj_to_hash{$_}
        for keys %obj_to_hash;
    mark_pair_unchanged $pair;
    if (defined $warnings && $warnings ne '') {
        $state->{errwarn_by_pair}->{$pair} = "W:$warnings";
    } else {
        delete $state->{errwarn_by_pair}->{$pair};
    }
    delete $state->{hash_by_pair}->{$pair}
        unless keys %{$state->{hash_by_pair}->{$pair}};
}
# Called when a pair errors out. Marks all its old outputs as unsure, but the
# rule itself as unchanged (thus forcing all those outputs' indirect
# descendants into limbo).
sub record_pair_error {
    my $pair = shift;
    my $errmsg = shift;

    progress_report 4, "Setting hashes for unsuccessful run of $pair...";

    mark_pair_unchanged $pair;
    for my $obj (keys %{$state->{hash_by_pair}->{$pair}}) {
        mark_object_unsure $pair, $obj;
    }
    delete $state->{hash_by_pair}->{$pair}
        unless keys %{$state->{hash_by_pair}->{$pair}};

    !defined $errmsg || $errmsg eq '' and
        croak "record_pair_error needs an error message";
    $state->{errwarn_by_pair}->{$pair} = "E:$errmsg";
}

### Resolving object contents
#
# Sometimes we'll have multiple possible versions of a provided object (this
# happens most often with symbol:main, but can happen for other provided
# objects, too). For produced objects, this is an error (they'd overwrite each
# other on the filesystem), but for provided objects, we work out which to use
# based on filename similarity. This takes two object names as arguments (the
# provided object, and the object that wants to use it), and returns the
# appropriate pair to use.
sub appropriate_pair_for_object {
    my $provided = shift;
    my $user = shift;
    my $ties_ok = shift;

    return unless $state->{hash_by_object}->{$provided};
    my @providers = sort keys %{$state->{hash_by_object}->{$provided}};

    scalar @providers == 1 and return $providers[0];

    $provided =~ multiple_providers_ok_regex and return $providers[0];

    my ($prvtype, undef) = parse_objname $provided;
    # It's OK for multiple rules to find objects on the path or spath.
    $prvtype eq 'spath' and return $providers[0];
    $prvtype eq 'path' and return $providers[0];
    # It's OK to have multiple providers for a searchfile/lib, symbolset, or
    # shared_symbol.
    $prvtype eq 'searchfile' and return $providers[0];
    $prvtype eq 'searchlib' and return $providers[0];
    $prvtype eq 'symbolset' and return $providers[0];
    $prvtype eq 'shared_symbol' and return $providers[0];

    $objtype_provided{$prvtype} or
        croak "Object $provided is produced by multiple rules: @providers";

    progress_report 4, "Finding appropriate pair for $provided (user $user)...";

    my $best = undef;
    my $bestscore = -1;
    my @tie;
    # We error out if we have two equally good providers.
    for my $provider (@providers) {
        my ($prule, $obj) = parse_pairname $provider;
        my ($objtype, $objvalue, $objinner) = parse_objname $obj;
        my $score = 0;
        if ($objtype eq 'spath') {
            # Avoid if possible. It's better than an entirely virtual
            # provider, though.
            $score = 1;
            my @aipath = parse_aipath $obj;
            # We add some bonuses based on the name. In particular, we prefer
            # to use libraries following the lib... naming convention, to
            # avoid linking against the dynamic loader explicitly for free()
            # or something silly like that, and libc is the best option when
            # available.
            $aipath[-1] =~ /^lib/ and $score += 0.1;
            $aipath[-1] =~ /^libc\b/ and $score += 0.4;
            $aipath[-1] =~ /^libmingw\b/ and $score += 0.4;
        } elsif ($objtype =~ /^b?path/s) {
            # The score depends on how many characters match at the
            # start of the objvalue.
            my ($utype, $uvalue, $uinner) = parse_objname $user;
            $score = 2;
            while ($uvalue ne '' && $objvalue ne '' &&
                   substr($uvalue, 0, 1, '') eq substr($objvalue, 0, 1, '')) {
                $score++;
            }
        }
        # Add a small bonus based on the rule that produced the object.
        if (defined $config->{rules}->{$prule}) {
            $score += defined_or($config->{rules}->{$prule}->{preference}, 0)
                / 100000;
        }

        # A tie is benign if we have two rules with the same object, and it
        # isn't sys:no_object. Otherwise, it's a problem.
        if ($score == $bestscore && (parse_pairname $best)[1] ne $obj) {
            push @tie, $provider;
        } elsif ($score > $bestscore) {
            @tie = ();
            ($best, $bestscore) = ($provider, $score);
        }
        progress_report 4, "Score for $provider is $score";
    }
    if (@tie) {
        unshift @tie, $best;
        $ties_ok and !wantarray and return 'tie sys:tie';
        $ties_ok and return ('tie sys:tie', \@tie);
        croak "Multiple equally good pairs are available to build ".
        "$provided (user $user): [@tie]";
    }
    return $best;
}

# Determines which hash of an object we're supposed to be building from. This
# is used for produced bpath:,path:,spath: objects to determine whether the
# file has changed on disk. (For a produced object, it would give its
# outdepends, but this method should not be used for this purpose because it
# has tiebreak issues. Go via xuse_prevpair instead.)
sub xuse_hash {
    my $pair = shift;
    my $obj = shift;
    return $state->{hash_by_object}->{$obj}->{
        appropriate_pair_for_object $obj, $pair};
}

### Dependency calculations

# We want to avoid allowing an object to be created in terms of itself. Rules
# cannot use their own output as a dependency, nor any output from rules that
# are marked as avoided for it.
sub inappropriate_prevpair {
    my $pair = shift;
    my $pair2 = shift;
    my ($rule, $obj) = parse_pairname $pair;
    my ($rule2, $obj2) = parse_pairname $pair2;
    my $avoid_rules = $config->{rules}->{$rule}->{avoid_rules};
    $avoid_rules and $rule2 =~ $avoid_rules and
        progress_report 5, "($pair,$pair2) inappropriate: avoid_rules"
        and return 1;
    return unless $state->{hash_by_object}->{$obj};
    $state->{hash_by_object}->{$obj}->{$pair} and
        progress_report 5, "($pair,$pair2 inappropriate: output"
        and return 1;
    return;
}

# We calculate the xuse for a pair via looping over its command, adding in the
# following dependencies recursively:
#
# - The pair's object, if it's a provicion rule and if propagate_usedeps is
#   not set;
# - The pair's object but /not/ any of its xuses, otherwise;
# - The pair's command;
# - The pair's rule;
# - Any dependencies: object that could possibly refer to an object in the set
#   (this can be determined statically);
# - Any outdepends that were added by the pair that provided an object in the
#   set (this is the hash of a provided object);
# - sys:clean, if there's a nonexistent provided object in the set.
#   (Nonexistent produced objects should also cause a clean, but that happens
#   when the rule is run; it can't be set now because produced objects don't
#   affect expanded use dependencies. Meanwhile, the produced objects have to
#   be checked for changes on disk, and their nonexistence hashwise will be
#   noticed then, something that doesn't happen with provided objects.)
#
# In the case where there are multiple reasonable possible ancestors, we hold
# off on choosing an ancestor immediately, and then try again once the set of
# xuses is complete, preferring to choose one that's already in the set. We
# report a tie if there's still multiple ancestors with the same degree of
# reasonability. We also never choose any of the rule's outputs as an ancestor
# for the rule itself.
#
# We also preserve order in xuse_by_pair, because the order is sometimes
# sigificant. (xuse_by_object is unordered.)
sub recalculate_pair_xuse {
    my $pair = shift;
    my $ties_ok = shift;
    my ($rule, $obj) = parse_pairname($pair);
    progress_report 4, "Calculating xuse of $pair";
    reset_pair_xuse($pair);
    %sure_pair_cache = ();
    %unsure_pair_cache = ();
    my $r = $config->{rules}->{$rule};
    # Add the pair's rule to the list.
    my %xuse = ("config_rule:$rule" => $obj);
    my @xuse = ("config_rule:$rule");
    if (!$r) {
        # The rule's meant to specify the dependencies, but the rule isn't
        # there, so we specify the rule itself and sys:clean as the xuse.
        $xuse{'sys:clean'} or push @xuse, 'sys:clean';
        $xuse{'sys:clean'} = "config_rule:$rule";
    } else {
        # Add the pair's command to the list.
        my @command = (defined_or($r->{command}, 'intcmd:nop'));
        scalar @command == 1 && ref $command[0] eq 'ARRAY'
            and @command = (@{$command[0]});
        # Add the pair's object to the list.
        $r->{output} and !$r->{propagate_usedeps} and
            push @command, '';
        # For install rules, add sys:installing to the list.
        $r->{install_dir} and push @command, 'sys:installing';
        my %xuse_reason = ();
        my $pass = 1;
        my @postponed = ();
        my %pass1_xuse_pairs = ();
        while (@command || ($pass == 1 && @postponed)) {
            if (!@command) {
                @command = @postponed;
                $pass = 2;
            }
            # Convert the object name from a partially specified name into a
            # complete name.
            my $o = shift @command;
            complete_objname \$o, $obj;
            $o = resolve_extend $o;
            next if $xuse{$o};
            my ($otype, undef) = parse_objname $o;

            # Add provided outdepends to the list. (Or postpone it for later
            # if we have multiple reasonable possibilities and we're still on
            # the first pass.)
            if ($objtype_provided{$otype}) {
                my @ancestors = sort keys %{$state->{hash_by_object}->{$o}};
                delete $state->{hash_by_object}->{$o} unless
                    keys %{$state->{hash_by_object}->{$o}};
                @ancestors = grep !inappropriate_prevpair($pair, $_),
                    @ancestors;
                if ($pass == 2 || $o =~ multiple_providers_ok_regex) {
                    # It would be slightly more accurate to check the use
                    # dependencies of the pairs we add to see if they're
                    # already there. But this method is faster and easier to
                    # read, and will produce the same results in pretty much
                    # all cases.
                    @ancestors = grep $pass1_xuse_pairs{$_}, @ancestors;
                    if (scalar @ancestors != 1) {
                        my ($provider, $tie) =
                            appropriate_pair_for_object $o, $obj, $ties_ok;
                        if (!defined $provider) {
                            @ancestors = ();
                        } elsif ($provider ne 'tie sys:tie') {
                            @ancestors = grep
                                !inappropriate_prevpair($pair, $_), $provider;
                        } else {
                            @ancestors = grep $pass1_xuse_pairs{$_}, @$tie;
                            @ancestors = grep
                                !inappropriate_prevpair($pair, $_), @ancestors;
                            @ancestors or @ancestors = grep
                                !inappropriate_prevpair($pair, $_), @$tie;
                        }
                        if (!@ancestors) {
                            @ancestors = grep !inappropriate_prevpair($pair, $_),
                                sort keys %{$state->{hash_by_object}->{$o}};
                            delete $state->{hash_by_object}->{$o} unless
                                keys %{$state->{hash_by_object}->{$o}};
                        }
                    }
                }
                if (@ancestors > 1 && $pass == 1) {
                    push @postponed, $o;
                    next;
                } elsif (@ancestors > 1 && $pass == 2) {
                    mark_pair_xuse_unknown $pair;
                    return 0 unless wantarray;
                    return (0, $o, $obj, \@ancestors);
                } elsif (@ancestors == 1) {
                    $pass == 1 and $pass1_xuse_pairs{$ancestors[0]} = 1;
                    $state->{xuse_prevpair}->{$pair}->{$o} = $ancestors[0];
                    my @udeps = @{$state->{hash_by_pair}->{$ancestors[0]}->{$o}};
                    push @command, sort @udeps;
                    $xuse_reason{$_} = $o for @udeps;
                } else {
                    # Nothing provides the object; add sys:clean to the list.
                    $state->{xuse_prevpair}->{$pair}->{$o} =
                        'nonexistent sys:clean';
                    $xuse{'sys:clean'} or push @xuse, 'sys:clean';
                    $xuse{'sys:clean'} = $o; # nothing provides it
                }
            }
            # Add dependencies: objects to the list.
            # These are sorted for determinism.
            my @drules = rules_that_apply_to($o);
            @drules = grep $config->{rules}->{$_}->{depends}, sort @drules;
            push @command, map "dependencies:$_:$o", @drules;
            $xuse_reason{"dependencies:$_:$o"} = "config_rule:$_" for @drules;

            $xuse{$o} = defined_or($xuse_reason{$o}, $obj);
            push @xuse, $o;
        }
    }
    unless ($xuse{$obj}) {
        $xuse{$obj} = "config_rule:$rule";
        push @xuse, $obj;
    }
    $state->{xuse_by_pair}->{$pair} = \@xuse;
    for my $xuse (keys %xuse) {
        $state->{xuse_by_object}->{$xuse}->{$pair} = $xuse{$xuse};
    }
    return 1;
}

# Resets the xuse of a pair. This is called for two reasons: either because
# we're about to recalculate the xuse and want to remove any old xuses on it,
# or because the pair's being deleted for good (either because it's a
# combination of a rule and a nonexistent object, or because it's a
# combination of a nonexistent rule and anything, or because it's a
# combination of a rule and an object that doesn't fit that rule; the former
# case happens most often when a file is deleted from the source tree or a
# symbol is removed from the program altogether, and the latter case only
# happens if a rule is deleted from the config file, or changed to apply to a
# different set of objects). (Calling reset_pair_xuse in such cases deletes
# the pair altogether; it's not mentioned in hash because it doesn't provice
# anything, and it's not mentioned in unsure because it's known that it
# doesn't provice anything.)
sub reset_pair_xuse {
    my $pair = shift;

    progress_report 4, "Resetting xuse of $pair.";

    mark_pair_xuse_unknown $pair;
    delete $state->{xuse_by_pair}->{$pair};
    delete $state->{xuse_prevpair}->{$pair};
    %sure_pair_cache = ();
    %unsure_pair_cache = ();
}

sub mark_pair_xuse_unknown {
    my $pair = shift;
    if (defined $state->{xuse_by_pair}->{$pair}) {
        for my $obj (@{$state->{xuse_by_pair}->{$pair}}) {
            delete $state->{xuse_by_object}->{$obj}->{$pair};
            delete $state->{xuse_by_object}->{$obj}
                unless keys %{$state->{xuse_by_object}->{$obj}};
        }
    }
    $state->{xuse_by_pair}->{$pair} = undef;
    delete $state->{xuse_prevpair}->{$pair};
    %sure_pair_cache = ();
    %unsure_pair_cache = ();
}

sub ensure_pair_has_xuse {
    my $pair = shift;
    my $ties_ok = shift;
    if (!defined $state->{xuse_by_pair}->{$pair}) {
        return recalculate_pair_xuse $pair, $ties_ok;
    }
    return 1;
}

### Sureness calculations

sub pair_is_definitely_deletable {
    my ($prule, $pobj) = parse_pairname shift;
    rule_applies_to_object $prule, $pobj or return 1;
    object_exists "config_rule:$prule" or return 1;
    return;
}
memoize('pair_is_definitely_deletable');

# A pair is sure if all its xuses, recursing back forever, are sure. This goes
# via xuse_prevpair in most cases. As an exception, for searchfile, searchlib
# and symbolset objects (which have an outdepends depending only on their
# name), the pair is sure if any of its ancestors are sure.
my %pair_is_sure_seen = ();
sub pair_is_sure;
sub pair_is_sure {
    my $pair = shift;

    # Caches. Check these even before completing argument passing, because
    # this function is called a /lot/ and bailing out early is helpful.
    # (Thanks, profiler!)
    $sure_pair_cache{$pair} and return 1;
    $unsure_pair_cache{$pair} and return 0 unless wantarray;
    $unsure_pair_cache{$pair} and return (0, [@{$unsure_pair_cache{$pair}}]);

    my $recursion_ok = shift;
    if ($pair_is_sure_seen{$pair}) {
        $recursion_ok and return 0 unless wantarray;
        $recursion_ok and return (0, []);
        croak "Pair $pair seems to have been built in terms of itself";
    }

    # The pair is definitely deletable (i.e. we're sure what to do with it) if
    # the rule doesn't exist, or the rule doesn't apply to the object; both of
    # those cases cannot be resolved during the run.
    pair_is_definitely_deletable $pair and return 1;

    # Base case.
    $pair eq 'parse_configuration sys:no_object' and return 1;
    # Recursive case.
    unless (ensure_pair_has_xuse $pair, 1) {
        # If we have a tie, we're not sure how to resolve it.
        my $unsure_list = ['tie'];
        $unsure_pair_cache{$pair} = [@$unsure_list];
        delete $pair_is_sure_seen{$pair};
        progress_report 4, "pair_is_sure: $pair is unsure due to tie";
        return 0 unless wantarray;
        return (0, $unsure_list);
    }
    $pair_is_sure_seen{$pair} = 1; # avoid an infinite regress
    my @xuses = @{$state->{xuse_by_pair}->{$pair}};
    for my $xuse (@xuses) {
        # Parsing $xuse is actually pretty timeconsuming. We regex it instead
        # for efficiency, because we only care about the object type. (This
        # line is actually the inner loop of the program; it runs more often
        # than any other line anywhere in aimake. Thus, the need for extreme
        # efficiency.)
        if ($xuse !~ multiple_providers_ok_regex) {
            # Make sure that the object's prevpair is sure, and that the
            # object is sure via its prevpair.
            my $prevpair = $state->{xuse_prevpair}->{$pair}->{$xuse};
            if (!defined $prevpair) { # nonexistent or produced object
                next unless $state->{hash_by_object}->{$xuse};
                croak "No xuse_prevpair from $pair for an object $xuse " .
                    "with multiple prevpairs " . (join ', ',
                    keys %{$state->{hash_by_object}->{$xuse}})
                    unless keys %{$state->{hash_by_object}->{$xuse}} == 1;
                $prevpair = (keys %{$state->{hash_by_object}->{$xuse}})[0];
            }
            next if $prevpair eq 'nonexistent sys:clean';
            if ($state->{unsure_by_pair}->{$prevpair} &&
                $state->{unsure_by_pair}->{$prevpair}->{$xuse}) {
                exists $state->{changed_pairs}->{$pair} and
                    $state->{changed_pairs}->{$pair} = "xuse $xuse is unsure";
                my $unsure_list = [$xuse];
                $unsure_pair_cache{$pair} = [@$unsure_list];
                delete $pair_is_sure_seen{$pair};
                progress_report 4,
                    "pair_is_sure: $pair is unsure due to " .
                        "unsure $xuse via $prevpair";
                return 0 unless wantarray;
                return (0, $unsure_list);
            }
            # If the chosen prevpair is unsure, we're unsure.
            if ($state->{hash_by_object}->{$xuse}) {
                my ($sure, $unsure_list) =
                    pair_is_sure $prevpair, $recursion_ok;
                if (!$sure) {
                    exists $state->{changed_pairs}->{$pair} and
                        $state->{changed_pairs}->{$pair} =
                        "xuse ${xuse}'s pair $prevpair is unsure";
                    unshift @$unsure_list, $xuse, $prevpair;
                    $unsure_pair_cache{$pair} = [@$unsure_list];
                    delete $pair_is_sure_seen{$pair};
                    progress_report 4,
                        "pair_is_sure: $pair is unsure due to ".
                            "unsure $prevpair needed for $xuse";
                    return 0 unless wantarray;
                    return (0, $unsure_list);
                }
            }
        } elsif ($state->{hash_by_object}->{$xuse}) {
            my @providers = sort keys %{$state->{hash_by_object}->{$xuse}};
            my $some_sure = 0;
            # We check unsureness one provider at a time.
            for my $provider (@providers) {
                if ((pair_is_sure $provider, 1) &&
                    (!$state->{unsure_by_pair}->{$provider} ||
                     !$state->{unsure_by_pair}->{$provider}->{$xuse})) {
                    $some_sure = 1;
                    last;
                }
            }
            if (!$some_sure) {
                # TODO: Pick an arbitrary choice to demonstrate the loop.
                exists $state->{changed_pairs}->{$pair} and
                    $state->{changed_pairs}->{$pair} = "no sure ancestors";
                $unsure_pair_cache{$pair} = ['?'];
                delete $pair_is_sure_seen{$pair};
                progress_report 4, "pair_is_sure: $pair is unsure ".
                    "because no sure pair generates $xuse";
                return 0 unless wantarray;
                return (0, ['?']);
            }
        }
    }
    progress_report 5, "pair_is_sure: $pair is sure";
    $sure_pair_cache{$pair} = 1;
    delete $pair_is_sure_seen{$pair};
    return 1;
}

### Object existence and contents
#
# Ideally, we'd treat objects as existing only if some rule produced them (and
# thus be able to check entirely via hash_by_object), but this doesn't work in
# practice, most obviously because the regress has to start somewhere. Object
# existence mustn't change without aimake being informed of it; in most cases,
# special objects are considered to always exist. The main exception here is
# for sys:clean, which always doesn't exist.
#
# Special handling is needed for config_rule and config_option; these are
# assumed to be produced from 'sys:no_object' via the rule
# 'parse_configuration', but the rule does not physically exist. Rather, the
# effects that it would have if it did exist are simulated. This means that
# rule hashes work just fine (they have a matching rule to check), and so
# object_exists can work on them the same way it would work on, say, the
# spath.
sub object_exists {
    my $obj = shift;
    my ($objtype, undef) = parse_objname $obj;
    return $state->{hash_by_object}->{$obj}
        unless $objtype_is_special{$objtype};
    return 0 if $obj eq 'sys:clean';
    return 1;
}

####### Encoding calculations
#
# Some platforms don't support langinfo, so we need to import it by hand
# This also contains a fallback for if langinfo isn't there

$codeset = 'latin1'; # a guess
eval {
    require I18N::Langinfo;
    I18N::Langinfo->import(qw/langinfo CODESET/);
    $codeset = langinfo(CODESET());
} or do {
    my $locale = $ENV{LC_ALL};
    defined $locale or $locale = $ENV{LANG};
    $locale =~ /\.([^.]+)$/ and $codeset = $1;
};

# We support two types of file: text and binary.
#
# Binary files are easy: we want to turn off any sort of translation and read
# into a bytestring, and this can always be achieved using :raw :bytes.
#
# Text files are harder: we want to read into a character string, which means
# that we need to respect the encoding used by the command that created the
# file. This is impossible to know in general; however, most of the text files
# we're dealing with are dumps of stdout/stderr from shell commands, and those
# typically respect the system locale nowadays. So we assume that text files
# are encoded in $codeset (apart from our own config file, which is definitely
# encoded in UTF-8). The other problem is to determine what the layers for
# text files on the platform actually are; :crlf is likely on Windows, but
# incorrect for UNIX, for instance. So we check for :crlf in the layers from
# the (text file) stdin in order to learn what a text file looks like.
{
    my @layers = PerlIO::get_layers(\*STDIN);
    my $crlf = scalar grep $_ eq 'crlf', @layers;
    $binary_layers = ":raw:bytes";
    $text_layers = $utf8_layers = $ascii_layers = $crlf ? ':crlf' : '';
    $text_layers  .= ":encoding($codeset)";
    $utf8_layers  .= ":encoding(UTF-8)";
    $ascii_layers .= ":encoding(ASCII)";
}

####### Options and configuration

##### Command-line options
#
# We use the stock option parser, Getopt::Std, to parse the command
# line arguments.

read_statefile;
atomic_read {
    $path = $state->{_srcdir};
};

$::VERSION = '3.0';
Getopt::Long::Configure('bundling', 'permute', 'auto_help');
$opt_verbose = 0;
$opt_install = undef;
$opt_prefix = undef;
$opt_dump = undef;
$opt_ignore_builtin_config = 0;
@opt_warnings = (); # TODO: unimplemented
$opt_nocr = 0;
@opt_rebuild = ();  # TODO: unimplemented
$opt_documentation = 0;
$opt_dlayout = undef;
$opt_license = 0;
$opt_version = 0;
GetOptions('verbose|v:+' => \$opt_verbose,
           'install|i:s' => \$opt_install,
           'destdir=s' => \$opt_prefix,
           'dump-status:s' => \$opt_dump,
           'show-warnings|W' => \@opt_warnings,
           'no-carriage-return' => \$opt_nocr,
           'documentation' => \$opt_documentation,
           'directory-layout=s' => \$opt_dlayout,
           'ignore-builtin-config' => \$opt_ignore_builtin_config,
           'license' => \$opt_license,
           'version' => \$opt_version,
           'rebuild|B' => \@opt_rebuild) or pod2usage(2);
$opt_documentation and pod2usage('-exitval' => 0, '-verbose' => 2);
$opt_license and pod2usage('-exitval' => 0, '-verbose' => 99,
                           '-sections' => ['COPYRIGHT']);
if ($opt_version) {
    print <<EOF;
aimake version $::VERSION, running under Perl version $^V.
Copyright (C) 2013 Alex Smith.

This program is licensed under version 3 of the GNU General Public License;
you are welcome to redistribute it under certain conditions, but it comes with
ABSOLUTELY NO WARRANTY.

For details on the license and lack of warranty, run this program with the
'--license' option.
EOF
    exit 0;
}
$opt_verbose = defined_or($opt_verbose, 0);
if (defined $opt_dump) {
    atomic_read {
        $Data::Dumper::Indent = 1;   # to help keep it on the screen
        $Data::Dumper::Sortkeys = 1; # make it easier to find things in it
        $Data::Dumper::Useqq = 1;    # make it more readable
        $Data::Dumper::Deepcopy = 1; # don't use cross-references
        $Data::Dumper::Terse = 1;    # don't prefix '$VAR1 = '
        my @path = split /,/, $opt_dump;
        my $subset = $state;
        for my $key (@path) {
            if (defined_or(ref $subset, 'undef') eq 'HASH') {
                if (exists $subset->{$key}) {
                    $subset = $subset->{$key};
                } else {
                    $subset = '!exists';
                }
            } else {
                defined_or($subset, 'undef') ne '!exists' and
                    $subset = 'not a HASH ref';
            }
        }
        print ref $subset || !defined $subset ? Dumper($subset) : "$subset\n";
    };
    exit 0;
}

##### Locating the source directory
#
# If no source directory was specified, assume that aimake itself is in the
# source directory, and find it that way.
my $argpath = $ARGV[0];
defined $argpath or $argpath = $RealBin;
$argpath = ospath2aipath $argpath, undef, 1; # $path is not set yet

defined $path and scalar @ARGV == 1 and $path ne $argpath and
    die "This build directory is already being used to build '".
    aipath2ospath($path) . "' (you wanted to build '".
    aipath2ospath($argpath) . "')";

if (scalar @ARGV > 1) {
    die "Don't know what to do with multiple non-option arguments.";
}

if (!defined $path) {
    # Start a new build. We first want to verify that the
    # directory is empty.
    opendir my $dh, File::Spec->curdir or die "Cannot open '.': $!";
    my @offending_files = File::Spec->no_upwards(readdir($dh));
    @offending_files = grep ospath2aipath($_) ne statefilename &&
        ospath2aipath($_) ne 'bpath:nytprof.out',
        @offending_files;
    closedir $dh;
    if (@offending_files) {
        # We created a mostly empty statefile as a lockfile.
        # In our build directory, that wouldn't matter, but we've been run
        # from the wrong directory, so clean up after ourselves.
        unlink aipath2ospath(statefilename);
        die "Please use an empty directory for starting new builds.";
    }
    # Should be OK to start, then.
    $path = $argpath;
}

-d aipath2ospath('path:') or die "Source directory '" .
    aipath2ospath('path:') . "' is not a directory.";

atomically {
    $state->{_srcdir} = $path;
};

##### Configuration parsing

# We use Perl notation (Data::Dumper-style) for the config file, which leads
# to a bit of a problem reading it. The solution: use Perl's parser, and the
# Safe module to allow only specification of constants. (rv2sv is there so
# that variables can be used to avoid repetition. rv2gv seems to be needed on
# recent Perl versions. Probably it's to do with different optimizers.)
#
# Perl 5.8 gets very confused (to the extent of needing "require", which
# would allow anything), so we just evaluate the config file directly.
my $configsafe = new Safe;
$configsafe->permit_only(qw/null stub scalar pushmark const undef list qr
                            negate lineseq leaveeval anonlist anonhash rv2sv
                            sassign nextstate padany regcreset concat
                            stringify quotemeta rv2gv/);

# These are global, not lexical, so we can share them with the config file
our $libext = $Config{_a};
our $objext = $Config{_o};
our $exeext = $Config{_exe};
$exeext eq '' and $exeext = '.exe';
# a UUID generated for the purpose of avoiding clashes with other things
our $longrandomstring = 'AIMAKE_e15d5ce8_c8f0_40c9_9a3f_3b568bcd59d5_';
our $dllext = {MSWin32 => '.dll',
               linux   => '.so',
               darwin  => '.dylib'}->{$^O};
$configsafe->share('$libext', '$objext', '$exeext', '$dllext',
                   '$longrandomstring');

# Parse the global config file, from our <DATA>
$! = 0;
undef $@;
my $configdata;
{
    local $/;
    $configdata = <DATA>;
}
if ($] >= 5.009) {
    $config = $configsafe->reval($configdata, 0);
} else {
    $config = eval $configdata;
}
$@ or ($! and $@ = $!);
$@ or $@ = "bad configuration file format";
defined $config or
    die "Could not load global config file: $@";
undef $@;
ref $config eq 'HASH' or die "Invalid type in global config file";

if ($opt_ignore_builtin_config) {
    delete $config->{options};
    delete $config->{rules};
}

# Parse the local config file, from path:aimake.rules
my $localconfigfile = aipath2ospath(configfilename);
if (-f $localconfigfile) {
    local $/;
    open my $fh, '<', $localconfigfile
        or die "Could not open config file $localconfigfile: $!";
    $configdata = <$fh>;
} else { $configdata = '{}'; }
my $localconfig;
if ($] >= 5.009) {
    $localconfig = $configsafe->reval($configdata, 0);
} else {
    $localconfig = eval $configdata;
}
$@ or ($! and $@ = $!);
$@ or $@ = "bad configuration file format";
defined $localconfig or
    die "Could not load project-specific config file: $@";
undef $@;
ref $localconfig eq 'HASH'
    or die "Invalid type in project-specific config file";
for my $t (qw/rules options directories/) {
    if (exists $localconfig->{$t}) {
        $config->{$t}->{$_} = $localconfig->{$t}->{$_}
            for keys %{$localconfig->{$t}};
    }
}

# Calculate a package name from the source directory, if we don't have one
# already.
$path =~ m=/([^/]+)$=;
defined($config->{options}->{packagename}) or
    $config->{options}->{packagename} = $1;

# Work out where and whether we're installing.
$installing = defined $opt_install;
$ipath = undef;
$opt_install and $ipath = ospath2aipath($opt_install);
$singledir = 0;
atomically {
    $ipath ||= $state->{_installdir};

    # Work out the install directory layout.
    my $dlayout = $opt_dlayout || $config->{options}->{directory_layout};
    if ($dlayout eq 'autodetect') {
        $dlayout = $config->{options}->{directory_layout_fallback};
        if (defined $ipath) {
            for my $layout (sort keys %{$config->{directories}}) {
                $ipath =~ $config->{directories}->{$layout}->{autodetect} and
                    $dlayout = $layout;
            }
        }
    }
    defined $config->{directories}->{$dlayout} or
        die "Nonexistent directory layout '$dlayout'";
    $config->{options}->{directory_layout} = $dlayout;
    $ipath ||= $config->{directories}->{$dlayout}->{preferred_installdir};

    # single_directory is special-cased.
    $dlayout eq 'single_directory' and $singledir = 1;

    # Fill in any directory options that weren't overriden.
    for my $dir (keys %{$config->{directories}->{$dlayout}}) {
        next unless $dir =~ /dir$/;
        $config->{options}->{$dir} ||=
            $config->{directories}->{$dlayout}->{$dir};
    }

    $config->{options}->{installdir} = $ipath;
    $state->{_installdir} = $ipath;
};

# Directory options need substitutions.
for my $option (keys %{$config->{options}}) {
    if ($option =~ /dir$/) {
        1 while $config->{options}->{$option} =~
            s/\$([a-z]+)/$config->{options}->{$1}/g;
    }
}

progress_report 4, Dumper($config->{options});

####### Main program

$SIG{INT} = sub {die "Interrupted.";};
progress_report 4, "Starting main program.";

##### Initialization
#
# Before we can enter the main loop, we have to add the rules as objects;
# specifically, we need to allow for new rules, rules being deleted, and rules
# having their hash changed. This is done via a fake pair 'parse_configuration
# sys:no_object', that always runs even though there's no change in either the
# rule or the object. The same thing is done for config options; and we also
# update sys:always_rebuild's hash.
#
# To hash a rule, we need to serialize it. Storable doesn't work (both because
# it doesn't like regexps, and because it's not stable as to whether it uses
# e.g. '2' or 2 for number-like strings), so we serialize by hand.
#
# record_pair_outputs will automatically do all the changed/unsure marking
# we'd want when a rule becomes changed, including notifying aimake of new
# rules, etc.

# We sanity-check the rules during initialization because a sufficiently
# insane rule might never run (e.g. if the user writes "object" rather than
# "output").
for my $rulename (keys %{$config->{rules}}) {
    my $rule = $config->{rules}->{$rulename};
    defined $rule or delete $config->{rules}->{$rulename}, next;
    # Check the rule for sanity.
    croak "Rule $rulename has no output, depends, or install directory"
        unless exists $rule->{output} || exists $rule->{depends} ||
        exists $rule->{install_dir};
    croak "Rule $rulename has both output and depends"
        if exists $rule->{output} && exists $rule->{depends};
}
$config_hashes{"config_rule:$_"} = sv_hash $config->{rules}->{$_}
    for keys %{$config->{rules}};
$config_hashes{"config_option:$_"} = sv_hash $config->{options}->{$_}
    for keys %{$config->{options}};
atomically {
    my $runcount = $state->{hash_by_pair}->
        {'parse_configuration sys:no_object'}->{'sys:always_rebuild'};
    $runcount ||= 0;
    $runcount++;
    $config_hashes{'sys:always_rebuild'} = $runcount;
    $config_hashes{'sys:rebuild_late'} = $runcount;
    $config_hashes{'sys:installing'} = $runcount;
    record_pair_outputs 'parse_configuration sys:no_object', \%config_hashes;
    mark_object_unsure 'parse_configuration sys:no_object', 'sys:rebuild_late';
    mark_object_unsure 'parse_configuration sys:no_object', 'sys:installing';
};


##### Main loop.
#
# We look for changed pairs that are runnable (i.e. have no unsure objects in
# its use dependencies and their recursive build dependencies). To save
# repeated slow unsureness calculations, we go through the entire list and
# then start again, rather than trying to find the first runnable pair. If the
# pair is runnable, then we have three possibilities: run the pair (no
# nonexistent objects in the use deps and the rule applies to the object);
# clean the pair's output (any nonexistent objects in the use deps, but the
# object exists and the rule applies to it); delete the pair altogether
# (nonexistent object or rule, or the rule does not apply to the object). The
# last two operations always count as successfully running the pair; the first
# operation can fail (or produce warnings).

my %pairs_currently_running = (); # used for parallel builds
my $rebuild_late_locked = 1;
my $installing_locked = 1;
my $last_pair = '';
MAINLOOP: while (1) {
    my $curpair = undef;
    my $find_another;
    my $no_changes_since = undef;
    my $no_rules_since_timestamp = time;
    my $lastbuild;
    my @xuse;
    atomically {
      FIND_ANOTHER_RULE:
        $find_another = 0;
        $curpair = undef;
        my @changedpairs = keys %{$state->{changed_pairs}};
        @changedpairs = sort grep $_ gt $last_pair, @changedpairs;
        if (!@changedpairs) {
            @changedpairs = sort keys %{$state->{changed_pairs}};
            $last_pair = '';
        }
        @changedpairs =
            sort grep !$pairs_currently_running{$_}, @changedpairs;
        if (!@changedpairs || (defined $no_changes_since &&
                               $changedpairs[0] eq $no_changes_since)) {
            # It could be that no pairs are runnable. In that case, unlock
            # features if we can.
            if ($rebuild_late_locked) {
                $rebuild_late_locked = 0;
                mark_object_sure 'parse_configuration sys:no_object',
                    'sys:rebuild_late';
                $find_another = 1;
                $no_changes_since = undef;
                $last_pair = '';
            } elsif ($installing_locked && $installing) {
                $installing_locked = 0;
                mark_object_sure 'parse_configuration sys:no_object',
                    'sys:installing';
                $find_another = 1;
                $no_changes_since = undef;
                $last_pair = '';
            }

            # We can't find a pair. Either we'll get one later, in which case
            # we should relinquish the critical section so that other threads
            # have a chance to give us one later, or we won't, in which case
            # we still need to relinquish the critical section so that we can
            # exit the main loop.
        } else {
            $curpair = $changedpairs[0];
            $last_pair = $curpair;
            my ($rulename, $objname) = parse_pairname $curpair;
            progress_report +(time > $no_rules_since_timestamp + 2 ?
                              $opt_verbose + 0.5 : 4),
                "Looking for a rule to run (checking '$rulename'" .
                (defined $objname ? " on object '" .
                 (friendly_objname $objname) . "')" : ')');
            time > $no_rules_since_timestamp + 2 and
                $no_rules_since_timestamp ++;
            defined $no_changes_since or $no_changes_since = $curpair;
            # Check for unsureness.
            progress_report 4, "Checking pair $curpair";
            $find_another = !pair_is_sure $curpair;
        }
        # Let other threads know we're processing this pair.

        $find_another and goto FIND_ANOTHER_RULE;
        $no_changes_since = undef;

        if (defined $curpair) {
            progress_report 4, "Checking run/clean/delete";
            # Now, if any pairs are runnable, curpair holds some runnable pair.
            # Work out whether we're running, cleaning, or deleting it.
            my ($rule, $object) = parse_pairname $curpair;
            my $runnable = 1;
            if (!(rule_applies_to_object $rule, $object) ||
                !(object_exists $object) ||
                !(object_exists "config_rule:$rule")) {
                # We're deleting it.
                # Clean it.
                record_pair_outputs $curpair, {};
                # Delete it. Cleaning it removed the pair from all the following
                # lists:
                # err_warn: report_pair_outputs sets/clears it
                # changed_pairs: record_pair_outputs marks unchanged
                # unsure: set_proviced_hash marks sure
                # hash: record_pair_outputs sets undef for all existing hashes
                # The remaining list is xuse, which we need to clean up ourself.
                reset_pair_xuse $curpair;
                # And now, the pair isn't mentioned anywhere at all, so we can
                # move onto the next one.
                progress_report 1,
                "Deleting outdated rule+object pair '$curpair'...";
                $runnable = 0;
            } else {
                # Check the rule's xuse for objects that don't exist, or that
                # have the wrong hash on disk.
                my ($currule, $curobject) = parse_pairname $curpair;
                ensure_pair_has_xuse $curpair;
                for my $obj (@{$state->{xuse_by_pair}->{$curpair}}) {
                    progress_report 5, "Checking xuse $obj";
                    if (!object_exists $obj) {
                        # We're definitely sure that this rule cannot be built
                        # from right now (and cannot be built from at all this
                        # compile unless we find a new file that provides its
                        # output). Clean it.
                        if (exists $state->{hash_by_pair}->{$curpair}) {
                            # If the pair was already outputting nothing, the
                            # clean is a no-op. This situation happens when a
                            # rule is created for the first time.
                            progress_report 1, "Cleaning rule+object pair " .
                                "'$curpair' because '$obj' was deleted...";
                        }
                        record_pair_outputs $curpair, {};
                        $runnable = 0;
                        last;
                    }
                    # The object always has the right hash unless it's on disk.
                    # This check makes sense for path: objects ("somebody edited
                    # the source tree while we were running), and bpath: objects
                    # ("somebody edited the build tree, including between runs");
                    # for spath:, it means "somebody edited system files we rely
                    # on between runs". For edited bpath: objects we regenerate
                    # them, for edited spath: objects we should probably rebuild
                    # other pairs that use them (as well as this pair), and for
                    # path: objects we should error out (because it almost
                    # certainly indicates that a build rule has got its inputs and
                    # outputs muddled up).
                    my ($objtype, undef) = parse_objname($obj);
                    if ($objtype =~ /^[bs]?path$/) {
                        my $hash_on_disk = file_hash($obj);
                        my $desired_hash = xuse_hash($curpair, $obj);
                        if ($hash_on_disk ne $desired_hash) {
                            $objtype eq 'path' and croak
                                "Source file '" . friendly_objname($obj) .
                                "' was overwritten during the build, make sure " .
                                "your build rules are correct";
                            $objtype eq 'bpath' and
                                progress_report -1, "Warning! Someone seems to " .
                                "have tampered with the build directory (" .
                                friendly_objname($obj) . ")";
                            $objtype eq 'spath' and
                                progress_report 1, "Regenerating files built " .
                                "via changed system file " .
                                friendly_objname($obj);
                            # We need to mark all pairs producing the object in
                            # question as changed (and thus the object itself as
                            # unsure).
                            mark_pair_changed $_ for
                                keys %{$state->{hash_by_object}->{$obj}};
                            # And we can't continue, due to having an unsure
                            # ancestor.
                            $runnable = 0;
                            last;
                        }
                    }
                }
            }
            if ($runnable) {
                # We can run the rule!
                ensure_pair_has_xuse $curpair;
                @xuse = @{$state->{xuse_by_pair}->{$curpair}};
            } else {
                # Find another rule.
                $find_another = 1;
            }
        }
        $find_another and goto FIND_ANOTHER_RULE;
        $curpair and $pairs_currently_running{$curpair} = 1;
    };
    if (!$curpair) {
        # End of the run.
        last;
    }

    my ($rulename, $objname) = parse_pairname $curpair;
    my $rule = $config->{rules}->{$rulename};

    # Give an appropriate progress message.
    my $shortobject = friendly_objname($objname);
    my $level;
    my $verb = defined_or($rule->{verb}, 'built');
    my $whatmsg;
    if ($rule->{install_dir}) {
        $whatmsg = "Installing $shortobject (rule $rulename)";
        $verb = 'installed';
        $level = 0;
    } elsif ($rule->{depends}) {
        $whatmsg = "Finding dependencies of $shortobject (rule $rulename)";
        $verb = 'found';
        $level = 1;
    } elsif ($rule->{outdepends}) {
        if ($objname eq 'sys:no_object') {
            $whatmsg = "Finding objects (rule $rulename)";
            $verb = 'found';
            $level = 1;
        } else {
            $whatmsg = "Finding contents of $shortobject (rule $rulename)";
            $verb = 'found';
            $level = 1;
        }
    } elsif ($objname eq 'sys:no_object') {
        $whatmsg = "Running build rule $rulename";
        $level = 0;
    } else {
        $whatmsg = "Building from $shortobject (rule $rulename)";
        $level = 0;
    }
    $rule->{low_message_priority} and $level = 1;

    progress_report +($level == 1 ? 0.5 : 0), "$whatmsg...";

    # Work out where we're outputting to.
    my $output_target = defined_or($rule->{output},
                                   "dependencies:$rulename:$objname");
    my $installed_into = undef;
    if ($rule->{install_dir}) {
        my ($objtype, undef) = parse_objname $objname;
        my @components = $objtype eq 'sys' ? $objname : parse_aipath $objname;
        my $install_name = defined_or($rule->{install_name}, $components[-1]);
        $install_name =~ s/\Q$exeext\E$/$Config{_exe}/es;
        $output_target = $config->{options}->{$rule->{install_dir}} . "/" .
            $install_name;
        if ($opt_prefix) {
            my $aiprefix = ospath2aipath $opt_prefix;
            my @components1 = parse_aipath $aiprefix;
            my @components2 = parse_aipath $output_target;
            $components2[0] eq 'spath' or die
                "Bad --destdir option: --install is inside source " .
                "or build directory";
            # Meanwhile, $components1[0] not being on the spath is meaningful,
            # albeit probably not useful.

            # Remove the "spath" and drive from the output_target; we're
            # changing the root directory, which means that the drive just
            # vanishes altogether.
            shift @components2; shift @components2;

            $output_target = deparse_aipath @components1, @components2;
        }
    }
    # $output_target's content gets modified, so we need to clone it if
    # it's an array ref.
    (ref $output_target) eq 'ARRAY' and $output_target = [@$output_target];
    (ref $output_target) eq 'ARRAY' or $output_target = [$output_target];

    # If our output is known in advance (rather than discovered as it's
    # proviced), create a directory for it.
    if (scalar @$output_target >= 1 &&
        (!ref ($rule->{inner}) || ref ($rule->{inner}) !~ /\bRegexp$/) &&
        (!exists $rule->{outputarg}) &&
        (ref ($output_target->[0])) !~ /\bRegexp$/) {
        complete_objname \$_,
            defined_or($rule->{inner}, $objname) for @$output_target;
        $output_target = [map +(resolve_extend $_), @$output_target];

        ensure_directory $_, 1, exists $rule->{install_dir}
            for @$output_target;
    } elsif (scalar @$output_target == 1) {
        # Make it back into a regex, not an array.
        $output_target = $output_target->[0];
    }

    # If we're installing, install now.
    if (defined $rule->{install_dir}) {
        my ($objtype, undef) = parse_objname $objname;
        if ($objtype ne 'sys') {
            my $ospathfrom = aipath2ospath $objname;
            my $ospathto = aipath2ospath $output_target->[0];
            open my $fhfrom, "<$binary_layers", $ospathfrom
                or die "Could not open '$ospathfrom' for read";
            open my $fhto, ">$binary_layers", $ospathto
                or die "Could not open '$ospathto' for write";
            print $fhto $_ for <$fhfrom>;
            close $fhfrom; close $fhto;
            # If we're installing an executable, the target should also be
            # executable.
            -x $ospathfrom and chmod 0755, $ospathto;
        } elsif ($objname eq 'sys:touch_only') {
            # nothing to do; we already created the directory
        } elsif ($objname eq 'sys:create_subdir') {
            ensure_directory $output_target->[0], 0, 1;
        } elsif ($objname eq 'sys:empty_file') {
            my $ospathto = aipath2ospath $output_target->[0];
            open my $fhto, ">$binary_layers", $ospathto
                or die "Could not open '$ospathto' for write";
            close $fhto;
        } elsif ($objname eq 'sys:ensure_exists') {
            my $ospathto = aipath2ospath $output_target->[0];
            if (!-e $ospathto) {
                open my $fhto, ">$binary_layers", $ospathto
                    or die "Could not open '$ospathto' for write";
                close $fhto;
            }
        } else {
            die "System object '$objname' cannot be installed";
        }
        # Make the rule into a production rule that produces nothing.
        $installed_into = $output_target;
        $output_target = [];
    }

    # Calculate the command line.
    my @rcargs = @xuse;
    defined $rule->{in_subdir} and push @rcargs,
        \ ("cwd:" . $rule->{in_subdir}), \ "relpaths";
    defined $rule->{force_locale} and push @rcargs,
        \ ("locale:" . $rule->{force_locale});

    # Run the command.
    my ($failreason, $stdout, $stderr) = run_command(@rcargs);

    $rule->{also_match_stderr} and ($stdout, $stderr) = ($stdout.$stderr, '');

    my @output = ();
    my @depends = ();
    my $failing_silently = 0;
    my $shortfailreason = $failreason;

    defined_or($rule->{fail_silently},0) == 2 and $failreason = undef;

    # Did it work?
    if (defined $failreason) {
        # No.
        $failreason .= ", with the following command line:\n";
        $failreason .= run_command(@rcargs, \ "cmdline");
        if (defined $stderr and $stderr ne '') {
            $failreason .= "\nand the following messages:\n$stderr";
        }
        chomp $failreason;

        # If we're failing silently at 1, then we produce no output and no
        # dependencies, but also no errors. (This is why the check for 1 is
        # inside the if, and the check for 2 is outside the if; failing
        # silently at 2 just ignores the failure code and treats the command
        # as having succeeded.) A dependencies: object is still generated, in
        # the silent failure case.
        if (defined_or($rule->{fail_silently}, 0) == 1 ||
            $stderr =~ /\!AIMAKE_FAIL_SILENTLY\!/) {
            ($failreason, $stderr) = (undef, '');
            $rule->{depends} and @output = @$output_target;
            $failing_silently = 1;
        }
    } else {
        # Yes.
        progress_report 4, "Parsing output...";
        $rule->{ignore_warnings} and $stderr = '';

        my $otarg = $rule->{outputarg};
        my $inner = defined_or($rule->{inner}, $objname);
        my $depends = defined_or($rule->{outdepends}, $rule->{depends});
        my $deparg = $rule->{dependsarg};
        $depends = defined_or($depends, []);

        # We keep a list of everything that could possibly be a regex.
        # Then we replace the regexes in the output.
        # Everything before the undef wants OS paths replaced with aimake
        # paths.
        my @regexable = (\$output_target, \$inner, \$depends,
                         undef, \$otarg, \$deparg);
        my $aify = 1;
        for my $r (@regexable) {
            if (!defined $r) {
                $aify = 0;
                next;
            }
            (ref $$r) =~ /\bRegexp$/ or next;

            my $rxreplace = [];
            my $out = (ref $stdout ? dclone $stdout : $stdout);
            if (!ref $out) {
                # Remove the very last newline from $out.
                chomp $out;
                # $out needs a split and perhaps an unescape.
                my $linesep = defined_or($rule->{linesep}, "\n");
                (ref $linesep) !~ /\bRegexp$/
                    and $linesep = qr/\Q$linesep\E/;
                if (defined $rule->{unescape}) {
                    my @out = ();
                    push @out, $1 while
                        $out =~ m/((?:[^\\]|\\.)*?)(?:$linesep | $ )/gsx;
                    $out = \@out;
                } else {
                    $out = [split /$linesep/, $out];
                }
                if (defined $rule->{unescape} &&
                    $rule->{unescape} eq 'backslash') {
                    s/\\\n//g for @$out;
                    s{\\(.)}{do{my $x = $1;
                                $x =~ y/abfnrt/\a\b\f\n\r\t/; $x}}ge
                        for @$out;
                    @$out = grep $_ ne '', @$out;
                } elsif (defined $rule->{unescape} &&
                         $rule->{unescape} eq 'backslash_whitespace') {
                    s/\\\n//g for @$out;
                    s/\\([\s\\])/$1/ge for @$out;
                    @$out = grep $_ ne '', @$out;
                }
            } else {
                # If an intcmd is giving us out-of-band end-of-lines, it's
                # also giving us aipaths rather than OS paths.
                $aify = 0;
            }

            my $filter = $rule->{filter};
            my @outlines = $filter ? grep /$filter/, @$out : @$out;
            my $lineskip = $rule->{lineskip};
            my $linemax = $rule->{linemax};
            # move the deref outside the loop, that match is one of the most
            # run lines in the program (according to the profiler) so any
            # small gain is helpful; don't bother precompiling the regex
            # because it's already in a qr// and putting it in another qr//
            # won't help
            my $regex_licm = $$r;
            for my $line (@outlines) {
                $lineskip--, next if $lineskip;
                next if defined $linemax && $linemax == 0;
                $linemax-- if defined $linemax;
                while ($line =~ m/$regex_licm/g) {
                    my $n = $1;
                    $aify and $n = ospath2aipath($n, $inner);
                    $n =~ /^file:/ and $rule->{output_as_searchfile}
                        and $n = "search$n";
                    push @$rxreplace, $n unless
                        ($n =~ /^spath:/ && $rule->{filter_spath}) ||
                        ($n !~ /^(search)?file:/ &&
                         $rule->{filter_absolute}) ||
                        ($rule->{filter_nonexistent_files} &&
                         $n =~ /^[bs]?path:/ &&
                         (!-e aipath2ospath($n) || (!-f _ && !-l _))) ||
                        ($rule->{filter_text_files} &&
                         $n =~ /^[bs]?path:/ && -T aipath2ospath($n));
                }
            }
            if ($rule->{require_match} and !@$rxreplace) {
                $shortfailreason = $failreason =
                    "Regular expression $$r failed to match [@outlines]";
                $failreason .= "\nThe command line was:\n";
                $failreason .= run_command(@rcargs, \ "cmdline");
            }
            $$r = $rxreplace;
        }
        # Our list of everything that could possibly be a regex doubles
        # as a list of everything that could be a scalar or could be an
        # array reference.
        $$_ = !defined $$_ ? [''] : (ref $$_) eq 'ARRAY' ? $$_ : [$$_]
            for @regexable;
        # Calculate our output and our inner out of the pieces.
        if (!$failreason) {
            for my $ostem (@$output_target) {
                for my $oarg (@$otarg) {
                    for my $oinner (@$inner) {
                        my $x = $ostem . $oarg;
                        complete_objname \$x, $oinner;
                        push @output, resolve_extend $x;
                    }
                }
            }
            for my $dstem (@$depends) {
                for my $darg (@$deparg) {
                    for my $dinner (@$inner) {
                        my $x = $dstem . $darg;
                        complete_objname \$x, $dinner;
                        push @depends, resolve_extend $x;
                    }
                }
            }
        }
    }

    $rule->{propagate_usedeps} and $rule->{propagate_usedeps} != 2 and
        push @depends, $objname;
    @output = grep {$_ ne $objname} @output;

    # Check for insane output.
    for my $o (@output) {
        my ($otype, undef) = parse_objname $o;
        if ($otype eq 'dependencies') {
            croak "Rule $rulename output $o but is not a dependency rule"
                unless exists $rule->{depends} || $rule->{outdepends};
        } elsif ($objtype_provided{$otype}) {
            croak "Rule $rulename output provided object $o but " .
                "has no outdepends" unless exists $rule->{outdepends};
        } elsif ($otype eq 'bpath') {
            croak "Provision rule $rulename output produced object $o"
                if exists $rule->{outdepends};
            croak "Provision rule $rulename output produced object $o"
                if exists $rule->{propagate_usedeps};
        } elsif (!exists $rule->{information_only}) {
            croak "Rule $rulename output unprovicable object $o";
        }
    }
    for my $o (@depends) {
        parse_objname $o; # check it's a well-formed object name
    }

    my @shortened = map {friendly_objname($_)} @output;
    my $msg;
    if ($rule->{depends}) {
        @shortened = map {friendly_objname($_)} @depends;
        $verb = "found";
    } elsif (@depends) {
        progress_report 4, "Outdepends are [".(join ", ", @depends)."]";
    }
    if (!$failreason) {
        if (scalar @shortened == 0) {
            $msg = "Succeeded but $verb no objects";
            # Install rules output no objects, but still do something.
            # We can look at $installed_into to find the actual installed
            # object.
            $rule->{install_dir} and $msg = "Installed into " .
                friendly_objname($installed_into->[0]);
            # Silently failing rules can give us a better message here.
            $failing_silently and $msg =
                "The rule was skipped because it was inapplicable";
        } elsif (scalar @shortened <= 4) {
            $msg = ucfirst $verb . " " . join ', ', @shortened;
        } else {
            $msg = ucfirst $verb . " " . $shortened[0] . ", " .
                $shortened[1] . ", ". $shortened[2] . ", and " .
                (scalar @shortened - 3) . " other objects";
        }
        $msg .= (defined $stderr && $stderr ne '' ?
                 " (with warnings)." : ".");
    } else {
        if ($objname eq 'sys:no_objname') {
            $msg = "Couldn't run rule $rulename: $shortfailreason";
        } else {
            $msg = "Couldn't run rule $rulename on $objname: $shortfailreason";
        }
    }
    progress_report +($failreason ? -1 : $level), $msg;

    atomically {
        if ($failreason) {
            record_pair_error $curpair, "$whatmsg failed: $failreason";
        } else {
            # Calculate the hashes of all produced objects. The only produced
            # objects that normal rules are allowed to produce are path,
            # bpath, spath. (And extend, but that's been replaced by now.)
            # Also calculate the "hash" of provided objects: that's \@depends.
            # This is done here because file_hash needs atomically()
            # protection.
            my %outhashes = ();
            for my $o (@output) {
                my ($otype, undef) = parse_objname $o;
                if ($objtype_provided{$otype}) {
                    $outhashes{$o} = \@depends;
                } elsif ($otype =~ /^[bs]?path/) {
                    $outhashes{$o} = file_hash $o;
                } else {
                    croak "Rule $rulename output the wrong " .
                        "type of object: $o";
                }
            }
            defined $stderr and $stderr ne '' and
                $stderr = "$whatmsg produced warnings:\n$stderr";
            record_pair_outputs $curpair, \%outhashes, $stderr;
        }

        delete $pairs_currently_running{$curpair};
    };
}

##### Cleanup
#
# We don't make any state changes during cleanup; this is because the compile
# process is designed to work even when interrupted at any point (reverting to
# the start of the atomically{} block if it's interrupted inside one of
# those). As such, this is pretty much entirely about printing messages.
#
# As one exception, the actual file writing is postponed until the end of the
# program, or a death/error. As such, we need to finish off with
# write_statefile.

my $anyproblems = 0;

### Errors and warnings during compile
#
# We need to report any warning/error messages to the user. These are stored
# in $state->{errwarn_by_pair}; we output the object, the rule, and the
# message. The object/rule were added earlier, so this is a pretty simple
# loop.

atomic_read {
    my $ewprinted = 0;
    for my $pair (sort keys %{$state->{errwarn_by_pair}}) {
        if (!$ewprinted) {
            progress_report -1,
                "\nThe following warnings/errors were reported:\n";
        }
        my $msg = $state->{errwarn_by_pair}->{$pair};
        $msg =~ /^E:/ and $anyproblems++;
        $msg =~ s/^[EW]://s;
        progress_report -1, "$msg\n";
        $ewprinted++;
    }
};

### Dependency problems
#
# A pair has dependency problems if it's non-changed, all objects in its
# command exist, and at least one object in its xuse doesn't exist. (There are
# a few more things true about such pairs, e.g. they don't appear in
# hash_by_pair, but we don't need to worry about that when presenting our
# output.)

atomically {
    my $ewprinted = 0;
    my %bad_rule_deps;
    # Note that pairs with unknown xuse still have an xuse_by_pair key, just
    # an undef value.
  DEPCHECK: for my $pair (sort keys %{$state->{xuse_by_pair}}) {
        my ($rulename, $objname) = parse_pairname $pair;
        $rulename eq 'parse_configuration' and next; # special case
        my $command = $config->{rules}->{$rulename}->{command};
        ref $command and $command = [@$command];
        $command or $command = [];
        ref $command or $command = [$command];
        complete_objname \$_, $objname for @$command;
        $_ = resolve_extend $_ for @$command;
        object_exists $_ or next DEPCHECK for @$command;
        $state->{blocked_by_pair}->{$pair} and
            croak "Pair '$pair' is blocked by '" .
            $state->{blocked_by_pair}->{$pair} . "', existence '" .
            ((object_exists $state->{blocked_by_pair}->{$pair}) ?
             'yes' : 'no') . "', command [@$command]";
        my ($has_xuse, $wanted, $user, $tied) = ensure_pair_has_xuse $pair, 1;
        my @missing_deps;
        my $verb = 'missing';
        if ($has_xuse) {
            @missing_deps = sort grep +((!object_exists $_) && $_ ne 'sys:clean'),
                @{$state->{xuse_by_pair}->{$pair}};

            $_ = friendly_objname($_) . '(' .
                friendly_objname($state->{xuse_by_object}->{$_}->{$pair}) . ')'
                for @missing_deps;
        } else {
            @missing_deps = @$tied;
            $verb = "multiple possibilities for " .
                friendly_objname($wanted) . ':';
            (undef, $_) = parse_pairname $_ for @missing_deps;
            $_ = friendly_objname($_) for @missing_deps;
        }
        (scalar @missing_deps) or next;

        $anyproblems++; # this sort of missing dependency is a problem

        if (!$ewprinted) {
            progress_report -1,
                "\nThe following rules did not run due to dependency issues:\n";
        }

        if ((scalar @missing_deps) > 4) {
            $missing_deps[3] = 'and ' . ((scalar @missing_deps) - 3) .
                " more objects";
            $#missing_deps = 3;
        }
        my $missing_deps = join ', ', @missing_deps;

        if ($objname eq 'sys:no_object') {
            $bad_rule_deps{"$rulename: $verb $missing_deps"} = {};
        } else {
            $bad_rule_deps{"$rulename on #OBJECT#: $verb $missing_deps"}->
                          {$objname} = 1;
        }
        $ewprinted++;
    }
    for my $msg (sort keys %bad_rule_deps) {
        my @objs = keys %{$bad_rule_deps{$msg}};
        if (0 == scalar @objs) {
            progress_report -1, $msg;
        } elsif (1 == scalar @objs) {
            $msg =~ s/#OBJECT#/'object '.$objs[0]/e;
            progress_report -1, $msg;
        } else {
            $msg =~ s/#OBJECT#/(scalar @objs).' objects'/e;
            progress_report -1, $msg;
        }
    }
};

### Dependency loops
#
# One thing that's definitely a problem is loops in the dependencies. There
# are a few possible ways this can manifest:
# - None of the objects in the loop were pre-existing, and the loop goes
#   through depends or outdepends fields. This will have been warned about as
#   a missing dependency already (although aimake won't realise why the
#   dependency is missing).
# - None of the objects in the loop were pre-existing, and the loop goes
#   entirely through command and output fields. This won't have been warned
#   about yet (because every rule in the loop will be blocked).
# - At least one of the objects in the loop was pre-existing, causing the
#   loop to go most of the way round (and then fail due to unsureness).
# The third case is pretty easy to detect; it gives us an object that's unsure
# with respect to a changed pair (as opposed to a pair that previously
# succeeded now failing, which gives us an object that's unsure with respect
# to an unchanged pair). In general, the first two cases cannot be detected;
# the object name that's output by a rule may depend on the contents of the
# objects that are input.

atomically {
    my $ewprinted = 0;
    my %loop_objects = ();
    for my $pair (keys %{$state->{unsure_by_pair}}) {
        $state->{changed_pairs}->{$pair} or next;
        for my $obj (keys %{$state->{unsure_by_pair}->{$pair}}) {
            $loop_objects{$obj} = 1;
        }
    }
    for my $pair (keys %{$state->{unsure_by_pair}}) {
        $state->{changed_pairs}->{$pair} or next;
        for my $obj (keys %{$state->{unsure_by_pair}->{$pair}}) {
            my $fobj1 = friendly_objname $obj;
            my ($sure, $unsure_list) = pair_is_sure $pair, 0;
            $sure and croak "Pair $pair is changed yet sure at program end";

            $unsure_list->[0] eq 'tie' and next;

            # It's theoretically possible that we get a false positive due
            # to two erroring rules that depend on each other in exactly the
            # right way. Make sure that's not happening.
            my $last_obj = $unsure_list->[$#$unsure_list];
            $loop_objects{$last_obj} or next;

            $anyproblems++;

            if (!$ewprinted) {
                progress_report -1,
                    "\nThe following dependency loops were detected:\n";
                $ewprinted++;
            }

            # The list alternates between xuses and pairs, with an xuse at
            # each end.
            unshift @$unsure_list, $obj, $pair;
            my $ir = "";
            my $mr = "is output by";
            while (@$unsure_list > 1) {
                my $x = shift @$unsure_list;
                my $p = shift @$unsure_list;
                my ($rule, $pobj) = parse_pairname $p;
                my $fx = friendly_objname $x;
                my $fo = friendly_objname $pobj;
                if ($pobj eq 'sys:no_object') {
                    progress_report -1, "$ir$fx $mr rule $rule,";
                } else {
                    progress_report -1, "$ir$fx $mr rule $rule on $fo,";
                }
                $ir = "  which depends on ";
                $mr = "which is output by";
            }
            # Complete the loop. It either loops back on itself, or joins onto
            # another loop; either way, there's enough information for the
            # user to calculate the entire loop.
            my $fl = friendly_objname $last_obj;
            progress_report -1, "  which depends on $fl.\n";
        }
    }
};

write_statefile;
progress_report 4, "Main program is ending.";

$anyproblems and exit 1;

####### Configuration files
#
# The default configuration file is appended to this script, in order to keep
# the aimake distribution as just one file.
__DATA__
# aimake config file. This is written in a very limited dialect of Perl (which
# only allows scalar, regex, array, and hash constants, and assigning to and
# using scalar variables), and determines the behaviour on different sorts of
# files.
#
# This file is the global file that specifies default behaviour for aimake,
# and is designed to work on a wide range of projects (and hopefully,
# eventually, operating systems). Projects can use their own specific
# aimake.rules file to override the config in this file.
#
# See `perldoc -F aimake` for the format.
{
    options => {
        default_libraries => [
            'c',
            'msvcrt', # Windows version of libc
            'm',
        ],
        libraries => [],
        ignore_directories =>
            qr/^(?:\.svn|\.git|\.hg|\.bzr|_darcs)$/i,
        ignore_directories_with_files => [
            'aimake.state',   # old versions of aimake
            'aimake2.state',  # old versions of aimake
            'aimake.objects', # this version of aimake
            'config.status',  # autoconf
            'CMakeCache.txt', # CMake
        ],
        directory_layout => 'autodetect',
        directory_layout_fallback => 'single_user',
    },
    # Directories. One of these directory sets is used for the install,
    # based on the command line options or the install directory; they
    # become normal options early in the compile process.
    directories => {

        # FHS layout: used for installed programs on UNIX/Linux systems. This
        # layout uses a wide variety of directories, and typically has
        # $installdir = spath:/usr. (In fact, the only other directory it
        # really makes sense with is the root directory, which is why it
        # specifies /usr explicitly sometimes. It'll only be used in /usr,
        # the root directory, or if the user specifically requests it.)
        fhs => {
            autodetect => qr=^spath:/(?:usr)?$=,
            preferred_installdir => 'spath:/usr',

            # Relative to the root directory.
            configdir => 'spath:/etc',
            staterootdir => 'spath:/var',

            # Relative to -i on the command line, or to /usr, depending on
            # whether there are one or two copies of the directory.
            bindir => '$installdir/bin',
            rootbindir => '$installdir/sbin',
            gamesbindir => 'spath:/usr/games',
            libdir => '$installdir/lib',
            specificlibdir => '$installdir/lib/$packagename',
            includedir => 'spath:/usr/include',
            specificincdir => 'spath:/usr/include/$packagename',
            datarootdir => 'spath:/usr/share',

            # Relative to datarootdir.
            datadir => '$datarootdir/$packagename',
            gamesdatadir => '$datarootdir/games/$packagename',
            mandir => '$datarootdir/man',
            infodir => '$datarootdir/info',
            docdir => '$datarootdir/doc/$packagename',

            # Relative to staterootdir.
            # Note that these have to be outside $installdir, because
            # spath:/usr is a read-only tree (except during install).
            statedir => '$staterootdir/lib/$packagename',
            gamesstatedir => '$staterootdir/games/$packagename',
            logdir => '$staterootdir/log',
            lockdir => '$staterootdir/run',
            specificlockdir => '$staterootdir/run/$packagename',
        },

        # FHS layout, non-package-manager version. There's a set of
        # directories set aside for package manager use; this avoids them as
        # far as possible, using a set of directories that the package manager
        # has been told not to touch.
        fhs_unmanaged => {
            autodetect => qr=^spath:/usr/local$=,
            preferred_installdir => 'spath:/usr/local',

            # Relative to the root directory.
            # Package managers can mess with /etc, but they're not allowed to
            # mess with files there that they don't recognise, so just using
            # /etc would be theoretically OK. However, the FHS suggests using
            # /usr/local/etc in install programs (the user can make that a
            # symlink to /etc/local if they'd prefer things in the /etc
            # hierarchy).
            configdir => '$installdir/etc',
            staterootdir => 'spath:/var',

            # Relative to -i on the command line.
            bindir => '$installdir/bin',
            rootbindir => '$installir/sbin',
            gamesbindir => '$installdir/games',
            libdir => '$installdir/lib',
            specificlibdir => '$installdir/lib/$packagename',
            includedir => '$installdir/include',
            specificincdir => '$installdir/include/$packagename',
            datarootdir => '$installdir/share',

            # Relative to datarootdir.
            datadir => '$datarootdir/$packagename',
            gamesdatadir => '$datarootdir/games/$packagename',
            mandir => '$datarootdir/man',
            infodir => '$datarootdir/info',
            docdir => '$datarootdir/doc/$packagename',

            # Relative to staterootdir.
            # Note that these have to be outside $installdir, because
            # spath:/usr is a read-only tree (except during install).
            statedir => '$staterootdir/local/$packagename',
            # The FHS is silent on the correct name for gamesstatedir
            # for an unpackaged directory. This seems like a decent
            # guess though...
            gamesstatedir => '$staterootdir/local/games/$packagename',
            # Logs likely need rotation. I'm not 100% sure this is correct.
            logdir => '$staterootdir/log',
            # lockdir needs to be /var/run because it's probably a symlink
            # to /run (and being a transient directory anyway, a package
            # manager can't meaningfully manage it).
            lockdir => '$staterootdir/run',
            specificlockdir => '$staterootdir/run/$packagename',
        },

        # Add-on package layout on FHS systems. This puts most things in an
        # entirely separate hierarchy of their own; it can be seen as the
        # system-wide version of installing in /home. Note that we could
        # actually use any layout we like here for the files in /opt; the
        # only requirement is the /var/opt, /etc/opt, /opt split. However,
        # we try to keep things in an FHS-like order because that's what the
        # program may be expecting.
        fhs_package => {
            autodetect => qr=^spath:/opt/=,
            preferred_installdir => 'spath:/opt/$packagename',

            # Relative to the root directory.
            configdir => 'spath:/etc/opt/$packagename',
            staterootdir => 'spath:/var/opt/$packagename',

            # Relative to -i on the command line.
            bindir => '$installdir/bin',
            rootbindir => '$installdir/bin',
            gamesbindir => '$installdir/bin',
            libdir => '$installdir/lib',
            # Because we're already in a package-specific directory, the
            # libdir and specificlibdir are the same.
            specificlibdir => '$installdir/lib',
            includedir => '$installdir/include',
            specificincdir => '$installdir/include',
            datarootdir => '$installdir/share',

            # Relative to datarootdir.
            datadir => '$datarootdir',
            gamesdatadir => '$datarootdir',
            mandir => '$datarootdir/man',
            infodir => '$datarootdir/info',
            docdir => '$datarootdir/doc',

            # Relative to staterootdir.
            # Note that these have to be outside $installdir, because
            # spath:/opt is a read-only tree (except during install).
            statedir => '$staterootdir',
            gamesstatedir => '$staterootdir',
            logdir => '$staterootdir/log',

            # Relative to /var/run. (On many systems, it's /run nowadays, but
            # the /var name has a longer history and is likely to be a symlink
            # for the forseeable future.)
            lockdir => 'spath:/var/run',
            specificlockdir => 'spath:/var/run/$packagename',
        },

        # Installing for just one user. Unlike the FHS installs, this one
        # works on Windows too, so there's an autodetect for the most common
        # instance of that (Windows Vista+ with a noncustomized English
        # document path). (The /Users/ autodetect is for Mac OS X.) As such,
        # care must be taken to avoid any FHS-specific paths. We still use a
        # vaguely FHS-like layout to keep things neat, but with more generic
        # names, and all the directories are arbitrary. (One big difference is
        # the use of $installdir, not $installdir/bin, for binaries; this
        # makes them easier to find.)
        single_user => {
            # The [^/]+ is not a typo: / is not legal in filenames on Windows,
            # so we don't have to worry about an escaped /.
            autodetect => qr=^spath:(?:/home/|/Users/|(?i:c/users/[^/]+/documents))/=,
            preferred_installdir => 'bpath:aimake_install',

            # Everything is relative to -i on the command line.
            configdir => '$installdir/config',
            staterootdir => '$installdir',
            bindir => '$installdir',
            rootbindir => '$installdir',
            gamesbindir => '$installdir',
            libdir => '$installdir/lib',
            # Because we're already in a package-specific directory, the
            # libdir and specificlibdir are the same.
            specificlibdir => '$installdir/lib',
            includedir => '$installdir/include',
            specificincdir => '$installdir/include',
            datarootdir => '$installdir',

            # Relative to datarootdir.
            datadir => '$datarootdir/data',
            gamesdatadir => '$datarootdir/data',
            mandir => '$datarootdir/man',
            infodir => '$datarootdir/info',
            docdir => '$datarootdir/doc',

            # Relative to staterootdir.
            statedir => '$staterootdir/data-rw',
            gamesstatedir => '$staterootdir/save',
            logdir => '$staterootdir/log',
            lockdir => '$staterootdir/lock',
            specificlockdir => '$staterootdir/lock',
        },

        # An install that just dumps everything in the same directory; useful
        # for home directory installs if there aren't many files being
        # installed. We never autodetect this, and it works better if the
        # application ignores $statedir and instead finds a user-specific
        # place to store its state (dotfiles, etc.). intcmd:optionvalues is
        # special-cased to return all directory options as relative paths
        # when this is used.
        single_directory => {
            autodetect => qr=(?!)=, # more version-portable (*FAIL)
            preferred_installdir => 'bpath:aimake_install',

            configdir => '$installdir',
            staterootdir => '$installdir',
            bindir => '$installdir',
            rootbindir => '$installdir',
            gamesbindir => '$installdir',
            libdir => '$installdir',
            specificlibdir => '$installdir',
            includedir => '$installdir',
            specificincdir => '$installdir',
            datarootdir => '$installdir',
            datadir => '$datarootdir',
            gamesdatadir => '$datarootdir',
            mandir => '$datarootdir',
            infodir => '$datarootdir',
            docdir => '$datarootdir',
            statedir => '$staterootdir',
            gamesstatedir => '$staterootdir',
            logdir => '$staterootdir',
            lockdir => '$staterootdir',
            specificlockdir => '$staterootdir',
        },

        # TODO: An FHS-like layout for Windows rather than FHS standards.
        # Part of the problem is that on Windows, you're meant to use syscalls
        # to get at the paths rather than just hardcoding them (they vary by
        # language and configuration), making it hard to implement this from a
        # portable program.
    },
    rules => {
        # Option sets.
        # TODO: Take these from options? Or from the environment?
        default_cflags => {
            output => 'optionset:CFLAGS',
            outdepends => ['optstring:-g',
                           'optstring:-O2',
                           'optstring:-Wall',
                           'optpath:-include :bpath:aimake/aimake_1.h',
                           'bpath:aimake/aimake_1.h'],
            verb => 'determined',
            low_message_priority => 1,
        },
        default_cxxflags => {
            output => 'optionset:CXXFLAGS',
            outdepends => ['optstring:-g',
                           'optstring:-O2',
                           'optstring:-Wall',
                           'optpath:-include :bpath:aimake/aimake_1.h',
                           'bpath:aimake/aimake_1.h'],
            verb => 'determined',
            low_message_priority => 1,
        },
        default_iflags => {
            output => 'optionset:IFLAGS',
            outdepends => [],
            verb => 'determined',
            low_message_priority => 1,
        },
        default_lflags => {
            output => 'optionset:LFLAGS',
            outdepends => [],
            verb => 'determined',
            low_message_priority => 1,
        },
        cflags_includes_iflags => {
            object => 'optionset:CFLAGS',
            depends => 'optionset:IFLAGS',
            verb => 'determined',
        },
        cxxflags_includes_iflags => {
            object => 'optionset:CFLAGS',
            depends => 'optionset:IFLAGS',
            verb => 'determined',
        },

        default_libraries => {
            # some likely guesses, not including the system libc
            output => ['searchlib:crypt',
                       'searchlib:dl',
                       'searchlib:m',
                       'searchlib:ncurses',
                       'searchlib:ncursesw',
                       'searchlib:pthread',
                       'searchlib:rt',
                       'searchlib:z'],
            outdepends => [],
            verb => 'determined',
            low_message_priority => 1,
        },

        # Finding relevant files.
        find_source_files => {
            # "optpath::path:" = root of the source directory
            command => ['sys:always_rebuild', 'intcmd:listtree',
                        'optpath::path:'],
            output => qr/(.+)/s,
            verb => 'found',
            information_only => 1,
        },
        fhs_library_directory => {
            # Are we on a UNIX/Linux-like system? If so, there's a bunch of
            # extra library directories we should add, because some linkers
            # (and maybe some compilers?) don't know about /usr/local.
            # (*glares at gold*)
            object => 'optionset:LFLAGS',
            command => ['intcmd:filetest', 'optstring:-d',
                        'optpath::spath:/usr/local/lib'],
            fail_silently => 1,
            depends => ['optpath:-L:spath:/usr/local/lib'],
        },

        # Finding header files is difficult. The problem is that cpp knows the
        # search path, but not even GNU cpp will tell you the search path upon
        # asking. As such, our solution is to preprocess a small test file
        # that includes some headers, and see where those headers are. In
        # order to accomplish this, we need to choose one header on each of
        # the likely search paths. We use the following set of headers:
        #
        # <iso646.h>
        #   Some C compilers provide their own set of headers independent of
        #   the OS's header files. <iso646.h> is a good choice because it's
        #   trivial to write, standard C, completely system-independent, and
        #   not provided by some system libraries (and as such, a compiler
        #   will want to patch around the deficiency). For instance, gcc and
        #   clang both have a copy, glibc doesn't.
        #
        # <limits.h>
        #   Some C compilers try to fix brokenness in the system include
        #   files; this involves making their own private copies elsewhere.
        #   <limits.h> is the only file that's unconditionally fixed by gcc on
        #   every system, so we have to use it. (As a bonus, it also seems to
        #   be unconditionally fixed by clang; its fix is on the same search
        #   path as its iso646.h, but including it makes it include /gcc's/
        #   fixed <limits.h>, if both are installed, thus informing us of a
        #   path the system knows about. And it's also standard C.)
        #
        # <sys/types.h>
        #   Some compilers have a multiple-architecture system, where
        #   different header files are used depending on the target
        #   architecture. As such, we want to find the correct directory for
        #   the architecture. None of the standard C header files are involved
        #   with this system (which means that it doesn't matter for standard
        #   C), so we use a standard POSIX header, <sys/types.h>, which is
        #   obviously highly architecture-dependent. (glibc provides a
        #   multiarch version of sys/types.h, as well as a default version.)
        #
        # <setjmp.h>
        #   We need to find the default system headers themselves. This
        #   involves picking one that won't be involved in multiarch, will be
        #   provided by the libc not the compiler, and won't be fixed by the
        #   compiler's installation. The only standard C header that fulfils
        #   these conditions is <setjmp.h>, probably because it's too weird to
        #   be caught up in any of the other mechanisms.
        #
        # <zlib.h>
        #   Finally, some C installations use a separate path for headers that
        #   are not part of C or POSIX. zlib is chosen because it has an
        #   excellent chance of being installed by such installations (it's
        #   not only commonly used by itself, it's also a dependency of lots
        #   of other things).
        #
        # We use the resulting search paths to find header files that have
        # been specified in a way that omits the directory. This makes
        # programs much more portable, because the directory they expect to
        # find a header in isn't always the directory it's actually in.
        generate_search_test_file => {
            command => [
                'intcmd:writefile', 'optpath::bpath:aimake/aimake_1.c',
                'optstring:' .
                '#ifdef_AIMAKE11 #include_<iso646.h> #endif ' .
                '#ifdef_AIMAKE12 #include_<limits.h> #endif ' .
                '#ifdef_AIMAKE13 #include_<sys/types.h> #endif ' .
                '#ifdef_AIMAKE14 #include_<setjmp.h> #endif ' .
                '#ifdef_AIMAKE15 #include_<zlib.h> #endif ' .
                'int_main(void)_{return_0;}'],
            output => 'bpath:aimake/aimake_1.c',
            verb => 'generated',
            low_message_priority => 1,
        },
        # We rely on the compiler specifying the header file we included as
        # the first dependency that contains its name. This seems pretty
        # likely, really.
        standard_searchpaths => {
            output => 'searchpath:systeminclude',
            outdepends => [],
        },
        locate_compiler_provided_include_path => {
            object => 'searchpath:systeminclude',
            command => ['tool:c_dependencies', 'bpath:aimake/aimake_1.c',
                        'optpath::bpath:aimake/aimake_1.c',
                        'optstring:-DAIMAKE11'],
            linesep => ' ', linemax => 1, unescape => 'backslash_whitespace',
            filter => qr/\biso646\.h\b/s,
            depends => 'optpath::',
            inner => qr/^(.+)\biso646\.h/s,
        },
        locate_compiler_patched_include_path => {
            object => 'searchpath:systeminclude',
            command => ['tool:c_dependencies', 'bpath:aimake/aimake_1.c',
                        'optpath::bpath:aimake/aimake_1.c',
                        'optstring:-DAIMAKE12'],
            linesep => ' ', linemax => 1, unescape => 'backslash_whitespace',
            filter => qr/\blimits\.h\b/s,
            depends => 'optpath::',
            inner => qr/^(.+)\blimits\.h/s,
        },
        locate_multiarch_include_path => {
            object => 'searchpath:systeminclude',
            command => ['tool:c_dependencies', 'bpath:aimake/aimake_1.c',
                        'optpath::bpath:aimake/aimake_1.c',
                        'optstring:-DAIMAKE13'],
            linesep => ' ', linemax => 1, unescape => 'backslash_whitespace',
            filter => qr/\bsys.*?types\.h\b/s,
            depends => 'optpath::',
            inner => qr/^(.+)\bsys.*?types\.h/s,
        },
        locate_libc_include_path => {
            object => 'searchpath:systeminclude',
            command => ['tool:c_dependencies', 'bpath:aimake/aimake_1.c',
                        'optpath::bpath:aimake/aimake_1.c',
                        'optstring:-DAIMAKE14'],
            linesep => ' ', linemax => 1, unescape => 'backslash_whitespace',
            filter => qr/\bsetjmp\.h\b/s,
            depends => 'optpath::',
            inner => qr/^(.+)\bsetjmp\.h/s,
        },
        locate_non_libc_include_path => {
            object => 'searchpath:systeminclude',
            command => ['tool:c_dependencies', 'bpath:aimake/aimake_1.c',
                        'optpath::bpath:aimake/aimake_1.c',
                        'optstring:-DAIMAKE15'],
            linesep => ' ', linemax => 1, unescape => 'backslash_whitespace',
            filter => qr/\bzlib\.h\b/s,
            depends => 'optpath::',
            inner => qr/^(.+)\bzlib\.h/s,
        },

        find_headers => {
            object => qr/^searchfile:/s,
            command => ['intcmd:listtree', 'optpath::',
                        'searchpath:systeminclude', 'optstring:2'],
            output => qr/^(.+)$/s,
            verb => 'found',
            low_message_priority => 1,
            information_only => 1,
        },

        # We'd like to find libraries the same way we find headers. (Why not
        # simply ask gcc where the libraries are? It has a command-line option
        # to do that, but the output is incorrect, and only useful for finding
        # libgcc.a in particular, as far as I can tell.) However, unlike with
        # the headers, we have lists of relevant libraries in the options
        # already. So to locate them, we run ld, via the compiler, specifying
        # -Wl,-t (--verbose would produce easier-to-parse output, but isn't
        # portable). This gets the linker to tell us where it found each
        # library. It'll also tell us about the system's libcs, so we don't
        # need to specify those.
        #
        # With GNU ld's and gold's --verbose we can test any number of files
        # at once; if it errors, it keeps going. However, this doesn't work
        # using Darwin ld (which requires -t); it produces no useful output
        # on error. Thus, we run on each library independently. (This is why
        # the searchlib: object type is needed; it can't be done with an
        # optionset because that would not allow looping over the libraries.)
        generate_library_test_object_file => {
            object => 'bpath:aimake/aimake_1.c',
            command => ['tool:c_compiler', 'optpath::', '',
                        "optpath:-o :bpath:aimake/aimake_1$objext"],
            output => "bpath:aimake/aimake_1$objext",
            verb => 'built',
            low_message_priority => 1,
        },
        find_libraries => {
            object => qr/^searchlib:/,
            command => ['tool:c_linker', "bpath:aimake/aimake_1$objext",
                        "optpath::bpath:aimake/aimake_1$objext",
                        "optpath:-o :bpath:aimake/aimake_1$exeext",
                        'optpath:-l:',
                        'optstring:-Wl,-t'],
            # We're looking at the linker's trace output to locate
            # libraries. -t prints each found object file on its own
            # line on stderr. We recognise the object files via the
            # extension, and the fact that they're existing, binary
            # files.
            output => qr/^(.*(?<!aimake_1)(?:\.a|\Q$objext\E|\Q$dllext\E)(?:\.[0-9]+)?)$/s,
            filter_text_files => 1,
            filter_nonexistent_files => 1,
            force_locale => 'C',
            verb => 'found',
            fail_silently => 2,
            also_match_stderr => 1,
            # can't require_match; if the library doesn't exist on OS X, we
            # get an error output with no matches, and require_match overrides
            # fail_silently (not that it would be useful even if it didn't)
            information_only => 1,
            low_message_priority => 1,
        },

        # An aimake-specific header file that's forced onto every C file.
        generate_aimake_header => {
            command => [
                'intcmd:writefile', 'optpath::bpath:aimake/aimake_1.h',
                'optstring:' .
                '#ifndef_AIMAKE\_HEADER\_INCLUDED ' .
                '#_define_AIMAKE\_HEADER\_INCLUDED ' .
                "#_define_AIMAKE\_BUILDOS\_$^O_1",
                'optionset:aimake_header_lines',
                'optstring:#endif'],
            output => 'bpath:aimake/aimake_1.h',
            verb => 'generated',
            low_message_priority => 1,
        },
        default_aimake_header_lines => {
            output => 'optionset:aimake_header_lines',
            outdepends => [],
        },

        # Compiling C and C++.
        c_compiler_tool => {
            output => 'tool:c_compiler',
            outdepends => ['cmd:gcc', 'optionset:CFLAGS', 'optstring:-c'],
            verb => 'found',
        },
        cxx_compiler_tool => {
            output => 'tool:cxx_compiler',
            outdepends => ['cmd:gcc', 'optionset:CXXFLAGS', 'optstring:-c'],
            verb => 'found',
        },
        c_cxx_dependencies_tool => {
            output => 'tool:c_dependencies',
            outdepends => ['cmd:gcc', 'optstring:-M -MG',
                           'optionset:IFLAGS'],
            verb => 'found',
        },
        c_cxx_preprocess_tool => {
            output => 'tool:c_preprocessor',
            outdepends => ['cmd:gcc', 'optstring:-E', 'optionset:IFLAGS'],
            verb => 'found',
        },
        ch_file_dependencies => {
            object => qr/^b?path:(?!aimake\/).*\.[ch](?:xx)?$/s,
            command => ['tool:c_dependencies', 'optpath::'],
            # A little aimake magic here: this outputs relative paths for
            # non-found files, and those become file: objects, whereas
            # absolute paths for files it did find will become the appropriate
            # sort of object (most likely path: or spath:).
            linesep => ' ',
            lineskip => 2, # output file, input file
            unescape => 'backslash_whitespace',
            depends => qr/^(.+)$/s,
            filter_spath => 1,
        },
        ch_file_searchfiles => {
            object => qr/^b?path:(?!aimake\/).*\.[ch](?:xx)?$/s,
            command => ['tool:c_dependencies', 'optpath::'],
            linesep => ' ', lineskip => 2, unescape => 'backslash_whitespace',
            output => qr/^(.+)$/s,
            outdepends => [],
            propagate_usedeps => 2,
            filter_absolute => 1,
            output_as_searchfile => 1,
        },
        # We can't just put config options in aimake_1.h, like we do for the
        # other aimake defines, because we need dependencies on them from the
        # config options.
        ch_embedded_aimake_option => {
            object => qr/^b?path:(?!aimake\/).*\.[ch](?:xx)?$/s,
            command => ['intcmd:cat', 'optpath::'],
            depends => 'config_option:',
            dependsarg => qr'AIMAKE_OPTION_([a-zA-Z0-9_]+)',
        },
        embedded_aimake_option_define => {
            object => qr/^config_option:/,
            command => ['intcmd:optionvalues', 'optpath::'],
            depends => 'optstring:-DAIMAKE_OPTION_',
            dependsarg => qr/^(.*)$/,
        },
        header_files_are_files => {
            object => qr/^[bs]?path:.*\.h(?:xx)?/,
            command => ['intcmd:echo', 'optpath::'],
            output => 'file:',
            outputarg => qr/^[bs]?path:
              (?:(?:[^\\]|\\.)+\/)?((?:[^\\\/]|\\.)+?)$/x,
            outdepends => 'optpath:-I :extend:..:',
            propagate_usedeps => 1,
        },
        compile_c => {
            object => qr/^b?path:(?!aimake\/).*\.c$/s,
            # Double-extend the filename, in case we have a C and C++ source
            # file with the same basename.
            command => ['tool:c_compiler', 'optpath::',
                        "optpath:-o :extend:_c$objext:"],
            output => "extend:_c$objext:",
            verb => 'compiled',
            in_subdir => 'bpath:', # shorter error/warning messages
        },
        compile_cxx => {
            object => qr/^b?path:(?!aimake\/).*\.cxx$/s,
            # Double-extend the filename, in case we have a C and C++ source
            # file with the same basename.
            command => ['tool:cxx_compiler', 'optpath::',
                        "optpath:-o :extend:_cxx$objext:"],
            output => "extend:_cxx$objext:",
            verb => 'compiled',
            in_subdir => 'bpath:', # shorter error/warning messages
        },

        # Shared objects.
        #
        # We detect that a library is wanted using flags in the source code:
        #
        # AIMAKE_EXPORT  This symbol is in a library and should be exported.
        # AIMAKE_IMPORT  This symbol should be imported from a library.
        # AIMAKE_REVERSE_EXPORT  This symbol should be made available to
        #                        libraries that use this code.
        # AIMAKE_REVERSE_IMPORT  This symbol should be imported from users of
        #                        this library into the library itself.
        #
        # Both _EXPORTs become __attribute__((visibility("default"))) on
        # Linux, and __declspec(dllexport) on Windows. The _IMPORTs are no-ops
        # on Linux, and become __declspec(dllimport) on Windows. Mac OS X
        # apparently works the same way as Linux in this respect (it supports
        # "hidden" and "default" visibility the same way Linux does).
        #
        # The syntax in the source file is AIMAKE_EXPORT(symbol), etc.. The
        # reason for this is so that we can identify symbol names that need
        # exporting using the preprocessor (using token pasting and
        # $longrandomstring). Once we find these, we create a symbolset for
        # each based on the stem of the namehints of the symbol. (That way, we
        # don't end up creating duplicate libraries.)

        ch_embedded_aimake_export => {
            object => qr/^b?path:(?!aimake\/).*\.[ch](?:xx)?$/s,
            command => ['tool:c_preprocessor', 'optpath::', 'optstring:-P',
                        "optstring:-DAIMAKE_EXPORT(x)=$longrandomstring##x"],
            output => 'shared_symbol:',
            outputarg => qr/$longrandomstring(\w+)/,
            outdepends => 'symbol:',
            dependsarg => qr/$longrandomstring(\w+)/,
            verb => 'found',
        },
        create_symbolset => {
            object => qr/^shared_symbol:/,
            command => ['intcmd:xuse_statistics', 'optstring:.o'],
            output => 'symbolset:',
            outputarg => qr/^hash=(.*)$/,
            inner => qr/^stem=(.*)$/,
            outdepends => qr/^dependency=shared_(symbol:.*)$/,
            avoid_rules => qr/^bpath_shared_object_provisions/,
            verb => 'named',
        },
        link_shared_library => {
            object => qr/^symbolset:/,
            command => ['tool:c_linker', 'optstring:-shared',
                        "optpath:-o :extend:$dllext:"],
            output => "extend:$dllext:",
            avoid_rules => qr/^bpath_shared_object_provisions/,
            verb => 'linked',
        },
        linux_cflags => {
            command => ['intcmd:assert_equal',
                        'optstring:linux', "optstring:$^O"],
            fail_silently => 1,
            object => qr/^optionset:C(?:XX)?FLAGS$/,
            depends => 'optstring:-fvisibility=hidden',
        },
        linux_lflags => {
            command => ['intcmd:assert_equal',
                        'optstring:linux', "optstring:$^O"],
            fail_silently => 1,
            object => 'optionset:LFLAGS',
            depends => 'optstring:-rdynamic',
        },
        linux_headerlines => {
            command => ['intcmd:assert_equal',
                        'optstring:linux', "optstring:$^O"],
            fail_silently => 1,
            object => 'optionset:aimake_header_lines',
            depends => 'optstring:' .
                '#_define_AIMAKE\\_IMPORT(x)_x ' .
                '#_define_AIMAKE\\_REVERSE\\_IMPORT(x)_x ' .
                '#_define_AIMAKE\\_EXPORT(x)_\\_\\_attribute\\_\\_(('.
                'visibility("default")))_x '.
                '#_define_AIMAKE\\_REVERSE\\_EXPORT(x)_\\_\\_attribute\\_\\_(('.
                'visibility("default")))_x'
        },
        osx_cflags => {
            command => ['intcmd:assert_equal',
                        'optstring:darwin', "optstring:$^O"],
            fail_silently => 1,
            object => qr/^optionset:C(?:XX)?FLAGS$/,
            depends => 'optstring:-fvisibility=hidden',
        },
        osx_lflags => {
            command => ['intcmd:assert_equal',
                        'optstring:darwin', "optstring:$^O"],
            fail_silently => 1,
            object => 'optionset:LFLAGS',
            depends => 'optstring:-rdynamic',
        },
        osx_headerlines => {
            command => ['intcmd:assert_equal',
                        'optstring:darwin', "optstring:$^O"],
            fail_silently => 1,
            object => 'optionset:aimake_header_lines',
            depends => 'optstring:' .
                '#_define_AIMAKE\\_IMPORT(x)_x ' .
                '#_define_AIMAKE\\_REVERSE\\_IMPORT(x)_x ' .
                '#_define_AIMAKE\\_EXPORT(x)_\\_\\_attribute\\_\\_(('.
                'visibility("default")))_x '.
                '#_define_AIMAKE\\_REVERSE_EXPORT(x)_\\_\\_attribute\\_\\_(('.
                'visibility("default")))_x'
        },

        # Selecting sensible names.
        #
        # This is used for shared objects and for executables. When selecting
        # a sensible name for an object, we base it on the bpath objects that
        # contain initialized read/write data, as a crude heuristic to
        # distinguish programs from library functions. (Library functions
        # rarely work on a single, centralized copy of data because that
        # causes a lack of re-entrancy. Read-only data doesn't count for this
        # purpose; and uninitialized data is possibly a static buffer, which
        # is a much more common way to lack re-entrancy than initialized
        # data.) Additionally, a symbol "main" or "_main" automatically gets
        # your name hinted, and exported symbols get their names hinted when
        # creating shared libraries.
        choose_namehint => {
            object => qr/^bpath:.*\Q$objext\E$/,
            depends => 'namehint:',
            command => ['cmd:nm', 'optpath::'],
            # In order to conditionally include the namehint, we use a regex
            # match that captures nothing. If it doesn't match, there'll be no
            # capture and thus no hint. (The hint itself is provided by the
            # implicit inner => ''.)
            dependsarg => qr'^()[[:xdigit:]]*\s+(?:[tT] _?main|[dDgG])',
            verb => 'chose',
        },

        # Linking.
        c_link_tool => {
            output => 'tool:c_linker',
            outdepends => ['cmd:gcc', 'optionset:LFLAGS'],
            verb => 'found',
        },
        oa_file_dependencies => {
            # Note that this only matches the bpath, not the spath.
            object => qr/^bpath:.*(?:\Q$objext\E|\Q$libext\E)$/,
            command => ['cmd:nm', 'optpath::'],
            depends => 'symbol:',
            # To make things work on Windows, omit symbols that start with a
            # double underscore, and translate DLL import hooks (__imp_.*) to
            # the function being imported.
            dependsarg => qr'^[[:xdigit:]]*\s+U (?:__imp_)?((?>_?[a-zA-Z0-9\$][a-zA-Z0-9_\$]*))',
        },
        o_file_provisions => {
            object => qr/^b?path:(?!aimake\/).*\Q$objext\E\z/,
            command => ['cmd:nm', 'optpath::'],
            output => ['symbol:', 'symbol_in_object:'],
            # [ABCDGRSTVWiI] are all the externally visible symbols. (Capital
            # I is used on Windows for DLL exports; normally there's a __imp_
            # with an I and a non-prefixed version of a function with a T, but
            # for variables, only the I exists, so we need to remove the
            # __imp_ ourself.)
            outputarg => qr'^[[:xdigit:]]*\s+[ABCDGRSTVWiI] (?>(?:__imp_)?)((?>[a-zA-Z0-9_$]+))',
            # inner => '' is implied, as with the next few rules
            # outdepends => '' is implied by propagate_usedeps
            outdepends => 'optpath::',
            verb => 'found',
            propagate_usedeps => 1,
            preference => 80,
        },
        a_file_provisions => {
            object => qr/^spath:.*\Q$libext\E\z/s,
            command => ['cmd:nm', 'optpath::'],
            output => ['symbol:', 'symbol_in_object:'],
            outputarg => qr'^[[:xdigit:]]*\s+[ABCDGRSTVWiI] (?>(?:__imp_)?)((?>[a-zA-Z0-9_$]+))',
            ignore_warnings => 1,
            outdepends => [],
            verb => 'found',
            propagate_usedeps => 1,
            low_message_priority => 1,
            preference => 30,
        },
        shared_object_provisions_nondynamic => {
            object => qr/^s?path:.*\Q$dllext\E(?:\z|\.)/s,
            command => ['cmd:nm', 'optpath::'],
            output => ['symbol:', 'symbol_in_object:'],
            outputarg => qr'^[[:xdigit:]]*\s+[ABCDGRSTVWiI] (?>(?:__imp_)?)((?>[a-zA-Z0-9_$]+))',
            ignore_warnings => 1,
            propagate_usedeps => 1,
            outdepends => [],
            verb => 'found',
            low_message_priority => 1,
            preference => 50,
        },
        shared_object_provisions_dynamic => {
            object => qr/^s?path:.*\Q$dllext\E(?:\z|\.)/s,
            command => ['cmd:nm','optstring:-D','optpath::'],
            output => ['symbol:', 'symbol_in_object:'],
            outputarg => qr'^[[:xdigit:]]*\s+[ABCDGRSTVWiI] (?>(?:__imp_)?)((?>[a-zA-Z0-9_$]+))',
            fail_silently => 1, # not everything is dynamic
            ignore_warnings => 1,
            propagate_usedeps => 1,
            outdepends => [],
            verb => 'found',
            low_message_priority => 1,
            preference => 50,
        },
        bpath_shared_object_provisions_nondynamic => {
            object => qr/^bpath:.*\Q$dllext\E(?:\z|\.)/s,
            command => ['cmd:nm', 'optpath::'],
            output => ['symbol:', 'symbol_in_object:'],
            outputarg => qr'^[[:xdigit:]]*\s+[ABCDGRSTVWiI] (?>(?:__imp_)?)((?>[a-zA-Z0-9_$]+))',
            ignore_warnings => 1,
            propagate_usedeps => 1,
            outdepends => [],
            verb => 'found',
            low_message_priority => 1,
            preference => 90,
        },
        bpath_shared_object_provisions_dynamic => {
            object => qr/^bpath:.*\Q$dllext\E(?:\z|\.)/s,
            command => ['cmd:nm','optstring:-D','optpath::'],
            output => ['symbol:', 'symbol_in_object:'],
            outputarg => qr'^[[:xdigit:]]*\s+[ABCDGRSTVWiI] (?>(?:__imp_)?)((?>[a-zA-Z0-9_$]+))',
            fail_silently => 1, # not everything is dynamic
            ignore_warnings => 1,
            propagate_usedeps => 1,
            outdepends => [],
            verb => 'found',
            low_message_priority => 1,
            preference => 90,
        },
        spath_library_option => {
            object => qr/^spath:.*(?:\Q$dllext\E|\Q$libext\E)(?:\z|\.)/,
            command => ['intcmd:echo', 'optpath::'],
            depends => 'optstring: -l',
            # Libraries on the spath which are not lib* get no option; they
            # probably don't get generated in the first place (apart from
            # the dynamic loader, which shouldn't be mentioned anyway)
            dependsarg => qr/^[bs]?path:
                (?:(?:[^\\]|\\.)+\/)?lib((?:[^\\\/]|\\.)+?)
                (?:\Q$dllext\E|\Q$libext\E)(\z|\.)/x,
        },
        bpath_library_option => {
            object => qr/^bpath:.*\Q$dllext\E(?:\z|\.)/,
            depends => ['optpath::', 'optionset:rpath']
        },
        linux_rpath => {
            # We set the rpath to the installed location for the shared
            # objects. We can't know if it'll be libdir or specificlibdir,
            # so we do both.
            output => 'optionset:linux_rpath',
            command => ['intcmd:optionvalues',
                        'optpath::config_option:libdir',
                        'optpath::config_option:specificlibdir'],
            outdepends => 'optpath:-Wl,-rpath=:',
            inner => qr/=(.*)$/,
        },
        linux_bpath_library_option => {
            command => ['intcmd:assert_equal',
                        'optstring:linux', "optstring:$^O"],
            fail_silently => 1,
            output => 'optionset:rpath',
            outdepends => 'optionset:linux_rpath',
        },
        link_c => {
            object => qr/^b?path:.*\Q$objext\E/,
            command => ['symbol_in_object:main:', 'tool:c_linker',
                        'optpath::', "optpath:-o :extend:$exeext:"],
            output => "extend:$exeext:",
            verb => 'linked',
            in_subdir => 'bpath:',
        },
        # Some compilers add an extra underscore to everything. No problem,
        # we'll just link files with a _main too. (This causes issues if a
        # file has both a _main and a main, but in such a case, we're in
        # trouble anyway.)
        link_mangled_c => {
            object => qr/^b?path:.*\Q$objext\E/,
            command => ['symbol_in_object:_main:', 'tool:c_linker',
                        'optpath::', "optpath:-o :extend:$exeext:"],
            output => "extend:$exeext:",
            verb => 'linked',
            in_subdir => 'bpath:',
        },

        # lex, yacc
        # For the time being we only support the GNU flex/bison, due to
        # traditional lex's nasty habit of using hardcoded filenames.
        lex_tool => {
            output => 'tool:lex',
            outdepends => ['cmd:flex'],
            verb => 'found',
        },
        compile_lex => {
            object => qr/^b?path:.*\.l$/,
            # Double-extend the filename to avoid potential clashes. Also note
            # the use of -o (with no space) here; GnuWin32 flex does not
            # support the --outfile= syntax, so that's the most portable
            # option.
            command => ['tool:lex', 'optpath::', 'optpath:-o:extend:_l.c:'],
            output => 'extend:_l.c:',
            verb => 'generated',
        },

        yacc_tool => {
            output => 'tool:yacc',
            outdepends => ['cmd:bison'],
            verb => 'found',
        },
        compile_yacc => {
            object => qr/^b?path:.*\.y$/,
            # Again, the C file needs extension, in case the project has files
            # file.y and file.l. The header file mustn't have an internal
            # extension, because it's probably referred to by name.
            command => ['tool:yacc', 'optpath::', 'optpath:-o :extend:_y.c:',
                        'optpath:--defines=:extend:.h:'],
            output => ['extend:_y.c:', 'extend:.h:'],
            verb => 'generated',
        },

        # Installing. Some projects may wish to modify or undef out these rules.
        install_libraries => {
            object => qr/^bpath:.*\Q$dllext\E$/s,
            install_dir => "libdir",
        },
        install_executables => {
            object => qr/^bpath:.*\Q$exeext\E$/s,
            install_dir => "bindir",
        },
    },
}
