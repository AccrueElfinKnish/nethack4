About this document:
Last modified by Alex Smith, 2013-11-23

This document documents the version of the network protocol used in
NetHack 4.3, and was written by Daniel Thaler, GreyKnight, Alex Smith.

This document is licensed under the NetHack General Public License.  See
libnethack/dat/license for details.


NetHack 4 Network Protocol
==========================

Basics
======

The protocol is based on JSON.  Each command and each response is a single,
valid JSON object in UTF8 encoding.

The server protocol is an enhancement of the protocol used by a window port to
connect to a local game; the two are very similar, and so this documentation
may also be consulted to gain some amount of understanding of the behaviour of
a windowport.  There are a few commands that are specific to server use,
though, suh as `auth`, and the API for map updates is different.

The following types are all special cases of integers:
* All enumerated types
* bitflags
* boolean
* charcode
* connid
* coordinate
* gameid


Interaction
===========

Once the client has connected to the server, it must send either an `auth` or
a `register` command.  If the client sends a successful register command, a
following `auth` command is not necessary.  When the client is authenticated
any other command may be sent to the server.

Normal flow is driven by the client and/or server sending commands and
receiving responses to them; a command can be sent from the client to the
server, or (more rarely) the other way round.  (Server commands are sent if
the server needs more information to fulfil a client command, or to inform the
client of unusual conditions, such as a retroactive cancel of a command in
progress.)  Server commands and responses can also carry an attached `display`
element with map updates (see later in this document).

In general, a command might be sent/received by the client and/or server at
any point after the authentication.  It is thus incorrect for a client to
block on user input, because it might have to handle a server command that
arrives unexpectedly.

It is also incorrect to block on the response to a command, because a command
might be followed up by another command rather than a response.  It is
acceptable, however, for the client to ignore user input after sending a
command, until either a command or a response is received; whenever a command
is sent, the client can assume that the server will react to it in some way,
either via responding or via sending a followup command.

Commands and responses are always well-nested; if a response is sent, it will
be to the most recent unresponded command sent by the other end of the
connection.  Additionally, messages usually alternate between client and
server.  Currently, the only exception to this is the `cancel_server_request`
command that the server uses to countermand a server request; it can be sent
by the server even if the previous message was also sent by the server.


Client commands
===============

These commands are sent by the client, expecting a response from the server.


auth
----

Either `auth` or `register` must always be the first command sent, and no
other commands may be sent until the original `auth` or `register` command
receives a response.

This command is specific to client/server communication, and is not used for
local play.  It specifies which user is making the connection, and whether to
start a new connection or attempt to re-establish an existing connection.

Upon creating a new connection, there will be no game loaded: `start_game` or
`restore_game` will need to be used before commands that require a game to be
loaded will work.  Re-establishing an existing connection will leave it in
whatever state it was in before the connection went down.

Command arguments:
  * `string username`: the username of the user who is making the connection
  * `string password`: the password of the user who is making the connection
  * `connid reconnect (optional)`: the connection ID of a connection to
    re-establish

Response arguments:
  * `connid connection`: an ID that can be used to re-establish this connection
    if it breaks
  * `enum authresult return`: whether the connection succeeded:
      * `NO_CONNECTION` = 0: the given connection ID does not exist
      * `AUTH_FAILED_UNKNOWN_USER` = 1: the given user does not exist
      * `AUTH_FAILED_BAD_PASSWORD` = 2: the given password is wrong
      * `AUTH_SUCCESS_NEW` = 3: a new connection was created
      * `AUTH_SUCCESS_RECONNECT` = 4: `reconnect` was re-established
  * `int[3] version`: the version number of the server
      * [0] The major version number (if it's not 4, this document is probably
        inaccurate)
      * [1] The minor version number (changes when save compatibility breaks)
      * [2] The patchlevel version number (changes when a release is made that
        does not break save compatibility)

TODO: What happens if this command is sent when a connection already exists?


register
--------

Like `auth`, except it requires a nonexistent rather than existing username,
and will create an account.  This cannot re-establish an existing connection,
for obvious reasons.

Command arguments:
  * `string username`: the username for the new account
  * `string password`: the password to register the account with
  * `string email`: (optional) an email address to store in the database; the
    server admin can use this for password reset requests, etc.

Response arguments: same as `auth`, except `AUTH_FAILED_UNKNOWN_USER` means
that the user account already exists.


describe_pos
------------

Returns farlook information for a given map square.  This command may only be
meaningfully sent while a game is running, and corresponds to the
`nh_describe_pos` API call in libnethack.  If the game is not running, all
string values in the response will be the null string, `objcount` will be -1,
and `in` will be false.

Command arguments:
  * `boolean is_in`: Whether to return the `in` element in the response
  * `coordinate x`: x coordinate of the map square to farlook
  * `coordinate y`: y coordinate of the map square to farlook

Response arguments:
  * `string bgdesc`: a description of the background
  * `string effectdesc`: a description of an effect
  * `boolean in`: true if an object is "in" rather than "on" the background
  * `string invisdesc`: a description of a remembered invisible monster
  * `string mondesc`: a description of a monster
  * `int objcount`: the number of object stacks on the square
  * `string objdesc`: a description of an object
  * `string trapdesc`: a description of a trap

Strings in the response are zero-length if they would describe something that
does not exist on the map square given by (x,y) (or that the character is
unaware of), e.g. `trapdesc` for a square with no known trap.  Otherwise, they
describe the map square given by (x,y).


exit_game
---------

Causes the game to stop running, either via saving/suspending it, or via
quitting it.  `EXIT_FORCE_SAVE` is equivalent to just dropping the connection
in terms of its user-visible effect, but is kinder on server resources than
dropping the connection would be.  This command can be sent if there is no
running game, but does nothing but return true in that situation.  It
corresponds to the `nh_exit_game` API call in libnethack.

Command arguments:
  * `enum nh_exit_types exit_type`: what sort of exit to perform
      * `EXIT_REQUEST_SAVE` = 0: ask the user whether to save, save if yes
      * `EXIT_FORCE_SAVE` = 1: just save and exit the game without prompting
      * `EXIT_REQUEST_QUIT` = 2: ask the user whether to quit, quit if yes
      * `EXIT_FORCE_QUIT` = 3: just quit without saving or prompting
      * `EXIT_PANIC` = 4: panic the process that handles the connection, with
        an error message and record in the panic log (equivalent to
        `EXIT_FORCE_SAVE` in terms of user-visible effect on the game itself)

Response arguments:
  * `boolean return`: true if the game exited (whether due to a save, to a
    quit, or to the process being panicked); false if the user cancelled the
    exit


game_command
------------

This command is used to send player input to the server; the client is
responsible for translating the input into a game command.  Use `get_commands`
in a client in order to determine which commands exist.

This command corresponds to the `nh_command` API call in libnethack.

Command arguments:
  * `string command`: what the player wants to tell their character to do
  * `struct nh_cmd_arg arg`: an argument to the command
      * `unsigned argtype`: what sort of argument is provided:
          * `CMD_ARG_NONE` = 2: no argument
          * `CMD_ARG_DIR` = 4: a direction
          * `CMD_ARG_POS` = 8: a position
          * `CMD_ARG_OBJ` = 16: an inventory letter
      * `enum nh_direction d`: a direction argument (provided iff `argtype` is
        4)
          * `DIR_W` = 0: west (`h`, `4`)
          * `DIR_NW` = 1: northwest (`y`, `7`)
          * `DIR_N` = 2: north (`k`, `8`)
          * `DIR_NE` = 3: northeast (`u`, `9`)
          * `DIR_E` = 4: east (`l`, `6`)
          * `DIR_SE` = 5: southeast (`n`, `3`)
          * `DIR_S` = 6: south (`j`, `2`)
          * `DIR_SW` = 7: southwest (`b`, `1`)
          * `DIR_UP` = 8: up (`<`)
          * `DIR_DOWN` = 9: down (`>`)
          * `DIR_SELF` = 10: at self (`.` or `s`)
      * `charcode invlet`: an inventory letter (provided iff `argtype` is 16)
      * `coordinate x`: an x coordinate (provided iff `argtype` is 8)
      * `coordinate y`: a y coordinate (provided iff `argtype` is 8)
  * `int count`: a numeric prefix to the command (which often but not always
    represents a repeat count; the meaning depends on the command); should be
    0 to continue a multi-turn command, or -1 to interrupt a multi-turn command

Response arguments:
  * `enum nh_input_status return`: What state the game was left in as a result
    of running the command:
      * `READY_FOR_INPUT` = 0: The game is ready to accept another command;
      * `MULTI_IN_PROGRESS` = 1: An action is currently being repeated due to
        a nonzero count; the `nh_command` call should be repeated with a count
        of 0 or -1;
      * `OCCUPATION_IN_PROGRESS` = 2: An interruptible multi-turn action is in
        progress; the `nh_command` call should be repeated with a count of 0
        (TODO: should we allow interrupting these? The main game library
        currently disallows that, as does the client, but it seems weird to
        allow monsters to interrupt something that the player can't interrupt
        from the keyboard);
      * `POST_ACTION_DELAY` = 3: The player was left helpless as a result of
        their action; the client should repeat the call with a count of 0 in
        order to get an update for the next turn;
      * `ERR_NO_INPUT_ALLOWED` = 4: Currently unused (TODO: It would make
        sense to use this if the player attempts to run a command while at a
        prompt, something which the code doesn't seem to disallow at the
        moment, but which it definitely should);
      * `ERR_COMMAND_FORBIDDEN` = 5: You cannot provide input to this game,
        either because it's not your game (and you're watching/replaying it
        rather than playing it), or because you're looking at a past rather
        than current state of the game (because you're replaying it);
      * `GAME_OVER` = 6: The game ended as a result of the command (if it
        wasn't a quit, then the player died), and is no longer running;
      * `GAME_SAVED` = 7: The game saved as a result of the command (probably
        because it was the save command), and is no longer running;
      * `GAME_PANICKED` = 8: Something went wrong trying to handle the
        command; the game is no longer running, and its save file may need
        recovery;
      * `ERR_FORCED_EXIT` = 9: The game was saved or exited via the
        `exit_game` client command;
      * `ERR_GAME_NOT_RUNNING` = 10: There was no game running, either because
        `start_game` / `restore_game` weren't called, or because the game has
        been saved/exited/panicked, or possibly due to a panic outside the
        `game_command` call;
      * `ERR_NETWORK_ERROR` = 20000: Something went wrong trying to send the
        command to the server.

The order of these enum returns groups them according to the response the
client should take:

  * 0: Prompt the user for another command;
  * 1-3: Repeat the command with the count set to 0 or -1;
  * 5: Complain that the command is invalid, and ask for another command;
  * 6+: Exit the main "in-game" loop and go back to the main menu.

(`ERR_NO_INPUT_ALLOWED` will only be sent by the server in response to a bug
in the client; a client's correct response to this is probably to panic.)

TODO: We should probably have a separate continue_command call for continuing
commands, rather than the current magic interpretation of `count`.


get_commands
------------

This command lists which commands exist and can be used in a `game_command`
call, and corresponds to the `nh_get_commands` API call in libnethack.  (TODO:
It currently doesn't have a check for whether the game is running, which it
needs because it looks at whether the game is in debug mode or not.  It should
probably always list debug mode commands, with the client deleting the ones
that won't do anything useful.)

In addition to information about the commands, it also returns default
keybindings for them; clients can choose to respect or ignore these.  This
means that minor changes to the game's commands can be made without needing to
alter clients.

Command arguments: none

Response arguments:
  * `struct nh_cmd_desc cmdlist`: a list of the commands that exist:
      * `string name`: the name of the command (`command` in `game_command`);
      * `string desc`: a human-readable description of the command;
      * `unsigned flags`: information about the command, a bitmask of:
          * `CMD_ARG_NONE` = 2: the command's argument can be omitted (and if
            no other `CMD_ARG_*` flags are set, must be omitted);
          * `CMD_ARG_DIR` = 4: the command can accept a direction argument;
          * `CMD_ARG_POS` = 8: the command can accept a position argument;
          * `CMD_ARG_POS` = 16: the command can accept an inventory object
            argument;
          * `CMD_EXT` = 1024: it is recommended that by default, this command
            should be available as an extended command (via `#`);
          * `CMD_MOVE` = 2048: this is a movement command (and thus it is not
            unreasonable to be able to keybind to individual direction
            arguments to this command);
          * `CMD_HELP` = 4096: it is recommended that by default, this command
            should be available via the help menu on `?`;
          * `CMD_NOTIME` = 8192: this command makes no changes to the
            gamestate, and thus can be used while watching or replaying a
            game;
          * `CMD_DEBUG` = 16384: this command is only available in debug mode.
      * `charcode def`: a default keybinding for this command (ASCII,
        control-ASCII, meta-ASCII);
      * `charcode alt`: another, lower-priority, default keybinding for this
        command


get_obj_commands
----------------

Requests a list of reasonable commands for use with a specified inventory
item.  (TODO: This is missing a check on whether the game is running.)  This
command is intended for use in response to an item being selected from the
inventory menu, itemactions-style; it will give more specific explanations of
what the commands do than `get_commands` does, because it is specialised to
one object.

Command arguments:
  * `charcode invlet`: The inventory letter of the item to get commands for.

Response arguments: the same as `get_commands`.

Note that unlike `get_commands`, which can recommend control- or meta-modified
keys for its keybindings, `get_obj_commands` favours capital and lowercase
letters only, so that its keybindings can easily be placed in a menu.  This
means that the recommended keybindings may not be identical to those produced
via `get_commands`.


get_drawing_info
----------------

Requests information about what drawable entities exist in the game: most code
that communicates display information will return indexes into lists, and this
function returns those lists.  It contains both API names, and default ASCII
representations (these need to be available to the server anyway so that it
can produce dumplogs, so it may as well communicate these to the client in
case it wants to use them).  It is reasonable to call this even when the game
is not running.  This command corresponds to the `nh_get_drawing_info` API
call in libnethack.

TODO: Sending an array and its length separately over JSON is always a bad
idea; what if they don't match? There's currently a `int num_*` for each
`struct nh_symdef[]` in the response arguments, but I removed the
documentation for them in preparation for fixing this rather major issue.

Command arguments: none

Response arguments:
  * `int feature_offset`:
  * `struct nh_symdef[] bgelements`: Backgrounds.
  * `struct nh_symdef[] effects`: Effects.
  * `struct nh_symdef[] explsyms`: Explosion shape/locations.
  * `struct nh_symdef[] expltypes`: Explosion appearances.
  * `struct nh_symdef[] invis`: Memory of invisible monsters.
  * `struct nh_symdef[] monsters`: Monsters.
  * `struct nh_symdef[] objects`: Items.
  * `struct nh_symdef[] swallowsyms`: The inside of an engulfing monster.
  * `struct nh_symdef[] traps`: Traps.
  * `struct nh_symdef[] warnings`: Warning symbols.
  * `struct nh_symdef[] zapsyms`: Zap shape/locations.
  * `struct nh_symdef[] zaptypes`: Zap appearances.
  
where `struct nh_symdef[]` is defined as follows (and sent as an array, with
its fields in this order):
  * `string name`: The API name of a drawable entity.  Explosions and zaps
    have two API names; one for the shape and location within the shape (the
    `*syms` list), one for the appearance (the `*types` list).  Other drawable
    entities have just the one API name.  Clients should feel free to hardcode
    overrides for specific API names.  (Note that an API name is not always
    the same as a tile name; use the functions in tilesequence.c if you need
    to convert, e.g. to discover a tile number for a given API name.)
  * `charcode character`: A recommended ASCII representation of this drawable
    entity.  Clients can use this as a fallback if they encounter an
    unrecognised API name.
  * `colourcode colour`: A recommended color for this drawable entity.

When using the recommended ASCII representations, for explosions and zaps
(which have two API names), the character should be taken from the
shape/location field, and the color from the appearance field.


get_options
-----------

Currently under revision.  TODO: When we decide what the API call actually
does, document it properly.

Command arguments:
  * `enum nh_option_list list`: what sort of options to list
      * (values, semantics under revision)

Response arguments:
  * `struct nh_option_desc[] options`:
      * `string name`: short name of the option
      * `string helptxt`: long desription of the option
      * `enum nh_opttype type`: what type of values the option takes:
          * `OPTTYPE_BOOL` = 0: booleans;
          * `OPTTYPE_INT` = 1: integers;
          * `OPTTYPE_ENUM` = 2: a fixed list of possibilities;
          * `OPTTYPE_STRING` = 3: strings;
          * `OPTTYPE_AUTOPICKUP_RULES` = 4: lists of autopickup rules
      * `union nh_optvalue value`: the value (or default value? under revision)
        of the option
      * `union _ desc`: the legal values for the option:
          * `nil` for `OPTTYPE_BOOL`;
          * `struct {int min, int max}` for `OPTTYPE_INT`;
          * list of strings for `OPTTYPE_ENUM`;
          * an integer for strings (reflecting the maximum length);
          * list of strings for autopickup rules (TODO: figure out what format
            these are in)
            
An autopickup rule has the following structure:
  * `enum autopickup action`: what action to take upon encountering this item:
      * `AP_GRAB` = 0: pick it up regardless of `pickup_types`;
      * `AP_LEAVE` = 1: leave it on the ground regardless of `pickup_types`.
  * `enum nh_bucstatus buc`: a filter against beatitude:
      * `B_UNKNOWN` = 0: match only items with unknown beatitude;
      * `B_BLESSED` = 1: match only blessed items;
      * `B_UNCURSED` = 2: match only non-blessed non-cursed items;
      * `B_CURSED` = 3: match only cursed items;
      * `B_DONT_CARE` = 4: do not filter items based on beatitude
  * `int oclass`: an object class of items to match
  * `string pattern`: a regular expression that matches items


set_option
----------

Changes a (non-interface) option on the server.  This corresponds to the
`nh_set_option` API call in libnethack.  TODO: This command should only be
runnable in situations where `game_command` is legal, except possibly for
setting birth options; this needs more thought.

Command arguments:
  * `boolean isstr`: if true, allows sending the option value as a string
    regardless of the option's actual type (the server will parse it into an
    appropriate value for the option); if false, the client has already parsed
    the option
  * `string name`: the name of the option to set
  * `union nh_optvalue value`: the value for the option, in a format depending
    on the option's type and whether `isstr` is set (a string, integer, or
    list of autopickup rules).

Response arguments:
  * `struct nh_option_desc option`: TODO: work out if we need this and what
    its semantics are
  * `int return`: an integer treated as a boolean; nonzero if the option value
    given was reasonable, zero if it was unreasonable (and thus the server did
    not try to set it)


get_roles
---------

Requests information on what roles, races, genders, and alignments exist in
the game, and what combinations of them are legal.  This command corresponds to
the `nh_get_roles` API call in libnethack.

TODO: This API is inherently prone to buffer length mismatches.  There should
not be separate `num_` fields.

Command arguments: none

Response arguments:
  * `string[] alignnames`: the list of alignments that exist
  * `string[] gendnames`: the list of genders that exist
  * `string[] racenames`: the list of races that exist
  * `string[] rolenames_f`: the list of roles that exist, using female names
    such as "Cavewoman" (TODO: if a role has no separate female name, are
    these a copy of the male name, or NULL?)
  * `string[] rolenames_m`: the list of roles that exit, using male names such
    as "Caveman"
  * `int[] matrix`: Information on which combinations of role, race, gender,
    and alignment are legal; each possible combination (legal or illegal) has
    an entry in the list, at an index that can be calculated via the macro
    `nh_cm_idx()`
  * `int num_aligns`: length of `alignnames`
  * `int num_genders`: length of `gendnames`
  * `int num_races`: length of `racenames`
  * `int num_roles`: length of `rolenames_[f,m]`


get_topten
----------

Requests entries from the high score table.

Command arguments:
  * `int around`: if there has been at least one game previously on this
    connection (even if it was re-established), and the most recent such game
    has since reached game over (death/quit/escape/ascension), and `player`
    was playing, list this many games near that game on the high score table;
    otherwise this value is ignored
  * `boolean own`: whether to list all games of the given `player` name or not
  * `string player`: the player name for `own` and `around`; a null string
    will automatically pick the appropriate player for the most recent game
    for use with `around`
  * `int top`: list this many games at the top of the table

Response arguments:
  * `string msg`: an appropriate heading for the high score table; if `around`
    matches, this will talk about the most recent game (e.g. telling the
    player what position on the list they are, or explaining that wizard mode
    games are not eligible for the high score table); otherwise, this will be
    an error message (if any), or else the null string
  * `struct nh_topten_entry[] toplist`: the requested high score table
      * `int birthdate`: seconds since the epoch that the game started (TODO:
        Y2038 issue!)
      * `string death`: the reason that the player died
      * `int deathdate`: seconds since the epoch that the game ended
      * `int deaths`: the number of times the player lifesaved, plus one if they
        eventually died permanently
      * `int end_how`: an internal code for the basic cause of death (drowning,
        starving, etc.); this is currently not in any publicly accessible header
        (TODO: which is probably a mistake), but is in libnethack's hack.h
      * `string entrytxt`: a formatted representation of this high score entry
        that can be output directly in a fixed-width font
      * `boolean highlight`: true if this entry is the one that `around` is
        measuring around
      * `int hp`: the character's current hitpoints at death
      * `int maxhp`: the character's maximum hitpoints at death
      * `int maxlvl`: the deepest dungeon level the character reached
      * `int moves`: the number of turns the charater spent
      * `string name`: the name of the character
      * `string plalign`: the character's alignment
      * `string plgend`: the character's gender
      * `string plrace`: the character's race
      * `string plrole`: the character's role
      * `int points`: the number of points the game scored
      * `int rank`: the position of this game within the high score table (1 for
        first place, 2 for second place, etc.); can be 0 or negative for games
        that are disqualified from the high score table (due to, for instance,
        playing in debug mode)
      * `int ver_major`: the major version number of the engine this game was
        played on
      * `int ver_minor`: the minor version number of the engine this game was
        played on
      * `int patchlevel`: the patchlevel version number of the engine this game
        was played on

list_games
----------

Lists current and/or completed games on the server.

TODO: what format are plgend, etc., in? Abbreviation? Full name?

Command arguments:
  * `boolean completed`: list only completed games if true, only current games
    if false
  * `int limit`: the maximum number of games to list
  * `boolean show_all`: if true, list games even if the user who authenticated
    this connection has only read access to them; if false, only list games to
    which the user has write access

Response arguments:
  * `struct nhnet_game[] games`: the information about the games selected by
    the arguments:
      * `int gameid`: a value that can be given to `restore_game` to connect to
        this game
      * `enum nh_game_modes playmode`: any special rules that might apply to
        this game:
          * `MODE_NORMAL` = 0: there is nothing special about this game;
          * `MODE_EXPLORE` = 1: this game is in non-scoring discovery mode;
          * `MODE_WIZARD` = 2: this game is in debug mode
      * `string plname`: the name of this game's player
      * `string death`: (optional) the reason a completed game ended
      * `int depth`: (optional) the current dungeon level on which the player
        resides
      * `string level_desc`: (optional) a textual description of the current
        dungeon level on which the player resides
      * `boolean has_amulet`: (optional) whether the player of this game has the
        Amulet of Yendor
      * `int moves`: (optional) the number of turns this game has lasted
      * `string plalign`: the alignment of this game's character
      * `string plgend`: the gender of this game's character
      * `string plrace`: the race of this game's character
      * `string plrole`: the role of this game's character
      * `enum nh_log_status status`: the status of this game's save file:
          * `LS_SAVED` = 0: an ordinary save file, nobody playing/replaying
          * `LS_DONE` = 1: game over: quit, died, ascended, etc.
          * `LS_IN_PROGRESS` = 2: someone is playing/watching/replaying this
            game
          * `LS_INVALID` = -1: something is badly wrong with the save file
          * `LS_CRASHED` = -2: the save file needs manual recovery

Arguments marked as (optional) with no elaboration will normally be available,
but might not be if the save file is invalid or requires recovery.


restore_game
------------

Attaches to a game, causing that game to be loaded.  If the game has read
access with the user the connection is authenticated as, and the game is not
completed, the user will be able to play, watch, and/or replay the
game.  Otherwise, the user will only be able to watch and replay the game.

This corresponds to the `nh_restore_game` API call in libnethack.

TODO: This doesn't seem to have checks against a game being in progress.  If
this is called inappropriately, what happens? Everything working fine? Memory
leaK? Or something worse?

Command arguments:
  * `int gameid`: A value returned from `list_games` representing a game to
    attach to

Response arguments:
  * `enum nh_restore_status return`: what happen in the attempt to restore the game:
      * `GAME_RESTORED` = 0: the game was restored successfully, there is now
        a game loaded
      * `ERR_BAD_ARGS` = 1: the given game ID does not exist
      * `ERR_BAD_FILE` = 2: the given game ID corresponds to a file on disk
        that cannot be read
      * `ERR_GAME_OVER` = 3: (previously used on an attempt to resume a
        completed game, no longer generates because this is now a meaningful
        operation, with the game resuming in replay mode)
      * `ERR_IN_PROGRESS` = 4: it is impossible to attach to the game due to
        locking issues; on POSIXy OSes, this should only happen if the file is
        being recovered manually, but on some OSes this may happen if anyone
        else is currently playing the game
      * `ERR_RESTORE_FAILED` = 5: the game is completely corrupted and needs
        manual recovery
      * `ERR_REPLAY_FAILED` = 6: the game is partially corrupted, and the user
        chose not to rewind it when prompted about whether to rewind it


set_email
---------

Change the email address associated with the authenticated user.  (This
address is not used by the game, but is available to server admins in case
they need to verify a uer's identity, e.g. for a password reset request.)

Command arguments:
  * `string email`: the new email address

Response arguments:
  * `boolean return`: true if the email address change succeeded


set_password
------------

Change the password associated with the authenticated user.  The same password
will be required by future `auth` requests.

Command arguments:
  * `string password`: the new password (sent in plaintext, unless the
    connection is encrypted some other way)

Response arrguments:
  * `boolean return`: true if the password change succeeded


shutdown
--------

Exits the server and closes the connection.  (If there is an active game, the
server will attempt to save it before exiting).

Command arguments: none

Response arguments:
  * `int return`: Always 1.


start_game
----------

TODO: The API of this function is under revision.

Command arguments:
  * Under revision

Response arguments:
  * `int gameid`: The game ID, for use with future `restore_game` calls; if
    this is -1, the game creation failed
  * `boolean return`: if this is false, the game creation failed

The game creation succeeded if `gameid` is -1 and `return` has a true value.


Server requests
===============

These requests are sent by the server, expecting a response from the client.
Normally they will only be sent as followups to a response from the client;
the only exceptions are `cancel_server_request` and `server_error`, which can
be sent at any time (except to interrupt the request half of a server request
or response half of a server response, in which case they will be delayed
until the server is done sending its current request/response).


display_menu
------------

Requests the client to display a menu to the user (either simply for display,
or to allow them to make a selection), until the user makes a selection or the
server cancels the request.

TODO: The API is inherently prone to buffer length mismatches.

Request arguments:
  * `enum nh_pick_type how`: a specification of how many items the user can
    choose from the menu:     
      * `PICK_NONE` = 0: the user cannot select items, the menu is purely used
        to present information to the user;
      * `PICK_ONE` = 1: the user can pick one item from the menu;
      * `PICK_ANY` = 2: the user can pick zero or more items from the menu
  * `int icount`: the length of `items`
  * `struct nh_menuitem[] items`: the menu items:
      * `charcode accel`: a recommended accelerator for this menu entry
      * `string caption`: the text of the menu entry
      * `charcode group_accel`: a secondary recommended accelerator (which may
        apply to more than one entry; if it does, a `PICK_ANY` menu should
        toggle all entries with the `group_accel` if the user presses it)
      * `int id`: a value to return in the `display_menu` response; if `id`
        and `accel` are both 0, then the item is unselectable
      * `enum nh_menuitem_role role`: what sort of entry this is:
          * `MI_TEXT`: a line of text that is logically grouped together even
            if it runs across multiple menu entries;
          * `MI_NORMAL`: a normal menu item;
          * `MI_HEADING`: a heading
      * `boolean selected`: whether this menu item should be selected by
        default (in a `PICK_ANY` menu, where choosing an item does not close
        the menu, choosing an item should toggle its selection state)
  * `enum placement_hint plhint`: a suggestion for a sensibleplcae on the
    screen to place this menu, and styling for the menu (TODO: many of these
    are unimplemented in nhcurses):
      * `PLHINT_ANYWHERE` = 0: no suggested location;
      * `PLHINT_LEFT` = 1: towards the left side of the screen;
      * `PLHINT_RIGHT` = 2: towards the right side of the screen;
      * `PLHINT_URGENT` = 3: appropriate styling for an important message;
      * `PLHINT_INFO` = 4: appropriate styling for an informational message;
      * `PLHINT_ONELINER` = 5: in the message area;
      * `PLHINT_CONTAINER` = 6: an appropriate location for container
        contents;
      * `PLHINT_INVENTORY` = 7: over the inventory area (if any)
  * `string title`: the title of the menu

Response arguments:
  * `int[] results`: a list of the `id` of all selected items after the menu
    was closed; this should be empty for `PICK_NONE` or if the menu was
    cancelled via server or client, empty or a single element for `PICK_ONE`,
    and any subset of elements for `PICK_ANY`,
  * `enum nh_client_response return`: an explanation of how the menu was
    closed:
      * `NHCR_ACCEPTED` = 0: pressing Return (or similar), scrolling off the
        end, or (for `PICK_ONE`) selecting an item;
      * `NHCR_CLIENT_CANCEL` = 1: pressing Escape (or similar)
      * `NHCR_SERVER_CANCEL` = 2: as a result of a `cancel_server_request`
        message


display_objects
---------------

A variant of `display_menu` specialised for inventory menus.  It provides extra
information and allows the user to specify partial stacks of items in addition
to full stacks.

Request arguments: same as `display_menu`, except for `items`:
  * `struct nh_objitem[] items`: the menu items (sent as an array, not an
    object, with elements in the order shown here):
      * `string caption`: as in `display_menu`
      * `int id`: as in `display_menu`
      * `enum nh_menuitem_role role`: as in `display_menu`
      * `int count`: the number of objects in the stack
      * `int otype`: the obfuscated object type; I think this is an index into
        the `objects[]` returned from `get_drawing_info`, but I'm not sure
      * `int oclass`: the object class (are these listed anywhere public?)
      * `int weight`: the object's weight, negative numbers means unknown
      * `enum nh_bucstatus buc`: the object's beatitude:
          * `B_UNKNOWN` = 0: unknown beatitude;
          * `B_BLESSED` = 1: blessed;
          * `B_UNCURSED` = 2: neither blessed nor cursed;
          * `B_CURSED` = 3: cursed
      * `charcode accel`: as in `display_menu`
      * `charcode group_accel`: as in `display_menu`
      * `boolean worn`: true if the object is equipped

Response arguments:
  * `struct nh_objresult[] pick_list`: a list of all selected items after the
    menu ws closed, as with `display_menu`, but with more information:
      * `int id`: the `id` specified for this item in the request
      * `int count`: the size of a partial stack specified for this item, or
        -1 to select the entire stack; should be -1, or between 1 and the stack
        size minus 1
  * `enum nh_client_response return`: as in `display_menu`


getdir
------

Requests a direction from the user (can be cancelled by the user or the
server).

Request arguments:
  * `string query`: a message to print along with the direction request (the
    generic message is along the lines of "In which direction?", but the
    message is often more specific, similar to "Zap your wand in which
    direction?").
  * `boolean restricted`: if true, the client should act as though diagonal
    directions do not exist for the purpose of its help text (applies when the
    player is polymorphed into a grid bug)

Response arguments:
  * `enum nh_direction return`: The selected direction:
      * `DIR_W` = 0: west (`h`, `4`)
      * `DIR_NW` = 1: northwest (`y`, `7`)
      * `DIR_N` = 2: north (`k`, `8`)
      * `DIR_NE` = 3: northeast (`u`, `9`)
      * `DIR_E` = 4: east (`l`, `6`)
      * `DIR_SE` = 5: southeast (`n`, `3`)
      * `DIR_S` = 6: south (`j`, `2`)
      * `DIR_SW` = 7: southwest (`b`, `1`)
      * `DIR_UP` = 8: up (`<`)
      * `DIR_DOWN` = 9: down (`>`)
      * `DIR_SELF` = 10: at self (`.` or `s`)
      * `DIR_NONE` = -1: the user cancelled the prompt
      * `DIR_SERVERCANCEL` = -2: the server cancelled the prompt


getline
-------

Requests a line of input from the user (can be cancelled by the user or the
server).

Request arguments:
  * `string query`: The prompt to display along with the request for a line.

Response arguments:
  * `string line`: The line of input from the user. Is the null string if the
    null string was entered, a single ESC character (hex 1B) if the user
    cancelled the prompt, and two ESC characters if the server cancelled the
    prompt.


getpos
------

Requests a map location from the user (can be cancelled by the user or the
server).

Request arguments:
  * `boolean force`: if true, the client should make it difficult for the user
    to cancel the prompt (TODO: the idea behind thies option is bad)
  * `string goal`: a description of what the user is supposd to select
  * `coordinate x`: the x coordinate to originally place the cursor at
  * `coordinate y`: the y coordinate to originally place the cursor at

Response arguments:
  * `enum nh_client_response return`: information on how the prompt was closed:
      * `NHCR_ACCEPTED` = 0: the user accepted the location using the most
        ordinary input (usually `.`);
      * `NHCR_CLIENT_CANCEL` = 1: the user cancelled the location prompt
        (e.g. via ESC);
      * `NHCR_SERVER_CANCEL` = 2: the server cancelled the prompt;
      * `NHCR_CONTINUE` = 3: the user accepted the location, requesting to
        continue choosing locations (normally accomplished via `,`);
      * `NHCR_MOREINFO` = 4: the user accepted the location, requesting more
        information about it (normally accomplished via `:`);
      * `NHCR_MOREINFO_CONTINUE` = 5: a combination of the two previous cases
        (normally accomplished via `;`).
  * `coordinate x`: the x coordinate chosen by the user
  * `coordinate y`: the y coordinate chosen by the user


query_key
---------

Inputs one keypress from the user, potentially with a repeat count beforehand.
(TODO: This seems to be assuming ASCII and non-special-key, or at least, it's
sending curses/uncursed keycodes directly to the server.)  As always, can be
cancelled by the user or the server.

Request arguments:
  * `boolean allow_count`: whether to allow a repeat count
  * `string query`: what prompt to display to the user

Response arguments:
  * `int count`: the repeat count, -1 if none was given; this is supplied
    even if `allow_count` is false, but is always -1 in that case and should
    be ignored
  * `charcode return`: the key the user pressed; this is ESC if cancelled by
    the user, NUL if cancelled by the server


yn
---

Requests the user to choose from a short list of choices represented by ASCII
characters.

Request arguments:
  * `string query`: the prompt to print to the user
  * `string set`: a list of appropriate responses; if ESC is included in the
    list, it does not mean that ESC is an appropriate response, but rather, it
    means that all responses after the ESC should be hidden from the user
  * `charcode def`: the default value to return in the case of a user cancel
    (this will be shown to the user in many interfaces)

Response arguments:
  * `charcode return`: the choice the user chose; this is `def` if cancelled
    by the user, NUL if cancelled by the server


server_error
------------

Called by the server if something goes unrecoverably wrong.  The server closes
the connection immediately after sending this, so sending a response is futile
and not particularly useful.  (For the same sort of message directed in the
opposite direction, see `exit_game`.)

Request arguments:
  * `boolean error`: true if the error is caused by something that the client
    did, false if the error is internal to the server
  * `string message`: a description of what went wrong, which can be displayed
    to the user

No response.


cancel_server_request
---------------------

Called by the server to countermand a previous request to the client.  This
message is not responded to in the normal way.  Rather, if the client is
currently waiting on user input, it instead responds immediately to the
current request using a special response that means "cancelled by server".
These responses are matched to the API of the individual client responses, and
specified above.  If the client is not currently waiting on user input, it
waits to respond to the `cancel_server_request` request until it would next
accept user input, and sends the appropriate special response to its current
request.

It is possible that the client receives a `cancel_server_request` when it does
not have a current request to handle.  In this case, and only this case, it
sends a `cancel_server_request` response as normal.


Request arguments: none

Response arguments: none


Display elements
================

Any message sent by the server, whether as a request or a response, might have
a `display` element attached, which specifies updates to the map.  The
exceptions are `auth`, `register`, and `cancel_server_request`, which never
carry map data.  The `display` element is an array of elements to draw; each
element can be one of the below types.


delay_output
------------

Specifies that the client should wait for a short time at this point before
doing any further rendering.

Arguments: `nil`.


display_buffer
--------------

Specifies that the client should display text to the user.  (The text may be
quite long, and should be word-wrapped and tab-expanded.)

Arguments: an object:
  * `string buf`: the text to display
  * `boolean trymove`: appears to be unused


level_changed
-------------

Specifies that the client should change its level display mode.

TODO: make this an enum.

Arguments: an integer:
  * `LDM_DEFAULT` = 0: normal display;
  * `LDM_HELL` = 1: display appropriate for Gehennom;
  * `LDM_QUEST` = 2: display appropriate for the Quest;
  * `LDM_MINES` = 3: display appropriate for the Mines;
  * `LDM_SOKOBAN` = 4: display appropriate for Sokoban;
  * `LDM_ROGUE` = 5: display appropriate for the Rogue level;
  * `LDM_KNOX` = 6: display appropriate for Fort Ludios


list_items
----------

Specifies a list of items in inventory or on the floor.

TODO: The API of this is vulnerable to length mismatches.

Arguments: an object:
  * `int icount`: length of `items`
  * `boolean invent`: true means that this list is the player's inventory;
    false means that this list is the list of items on the ground
  * `struct nh_objitem[] items`: the list of items about which the client is
    being informed


outrip
------

Shows an appropriate message to reflect character death (and similar
game-over situations like ascension).

TODO: The API of this is vulnerable to length mismatches.

Arguments: an object:
  * `int gold`: amount of gold upon death
  * `int how`: as `end_how` in `get_topten`
  * `int icount`: length of `items`
  * `struct nh_menuitem[] items`: list of messages to print; only the
    `caption` field is used. TODO: There has to be a better API for this!
  * `string killbuf`: the cause of the game over
  * `string name`: the name of the character whose game ended
  * `boolean tombstone`: true to request the drawing of a tombstone graphic;
    false presents the information entirely as text
  * `int year`: a year to draw on the tombstone


pause
-----

Wait for user input in order to give the user a chance to read messages or
look at the map.

TODO: This has a pretty weird interaction with server cancel requests.  It
should probably be made a server request, not a display element.

Arguments: an enum nh_pause_reason:
  * `P_MESSAGE` = 0: give the user a chance to read the message area
  * `P_MAP` = 1: give the user a chance to look at the map


print_message
-------------

Print a message in the message area.

TODO: This API is badly designed and has caused several bugs.

Arguments: an object:
  * `string msg`: the message to print
  * `int turn`: the turn on which the message was sent


print_message_nonblocking
-------------------------

Print a message in the message area.  This message is not important enough to
ensure that the user sees it, and the client should aim to prevent this
forcing a --More-- or similar.

Arguments: as print_message


raw_print
---------

Display a message to the user, attempting to bypass the standard rendering and
just displaying the message directly on a console, perhaps after the program
exits.  (This is typically used to make a record of error messages.)

Arguments: a string, the message to print


update_screen
-------------

Change what is displayed at a particular map location.

Arguments: an object:
  * `mapdelta dbuf`: the map delta, in compressed form (see below)
  * `coordinate ux`: the character's x location; if this is 0, instead hide
    the cursor altogether
  * `coordinate uy`: the character's y location

A map delta can be an integer 0 if nothing at all has changed.  Otherwise it
is a list of column deltas.  A column delta of 0 means that column is empty,
and 1 means it is unchanged since last time.  Otherwise a column delta is a
list of cell deltas.  Again, 0 means empty, 1 means unchanged.  Otherwise the
cell delta is an `int[10]`, mostly of indexes into the arrays returned by
`get_drawing_info`:

  * [0] encoded effect number: the encoding is quite complex, see `draw_map`
    in `libnethack/src/map.c` for an example on how to decode it; it
    eventually decodes into offsets into `effects`, `zapsyms`, `zaptypes`,
    `swallowsyms`, `explsyms`, and/or `expltypes`
  * [1] index into `bgelements`
  * [2] index into `traps`
  * [3] index into `objects`
  * [4] index into `monsters`, representing the monster associated with an
    object (e.g. "lichen" for "lichen corpse")
  * [5] index into `monsters`, representing a monster on that square
  * [6] a bitmask that represents details of a monster on the square:
      * `MON_TAME` = 1: the monster is tame
      * `MON_RIDDEN` = 2: this monster has the player riding it
      * `MON_DETECTED` = 4: this monster is seen via monster detection
      * `MON_WARNING` = 8: this is a warning symbol, not a monster
      * `MON_PEACEFUL` = 16: the monster is peaceful
  * [7] a bitmask that represents any branding of the square:
      * `NH_BRANDING_STEPPED` = 1: the player has stepped on the square
      * `NH_BRANDING_LOCKED` = 2: the player knows this door is locked
      * `NH_BRANDING_UNLOCKED` = 4: the player knows this door is unlocked
      * `NH_BRANDING_TRAPPED` = 8: the player knows this square is trapped
      * `NH_BRANDING_UNTRAPPED` = 16: the player knows this door is untrapped
  * [8] index into `invis`
  * [9] a boolean, not an int; true if the character can see this square

Indexes have 1 added to them, so that 0 can represent the lack of the
appropriate sort of drawable entity on the square.


update_status
-------------

Updates the character's status information.

Arguments: an object:
  * `int ac`: the character's AC (10 = unarmored, lower is better)
  * `int align`: the character's alignment (TODO: what format?)
  * `boolean can_enhance`: true if the #enhance command is usable
  * `int ch`: the character's Charisma stat
  * `int co`: the character's Constitution stat
  * `charcode coinsym`: the character to use to represent money
  * `int cur_monnum`: the species the character is polymorphed into (an index
    into `monsters` returned from `get_drawing_info`)
  * `int dx`: the character's Dexterity stat
  * `int en`: the character's current Pw
  * `int enmax`: the character's maximum Pw
  * `int gold`: the character's gold in open inventory
  * `int hp`: the character's current HP
  * `int hpmax`: the character's maximum HP
  * `int in`: the character's Intelligence stat
  * `int level`: the character's experience level
  * `string level_desc`: a textual description of the character's current
    dungeon level
  * `int max_rank_sz`: the maximum possible width of a character's
    professional title, given their role, even if they change gender or level
  * `int monnum`: the species that the character is naturally (an index
    into `monsters` returned from `get_drawing_info`)
  * `int moves`: the number of turns this game has lasted (1 for the first
    turn)
  * `int plname`: the character's name
  * `string rank`: the character's professional title
  * `int score`: the character's current score
  * `int st`: the integer part of the character's Strength stat
  * `int st_extra`: the fractional part of the character's Strength stat
  * `string[] statusitems`: a list of status lights currently affecting the
    character
  * `int wi`: the character's Wisdom stat
  * `int x`: the character's x coordinate
  * `int xp`: the character's total number of gained experience points (minus
    any lost to level drain)
  * `int y`: the character's y coordinate
  * `int z`: the character's z coordinate
